design extensible componentbased groupware tailoring identified key requirement cscw applications one major tailoring mechanism extension application runtime change behaviorthis article shows synchronous cscw componentbased applications designed extensible runtime propose split act tailoring two steps designtime customization new components visual builder tools insertion running application thus customization tool required part applicationthis article presents new design pattern extensibility gives several examples based pattern help pattern extensible application frameworks systematically created nonextensible application design different possibilities place insertion points application design discussed respect flexibility ease deployment finally present advantages limitations approach b introduction human beings interact different situations cooperative actions depend context rather following predefined schedule events people tend act spontaneously creative phases general foreseeable people work together therefore always possible define advance artifacts adequate support cooperative process cscw system reflects observations must allow creation insertion new cooperative modules artifacts inserting new functionality running application act tailoring tailoring recognized cscw literature key requirement system adapt different cooperative contexts malone et al 1995 trigg bdker 1994 bentley dourish 1995 support customization support innovation article focuses one important subset tailoring ability insert new functionality application thus change behavior system new functionality discovered extensible application initialization time harder design applications extended runtime even harder design c publishers printed netherlands extensibility runtime distributed interactive applications synchronous groupware article presents general design pattern solve latter problem componentbased frameworks currently investigated means gain reusability layers adapt change recently software engineering focused development code reusable extensible design phase focus evolved towards development finished modules code reused customized enduser system modifications extensions strictly domain programmer shifted domain enduser article applies findings framework research construction tailorable cscw systems allow insertion extensions demand enduser code extensions distributed demand every participant group thus extensions need preinstalled approach provides possibility extend application without terminating ongoing cooperation goal article demonstrate component technology supports efficient way constructing extensible cscw applica tions component models allow one reason different levels abstraction depending composition level stiemerling cre mers 1998 focus component model java beans supporting integrated development tools ide let user create customize components visually user may assemble components larger composite components using visual representation provided ide rather writing lines code programmers design components accompany special customizers facilitate customization designtime extreme case new component assembled using drag drop operations even endusers accomplish task creating new components using standard widely used java java beans technologies realization concepts become applicable usable groupware developers otherwise stated refer throughout article tailoring activities enduser modify extend application runtime contrast use term designtime customization denote modifications designtime tailoring support extending running program split two different supportsystems customization insertion support figure approach first step enduser uses offtheshelf visual builder tool customize component designtime component second step inserted running cscw application running cscw application figure 1 twostep approach tailor cscw application running distributed cscw application decoupling customization tool components actual cscw application following advantages developer gamma product earlier delivered tailoring functionality built product gamma developer save resources proprietary tailoring tool needs developed general offtheshelf ides continuously improved third party vendors endusers profit decoupling well use favorite builder tool component model need accustom new tool every application show standard visual programming tools used efficiently endusers perform tailoring cscw applications 2 relevant previous work work described article based influenced research different domains relevant work publications tailorability general significance cscw framework design component technology design pattern evolving objectoriented software engineering also new organizational forms business science coordination theory umbrella virtual organizations approaches common focus evolving systems differ points view paper tries synthesize findings 21 tailoring tailoring defined activity modifying appearance behavior application runtime enduser malone et al 1995 mrch 1997 trigg bdker 1994 tailoring support normally built application user need separate tool contrast definition article proposes twostep approach uses customization designtime gain tailorability runtime explaining approach greater detail give brief overview tailoring mrch 1997 distinguishes three levels tailor ing levels classified design distance experienced enduser tailoring first level customization run time allows modify appearance presentation objects change attributes second level allows integration new components commands composition existing functionality within application third level allows extension application adding new code generally speaking increasing level tailoring possibilities user increase also become complex overcome design distance mrch 1995 proposes use called application units application units consist three parts presentationobject userinterface rationale provides metainformation intended use actual implementation tailoring beyond first level involves enduser programming enduser programming facilities offered application framework radically tailorable tool cscw oval malone et al 1995 enduser write small scripts interpreted application applications microsoft office suite solomon 1995 enduser programming also separated application done general purpose language afterwards written functionality inserted application anticipated hooks since programming general purpose language regarded hard enduser must supported high level tools task visual builder tools like ibms visual age java offer even higher abstraction scripting languages thus usable endusers weinreich 1997 follow approach level programming languages possibility reflect introspect code viewed enabling technology write tailorable software reflection component models used support selfrepresentation stiemerling cremers 1998 reflection also viewed design pattern buschmann et al 1996 dourish proposes reflective model collaborative systems dourish 1995 implemented toolkit prospero cscw dourish 1996 using model express metainformation allow change behavior underlying toolkit component models javabeans dcom offer reflection capabilities metadata components krieger adler 1998 approach uses capabilities automate interface negotiation offer enduser easytohandle userinterface tailor components within visual builder tool 22 frameworks towards extensible applications framework skeleton cooperating classes forms reusable implementation application framework defines overall architecture applications created adapting framework frameworkbased applications adapted extending framework explicit hooks also known hot spots pree 1994 frameworks currently successfully employed general purpose software units graphical user interfaces system infrastruc ture middleware integration frameworks also application domain specific frameworks emerging frameworks distinguished whitebox blackbox frameworks schmidt 1997 objectoriented whitebox frameworks use inheritance offer developer extension facilities insert extensions whitebox frameworks developer must understand class hierarchy derive new classes relinked framework blackbox frameworks use object composition delegation instead blackbox frameworks anticipate extensions defining interfaces providing hooks insert new objects applications extended runtime need hooks like blackbox frameworks unfortunately designing frameworks especially blackbox frameworks substantially harder designing ap plication however hot spots framework designed implemented stepwise sequence generalization transformations schmid 1997 since applications using framework must conform frameworks design model collaboration framework encourages developers follow specific design patterns johnson 1997 direction developers use design patterns generalize objectoriented application framework schmid 1995 23 component technology field software engineering component based software development seen major factor facilitate reuse components purchased third party vendors customized assembled within component model examples major component models microsofts distributed component object model dcom suns component model java javabeans javasoft 1996 component technology predicted acquire significantly increasing importance kiely 1998 furthermore distributed component platforms emerging allow interaction components across system boundaries krieger adler 1998 component independent unit software encapsulates design implementation offers interfaces outside may composed components form larger whole dsouza wills 1998 frameworks provide reusable context components johnson 1997 components become powerful within blackbox frameworks used extend hot spots 231 java beans examples article implemented using javabeans component standard java specification javabeans outlines java bean reusable software component manipulated visually builder tool javasoft 1996 beans selfdescriptive java classes follow design patterns let builder tools applications introspect bean properties reflect accessible state bean java beans component model uses event mechanism interconnect beans bean sends event beans registered interest event standard distinguishes two extraordinary states lifecycle bean bean manipulated ide designtime behave like ordinary object runtime properties events manipulated within visual builder tools javabeans standard offers additional associated classes bean contain metainformation bean including special customizers property editors support intuitive interaction developer componentbased approach together visual integrated development environments ides directly support goal able customize existing application designtime able build new similar applications reusing components beans associated customizers allow even nonprogrammers customize applications intuitive way easy grasp achieved use graphical formbased editors within ides 24 design patterns design patterns help one reason recurring design problems objectoriented design patterns describe communicating objects classes customized solve general design problem particular context gamma et al 1994 patterns abstract used programming language provide basis reusable design building blocks design patterns microarchitectural elements frameworks johnson 1997 design patterns surprisingly useful detect hotspots application design transform domainspecific framework design schmid 1995 actually idea hot spots first introduced metapattern framework design pree 1994 domain cscw userinterface design patterns well known distributed versions modelviewcontroller presentationabstractioncontrol patterns buschmann et al 1996 syri 1997 describes use mediator pattern design tailorable cooperation support cscw systems design cscw applications tailorable extension hot spots must discovered design phase implemented ease implementation introduce design pattern used insert hooks application pattern focuses ability insert new code runtime conforms interface applying pattern one thus designs blackbox framework specific cscw problem 25 virtual organizations work also influenced recent publications virtual organization mowshowitz 1997 turoff 1997 idea virtual organization stems virtual constructs virtual memory circuit routing generalizes concepts toward integrating theory one common concept virtual constructs mapping abstract requirement possible concrete satisfier dynamic mapping adapt well evolving requirements changing satisfiers ability virtual organized systems dynamically adapt environmental changes led us think dynamic exchange software components could enhance cscw systems context paper provides technical basis insert new satisfiers running groupware application new requirement arises changes requirements cscw applications result evolving cooperative work patterns example users become familiar cscw product context goal work group changes mark et al 1997 3 enabling technologies extending cscw applications section introduces design pattern used insert hot spots design applications since cscw applications inherently distributed pattern accompanied components allow distribution arbitrary events group using event mechanism encapsulating code within event place event receiver pattern allow simultaneous extension synchronous cscw applications runtime finally investigate applicability inserting code runtime 31 design pattern extensibility component model applications developed interconnecting customizing components components composed smaller components design pattern extensi bility introduced encapsulated one component extensibility pattern 1 intended used provide default behavior changed runtime change behavior new class inserted hook either add new functionality replace existing class application sees specified behavior proxy class structural representation pattern given relationship used classes figure 2 shows structure extensibility pattern uml notation 2 pattern consists proxy extends interface subject may inserted runtime 3 inside proxy exists creator responsible follow convention use initial uppercase letter name patterns use bold names classes use italic names beans events fowler 1997 provides good overview uml notation 3 pattern proxy extends subject interface conform proxy pattern however framework developer important figure 2 structure extensibility pattern create new object arbitrary class real subject conforming interface subject actually pattern combination proxy factory method patterns gamma et al 1994 figure 3 shows interaction objects initialization time creator object passes reference default real subject proxy event proxy receives delegated default real subject creator receives event happens discussed soon create new real subject instantiates respective class sets reference proxy newly created object proxy forwards subsequent events object unless creator changes reference real subject slight variation pattern allows add instances new classes instead replacing old objects easily accomplished letting proxy store set real subjects incoming events forwarded instantiated real sub jects variation useful new functionality added independent application logic already existing objects 32 remote events event based component model events means communicate state changes components event mechanism definition proxy remains stable developer pluggable components real subjects relies stable definition subject proxy class need extend interface may act adapter bridge proxy adapter bridge described gamma et al 1994 c rea tor ins tan tia te de fau lt sub je c hand leeven hand leeven ins tan tia te new sub jec hand leeven hand leeven c rea te new sub jec figure 3 interaction diagram extensibility pattern follows publishersubscriber pattern buschmann et al 1996 java beans component model uses event mechanism concentrate java beans component model chosen implementation design group communication components rely particular component model since event mechanisms common property component models since java beans component model defines interaction beans virtual machine developed group communication beans act access points distribution events process barriers figure 4 group communication beans follow publishersubscriber pattern distributed platform group communication beans expose event model developer remote event communication two types beans necessary groupsender forwards events groupreceivers configured group name group name property beans easily set within visual builder tools beans events visually connected beans beans specialized event simple objectoriented subclassing implementing register handler methods event type thus group communication beans form whitebox framework distributed event communication although definition new events considered programming activity goes beyond usual gs group communication gr gr gr group name group name event event event event components backbone figure 4 group communication beans groupsender gs distributes event subscribed groupreceivers gr capabilities enduser implementation automated within ides thus nearly source coding required developer 33 distributing inserting components readers ask creator extensibility pattern triggered get answers creator encapsulates groupreceiver subscribes group events may arrive carry classes instantiated since java provides platformindependent bytecode directly associate classes events implementations objects would called remotely using corba instance decided actually distribute code since general solution calling remote objects example remote object would difficulties access system dependent resources show new graphical user interface new class event insert new class choose new class gs gr new class event chooser loader figure 5 distribution newclass event distribution new component handled design distribution newclass event beans group communication figure 5 bean acts chooser selects class inserted distributed application often chooser embedded userinterface let user decide class inserted eventually chooser fires newclass event event simply passed chooser bean derived groupsender publishes configured group event received beans extend groupreceiver event type subscribed group groupreceiver passes event loader instantiates class resulting object used creator replace add new real subject combination extensibility pattern group communication beans used extend well specified hot spots distributed applications specification interface subject hot spot defines lot methods component implement methods could used extend hot spot times however feasible constrained interface case truly independent components applications would needed write adapter gamma et al 1994 insert side even components may use available information loading component instead using static information provided interface variation pattern uses reflection mechanisms java java beans connect available hooks figure 6 illustrates concept newclass event arrives loader upon arriving loader loads class instantiates b since loader know time features arrived bean uses introspection discover events fired new bean events interested new class event b b c c event listener event source loader loader loader figure 6 loader receives new class instantiates b loader new object register mutually c loading bean adds interest calling discovered registration methods c loading bean receive events new bean loading bean provides events discovered introspection new bean implements appropriate method connect invokes method loaded bean uses mechanism subscribe events interested newclass event may additionally carry name start method new class bean events connected start method still called thus possible pass arbitrary java programs start remotely newly loaded code interact loading application means two mechanisms mutual registration provided events discovered initialization presented group communication beans latter also used communicate remote applications 34 applicability extensibility cscw applications introduced various levels granularity varying one extreme new applications started extreme every component may extended place number hot spots design determine extensibility application framework number hot spots worsen performance application increases also necessary effort maintenance figure 7 shows level extensibility relates granularity components inserted understandability maintainability enduser mbone tools eriksson 1994 may serve example small successful extensibility user click session directory sdr session starts needed tools join audio video session tools standalone applications started different process medium extensibility granted domain specific frameworks figure 7 tradeoff application extensibility component granularity understandability enduser hot spots teamwave roseman greenberg 1997 groupware application uses custom made component model top groupkit roseman greenberg 1996 offer extensibility tailoring support highest level extensibility would usage extensibility pattern every component system extensibility provided means starting applications new processes original new application must use protocol exchange data normally different local interaction therefore inserting components running application advantage integrated seamlessly new components become part application components interact locally use interaction protocol component model experiments pattern component based cscw applications suggest extensions groupware applications happen anticipated places application uses design patterns hot spots found design phase schmid 1997 however remains art rather pure engineering design extensible applications give examples next sec tion extensibility designed implemented cscw applications 4 examples section gives examples extensibility pattern used design extensible cscw applications first example presents minimal cscw component used distribute start cooperative components use chat component example demonstrate application extensibility pattern insertion voting component chat session highlights use extensibility pattern support unforeseen cooperation modes finally summarize experience using extensibility pattern teleteaching components 41 design minimally extensible cscw application example minimally extensible cscw application loader offers functionality distribute insert coarse grained components actually cscw applications user selects new component insertion code distributed participants group started within instances loader figure 8 loader application visual ide figure 8 shows composition loader within visual ide 4 user interface consists two beans enter participant group name button insert new component user presses button file dialog pops lets user select component choosing component event passed nonvisual controller bean generates newclass event passes groupsender configured group name loaders group members eventually receive newclass event start associated component creator creator loader configured add every received component use reflection capabilities register available events loaded component query properties loader via reflection case finds participant group name presented form loader supports insertion symmetric cscw applications ie applications executed partic ipant example loader used insert components next examples chat voting component also developed loader component asymmetric groupware supports local insertion server component distributes clients component participants 42 design functional extensions wellknown example synchronous cscw application chat chat allows exchange textual messages members 4 subsequent examples built ibms visual age java puzzle piece denotes nonvisual bean puzzle piece brackets variable arrow connection event method dotted line connection two properties figure 9 design extensible input component right chat tool left variable gives access methods variables defining bean input component group example focus design extensible chat present component inserted runtime support simple floor control policy figure 9 shows running chat application component composition designtime input part chat new message distributed chat event participants output part chat component eventually receives event shows user reaction user input performed within bean chatinputcontrolproxy access input field environment properties whenever proxy generates new chat event distributed groupsender event chatgs participants example userinterface additionally offers button insert new component running application figure 10 design chatinputcontrolproxy figure 11 userinterface insertion new component implementation figure shows internals proxy allows replacement default strategy beancreator receive new beans implement interface chatinputcontroli takes default component chatinputcontrol input field current instance input control associated variable type chatin putcontroli depending actual input control bean chat event fired proxy forwards groupsender example implements simple mechanism plug new component running system see figure 11 user clicks insert component button chat application dialog box pops user selects hot spot extend user chooses list available components actual design implementation selection uses components simple loader previously described discussed later sophisticated mechanism used realworld applications add floor control mechanism default implementation chatinputcontrol figure 12 left replaced chatinputfloor control figure 12 right runtime new component displays additional simple userinterface request token input input field chat bean enabled user token also uses groupsenders request release 5 token newly 5 implementation implicitly releases token user sent message server floor control shown figure 12 chatinputcontrolproxy configured default bean chat inputcontrol left replaced chatinputfloorcontrol right support token based floor control policy inserted component interacts seamlessly existing components since implements interface chatinputcontroli design chat components follows simplified modelview controller pattern buschmann et al 1996 insert components provides new behavior designed controller chat input component exchangeable design uses presented extensibility pattern chat components designed similar way another hot spot designed chat output component possible extension would add component write log file discussion chat example shown applicability extensibility pattern change components behavior specially defined hot spots thus classified medium level granularity 43 design second application insertion loader used start one cooperative tool group members example chat tool inserted discussion meeting remote participants decision must made discussed topics chair decides create list topics participant vote one item list chair uses ide customize voting component inserted distributed using loader voting component shown participant participant submitted vote separate frame shows arriving votes others designtime customization vote component easy task question component dropped vote panel within visual figure 13 voting component left associated customizer right ide figure 13 vote panel associated customizer add new questions manipulate provide different language features customizer offers user graphical interface hide details programming enduser performs draganddrop operations fills text fields customizer constructs new voting component information inserted loader distributed participants example shown applicability extensibility pattern coarse grained components support insertion new cooperation forms also validated approach use offthe shelf visual builder tools let end user build new component designtime customizing existing beans distributed inserted running cscw system 44 examples redesigned earlier developed remote education components offer extensibility example placed extensibility pattern remote tutoring components hummes et al 1998b allow insertion arbitrary components supporting cooperation among students tutors tutoring components allow students contact tutor want assistance remote laboratory course tutor gives peertopeer advice using cooperation beans original implementation components cooperation could changed designtime new implementation use several cooperation forms inserting runtime tutor also distribute questionnaires hummes et al 1998a students end laboratory course monitor learning progress tutor prepared questionnaire laboratory course based issues discussed students creation questionnaire highly supported customizers within visual ide presented customizer vote panel actually reused component multiple choice questions teleexam framework 5 discussion examples shown applicability extensibility pattern within component based cscw applications using pattern one actually designs domain specific application frameworks application frameworks extended runtime inserting new components new components created enduser outside application within visual ides examples used extensibility pattern insert coarse medium grained components placement hot spots pattern examples based anticipation possible extensions leads question whether rule given hot spots located main problem conflict exists level extensibility level understandability cfg section 34 component made extensible design implementation would become unnecessary complex even performance affected added complexity could improved example flyweight pattern gamma et al 1994 maintainability criteria still limits amount hot spots hand hot spots limits extensibility application compromise must found depending domain application found design cooperation offers good startingpoint insert hot spots cscw applications components triggered user actions perform operations depending actions candidates extended design application uses design patterns location potential hot spots derived design schmid 1997 case cscw appli cations patterns used cooperation must examined often used modelviewcontroller pattern potential hot spot extension application located controller view would candidate extended locally cooperations use different strategies change strategies placing extensibility pattern within strategy pattern gamma et al 1994 good example adding new strategy component would new algorithm video encoding decoding conference systems mediator pattern gamma et al 1994 used design tailorable 1cscw systems attaching cooperation enablers syri 1997 cooperative artifacts placing extensibility pattern within mediator new enablers could introduced running system presented non exhaustive list potential loca tions hot spots could useful still groupware designer decide hot spots eventually placed analysis oriented domain application new components inserted demand components demand enduser latter case enduser must supported userinterface select appropriate hotspot component obtain certain behavior extension used simple file chooser examples sophisticated approach would present user potential plugpoints list available components available extend one introspecting selected component list created automatically additionally user also get description intent effects possible sideeffects component presented implementation insert components runtime uses code distribution inform remote applications insert new component used group communication beans distribute arbitrary events needed information new components encapsulated event implementation coherent java beans event model thus supported visual builder tools java beans distribution code advantage components access local system properties thus userinterface components also distributed another advantage lays increased performance compared remote object communication inserted component often used biggest advantage cooperative environment component inserted running application needs installed remote machines application started operation loading instantiating classes via network opens severe security risks since java network language risks wellknown methods protection exist java code signed signature authenticates creator code code manipulated signing detected although signed code allows one accept code trustworthy sources problem trust remains cooperative environment question hard answer even persons allowed distribute new code trustworthy failures distributed code cause damage zhang 1997 problem partly solved giving explicit rights customizing code stiemerling cremers 1998 another barrier inserted granting new classes rights need function however class claims need full rights created person full trust problem remains problem generally solved 6 conclusion article focused insertion new components running synchronous cscw applications tailor behavior proposed split act tailoring steps designtime customization new components within visual ides insertion running application decoupling leads shorter development cycle applications furthermore enduser needs accustom one ide tailor different applications ides delivered components approach taken extend cscw applications pluggable builder tools presented design pattern focused modeling insertion points hot spots general way since cscw applications inherently distributed developed components used distribute arbitrary events across process boundaries configurable group receivers group communication components used examples remote event communication extensions implemented java beans distributed remote events automatically inserted provisioned hot spots inserted new components seamlessly integrated within running application independent coarse grained components function also without information environment inserted without conforming predefined interface nevertheless query environment via reflection register events read write properties thus arbitrary applications distributed started remotely presented examples shown use extensibility pattern create hot spots within component based applications article discussed tension extensibility understandability design increasing extensibility increases also complexity design thus decreases understandability leads conclusion design reasonable components extensible exchangeable runtime revisited design patterns used examples find locations hot spots inserted located places compared design patterns literature thus shown extensibility pattern useful design cscw applications however remains still task application designers identify hot spots ex pertise potential insertion points recognized developer uniformly design hot spots using introduced extensibility pattern one problem addressed work extensibility presented enduser presentation include hot spots application possible extensions presentation must find means intuitive graphical userinterface insert components right places 7 acknowledgments want thank david turner proofreading earlier versions article arnd kohrs provided valuable java hints various discussions without help components remote tutoring would never implemented last least want acknowledge detailed comments anonymous reviewers described work part acost research project funded research institute cnet lannion france telecom r communications acm 4010 uml distilled design patterns elements reusable objectoriented software kluwer academic publishers httpwww developing applications microsoft office strategies de signing tr ctr yang du li separating data control support adaptable consistency protocols collaborative systems proceedings 2004 acm conference computer supported cooperative work november 0610 2004 chicago illinois usa jrgen p bansler erling havn sensemaking technologyuse mediation adapting groupware technology organizations computer supported cooperative work v15 n1 p5591 february 2006 yang du li supporting adaptable consistency control structured collaborative workspaces computer supported cooperative work v14 n5 p469503 october 2005 p barthelmess c ellis neem platform evolvable framework perceptual collaborative applications journal intelligent information systems v25 n2 p207240 september 2005
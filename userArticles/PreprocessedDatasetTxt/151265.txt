automatic recognition tractability inference relations procedure given recognizing sets inference rules generate polynomial time decidable inference relations procedure automatically recognize tractability inference rules underlying congruence closure recognition tractability particular rule set constitutes mechanical verification theorem originally proved independently kozen shostak procedure algorithmic rather heuristic class automatically recognizable tractable rule sets precisely characterized series examples rule sets whose tractability nontrivial yet machine recognizable also given technical framework developed viewed first step toward general theory tractable inference relations b introduction certain well known algorithms viewed polynomial time decision procedures inference relations example transitive closure determines whether formula form x proven given inequalities transitivity axiom unionfind procedure determines whether equality proven given equations reflexivity tran sitivity symmetry axioms equality congruence closure procedure determines whether equality proven given set equations symmetry reflexivity transitivity congruence axioms equality 1 algorithms viewed decision procedure inference relation generated certain set inference rules paper identifies general class local rule sets rule sets desirable property generated inference relation polynomial time decidable consider set r inference rules let r inference relation generated r ie relation sigma r phi exists derivation phi sigma using rules r rule set r called local whenever sigma r phi exists local derivation phi sigma derivation local every proper subexpression formula derivation either proper subexpression phi proper subexpression member sigma appears subexpression inference rule r one show rule set r one determine polynomial time size sigma phi whether exists local derivation phi sigma r local ie existence derivation ensures existence local derivation inference relation r polynomial time decideable one easily show rule set consisting single transitivity rule local true rule set underlying unionfind procedure ie reflexivity symmetry transitivity axioms equality rule set underlying congruence closure ie reflexivity symmetry transitivity substitution axioms equality also local although locality rule set difficult prove addition providing theoretical framework study certain class polynomial time algorithms local inference relations provide tool construction general purpose automated reasoning systems sound complete set inference rules first order logic local every local relation polynomial time decidable entailment relation first order logic undecidable however local inference rules used reduce proof length first order proof systems done construction socratic sequent system 2 sequent expression form sigma phi sigma set formulas phi formula sigma r phi say rule set r generates sequent sigma phi socratic sequent system consists two rule sets local rule set set sequent rules sequent generated local set called obvious proof socratic sequent system series sequents sequent either obvious derivable earlier sequents one sequent rules obvious sequents abbreviate long derivations proofs socratic sequent system shorter proofs traditional systems however rule set generating obvious sequents local correctness proof still verified polynomial time particular socratic sequent systems set theory first order logic described 5 4 appears power local rule set socratic sequent system enhanced use nonstandard syntax first order logic aspects syntax english mantague semantics used construct particularly powerful general purpose local rule sets 2 determining locality arbitrary rule set difficult known whether locality property rule sets decidable main result paper certain subclass local rule sets bounded local rule sets mechanically identified precisely exists procedure given arbitrary rule set find counterexample locality whenever rule set local construct proof rule set bounded local whenever bounded local fail terminate cases rule set local bounded local rule set consisting reflexivity symmetry transitivity congruence axioms equality bounded local locality rule set mechanically recognized procedure given amounts mechanical verification theorem given 3 8 7 several novel examples nontrivial bounded local rule sets given paper including rule set based syntax english example also given rule set local bounded local hopefully notion locality described paper first step toward general understanding tractable rule sets several open technical problems several directions research discussed end paper better understanding tractable inference relations hopefully result improved technology construction semiautomated verification systems deeper understanding inference general f figure 1 tractable set boolean inference rules preliminary definitions paper presents general procedure recognizing certain cases set inference rules generates computationally tractable inference rela tion first step constructing procedure precisely define notion inference rule figure 1 gives basic inference rules boolean connectives rules question mark front indicates variable replaced different expressions different applications rule variables inference rules called metavariables distinguish variables underlying language throughout remainder paper let b boolean denote set inference rules given figure 1 boolean expressions written terms two universal connectives rule set b expresses inferential properties connectives inference relation generated rules linear time decidable yet inference rules augmented simple case analysis sequent rule rules become complete boolean inference another example set inference rules consider following rules equality rules 12 13 14 express symmetry reflexivity transitivity properties equality respectively rule 15 expresses substitutivity equals equals well known congruence closure provides polynomial time decision procedure inference relation generated equality rules precise notion inference rule developed general enough allow notation used rule 15 fortu nately however inference problem involving function symbols two arguments converted equivalent problem involving function symbols two arguments example function f three arguments replaced two functions pair f 0 loss generality replace rule 15 following two rules remainder paper let e denote rule set consisting rules 12 13 14 15a 15b different metavariables different syntactic kinds example metavariables appear boolean rule set b range formulas rule set e metavariables range terms metavariables range function symbols phrases formula term monadic function refer particular syntactic kind syntactic kind either kind symbol expression form oe 1 theta oe 2 oe syntactic kinds expression either constant symbol metavari able given syntactic kind application form expression kind oe 1 expression kind oe latter case expression kind first order predicate calculus ordinary constant symbol constant kind term proposition symbol constant kind formula function symbol constant kind term predicate symbol constant kind term formula boolean connectives constants kind formula theta formula formula respectively quantifierfree predicate calculus language generated set constants type term set constants type formula set function symbols set predicate including equality boolean connectives expression sometimes written ffi e occasionally e 1 definitions allow quantified expressions paper discusses inference rules involve quantification even without quantifiers set rules still generate undecidable intractable inference relation hand presence quantifiers necessarily prevent tractability tractable inference relations involving quantification discussed 5 4 general notion locality needed construct procedure automatically recognizing tractability rule sets involve quantification expression kind formula called formula inference rule object form theta theta formulas metavariable substitution mapping ae metavariables expressions metavariable x aex expression kind x definition metavariable substitution ae expression define aes result replacing metavari able image ae set expressions upsilon define aeupsilon set observation metavariable substitution ae expression aes expression syntactic kind derivable set formulas sigma inference rules r exists inference rule theta r metavariable substitution ae aepsi 1 members sigma aetheta equals phi derivation phi sigma sequence formulas psi either member sigma onestep derivable r previous elements sequence psi n formula phi exists derivation phi sigma rule set r write sigma r phi note r relation generated r standard way interested finding general properties rule set r guarantee corresponding inference relation r polynomial time decidable one way consider restricted relation r explicitly constructed polynomial time decidable done using following terminology called label formula set expressionsomega every proper subexpression psi member omegagamma set formulas gamma rule set r define gamma set proper subexpressions formulas plus closed variablefree proper subexpressions formulas r note finite rule set r finite formula set gamma finite however formula constant formula metavariable label formula expression set implies expression set infinite set label formulas spite infinity label formulas however restricting inference process label formulas small finite set yields tractable inference relation write sigma r phi exists derivation phi sigma rule set r psi label formula omegagamma r sigma fphig tractability lemma finite rule set r relation r polynomial time decidable set rules r called local relation r relation r tractability lemma implies inference relation generated local rule set polynomial time decidable proof refined version tractability lemma given appendix example consider problem determining whether sigma e phi phi formula sigma equation first order terms e equality rule set rules 12 13 14 15a 15b expression equality symbol plus first order terms appear sigma phi terms omegagamma e sigma fphig equation label formula omegagamma e sigma fphig let n total size sigma fphig order n 2 equations label formulas omegagamma e sigma fphig implies one enumerate polynomial time label formulas omegagamma e sigma fphig derived sigma using derivations restricted label formulas definition locality provide obvious way determining given rule set local locality equality inference rules originally proved using different terminology independently kozen 3 shostak 8 kozen uses syntactic argument show sigma e phi phi proof essentially induction length derivation used establish sigma e phi shostaks proof locality e semantic shostak observes relation e clearly sound standard semantics equality furthermore sigma 6 e phi one construct model sigma phi false words relation e semantically complete since e sound e least strong semantic completeness e implies e e semantic proof using simpler model construction later given nelson oppen 7 semantic proofs locality compact many cases syntactic proofs results however seems difficult generalize semantic proof techniques point used mechanically recognize wide class local rule sets following section shows syntactic techniques used construct general locality recognition procedure 4 syntactic proofs locality finite rule set r relation r polynomial time decidable rule set r local relation r relation r general syntactic approach proving locality particular rule sets constructed using following definitions set expressions upsilon called subexpression closed every subexpression every member upsilon also member upsilon r rule set sigma formula set let upsilon expression set subexpression closed contains subset set cr sigma upsilon defined set formulas psi exists derivation psi sigma every formula appearing derivation label formula upsilon fphig say set cr sigma upsilon universal cr sigma upsilon contains label formulas upsilon lemma let r fixed rule set let sigma formula set let upsilon subexpression closed set sigma one determine whether cr sigma upsilon universal time polynomial size upsilon cr sigma upsilon universal finite enumerated time polynomial size upsilon proof lemma given similar proof refined tractability lemma given appendix possible characterize locality terms closure operator cr rather inference relation r need additional terminology one step extension subexpression closed set upsilon expression ff member upsilon every proper subexpression ff member upsilon extension event rule set r fourtuple upsilon upsilon subexpression closed contains one step extension upsilon psi member letters used denote extension events consider extension event ff psi sigma upsilon note formula psi may old sense psi may member cr sigma upsilon alternatively psi may new sense psi member cr sigma upsilon fffg member cr sigma upsilon lemma given states rule set r local impossible new formula label formula old set upsilon feedback event rule set r extension event ff psi sigma upsilon r psi label formula upsilon member cr sigma upsilon lemma rule set r local feedback events r proof first suppose exists feedback event e r components ff psi sigma upsilon fact psi member cr sigma upsilon fffg implies sigma r psi fact e feedback event implies psi label formula upsilon member cr sigma upsilon fact psi label formula upsilon implies upsilon must member cr sigma omegagamma r sigma fpsig sigma 6 r psi thus r r different r local argument shows r local feedback events r show converse feedback events r r local suppose feedback events r consider sigma phi sigma 6 r phi show r local suffices show sigma 6 r phi show sigma 6 r phi suffices show finite subexpression closed set upsilon phi phi 62 cr sigma upsilon assumption phi 62 cr sigma omegagamma r sigma fphig let upsilon subexpression closed set phi 62 cr sigma upsilon onestep extension ff upsilon phi member cr sigma upsilon fffg otherwise tuple ff phi sigma upsilon would feedback event induction implies phi member cr sigma upsilon finite subexpression closed set upsilon containing thus sigma 6 r phi lemma reduces problem determining locality problem determining existence feedback events locality recognition procedure based general method proving nonexistence feedback events general method best introduced using simple example consider following rules expressing monotonicity operator f let monotonicity set three inference rules 1 wish prove nonexistence feedback events consider extension event ff psi sigma upsilon rules either psi old formula ie member cm sigma upsilon psi provable old formulas using inference rules possible characterize ways proving new formula old formulas using rules specifically extension event one following four conditions must hold ffl psi old formula ie member cm sigma upsilon ffl psi formula ff ff ffl ff form fs psi formula form ff cm sigma upsilon contains formulas u fu ffl ff form fs psi formula form ff cm sigma upsilon contains formulas fu u extension event satisfies one conditions either psi old formula first condition psi contains ff proper subexpression last three conditions thus psi either old formula psi label formula upsilon extension event satisfying one conditions feedback event problem proving nonexistence feedback events reduced problem proving every extension event satisfies one four conditions done using following definitions let r rule set sigma formula set upsilon subexpression closed set let ff one step extension upsilon definition set c ff0 r sigma upsilon defined cr sigma upsilon set c ffj1 r sigma upsilon defined c ffj r sigma upsilon plus label formulas upsilon fffg derived c ffj r sigma upsilon via single application inference rule r indepth analysis computational complexity relation given r sigma upsilon consider fixed arbitrary sigma upsilon ff show nonexistence feedback events suffices show every formula psi cm sigma upsilon fffg satisfies one four conditions respect sigma upsilon ff four conditions viewed defining four different types formulas set cm sigma upsilon fffg prove every formula cm sigma upsilon fffg one four types suffices prove induction j every formula c ffj sigma upsilon one four types every formula sigma upsilon old formula formula first type assume every formula c ffj sigma upsilon one four given types assumption one prove every formula psi c ffj1 sigma upsilon one given types induction step involves case analysis proof rule used derive element c ffj1 sigma upsilon types formulas used antecedents application rule method described proving locality rule set generalized mechanical procedure recognizing locality 5 locality recognition procedure mechanical locality recognition procedure guaranteed recognize local rule sets however possible precisely characterize class rule sets whose locality mechanically recognizable procedure precise characterization involves additional terminology definition rank extension event ff psi sigma upsilon rule set r least natural number j psi element c ffj r sigma upsilon definition natural number k rule set r say r kboundedlocal r local extension events r rank k less rule set r boundedlocal whenever exists k r kboundedlocal note r kboundedlocal cr sigma upsilon fffg always equal c ffk r sigma upsilon would seem boundedlocality extremely strong condition inference rules rule sets would satisfy condi tion however examples local inference rules discussed boundedlocal rule sets e 2boundedlocal b 1bounded local unfortunately rule sets local boundedlocal let consist reflexivity rule 16 transitivity rule 17 plus rules 19 20 21 given rule set local boundedlocal proof left nontrivial exercise reader 19 given local although boundedlocal refined tractability lemma implies generated inference relation decidable order n 3 time transitivity rule order 3 following two theorems main results paper first locality recognition theorem rule set r bound k possible determine whether r kbounded local second locality recognition theorem exists procedure given rule set r following ffl r local procedure terminates outputs feedback event r ffl r boundedlocal procedure terminates outputs least k r kboundedlocal plus enumeration possible types extension events ffl r local boundedlocal procedure fails terminate consider proof locality monotonicity rules described preceding section proof shows every monotonicity extension event falls one four types extension event types feedback event mechanize proof technique need way formally represent extension event types consider third monotonicity extension event type given preceding section ffl ff form fs psi formula form ff cm sigma upsilon contains formulas u fu extension events type characterized specifying form ff form psi certain formulas must cr sigma upsilon general allow formal specification extension event type also include specification expressions must upsilon formal specification extension event type fourtuple ff ff 0 psi 0 patterns giving form ff psi respectively sigma 0 set formulas must included cr sigma upsilon upsilon 0 set expressions must included upsilon patterns ff 0 psi 0 expressions containing metavariables type monotonicity extension event characterized following formal fourtuple fourtuple specifies class extension events ff form fs psi form ff cr sigma upsilon contains four tuple note upsilon 0 constructed upsilon 0 subexpression closed set containing onestep extension upsilon 0 fact tuple ff conditions given definition extension event tuple extension event general extension event containing metavariables defines entire class instantiations extension event extension event ff psi sigma upsilon let extension event say e rinstance template e 0 template e 0 rcovers extension event e exists metavariable substitution ae satisfying following conditions say template set 1 rcovers event set 2 every member 2 rcovered member 1 often say covers instance rather rcovers r instance respectively rule set clear context use term event template template rather term exten sion event describe extension events used templates schemas whole class extension events following lemmas state useful properties extension event templates let e ff psi sigma upsilon let e 0 ff instance e 0 virtue metavariable substitution ae lemma set aec r sigma subset cr sigma upsilon proof consider formula theta cr sigma must show aetheta member cr sigma upsilon consider derivation theta sigma 0 formulas derivation label formulas upsilon 0 let aed derivation derived replacing expression image substitution ae aed derivation aetheta aesigma 0 furthermore since aeupsilon 0 subset upsilon every formula aed label formula upsilon since every element aesigma 0 cr sigma upsilon must aetheta also cr sigma upsilon lemma natural number j set aec ff 0 j subset c ffj r sigma upsilon proof proof induction j previous lemma establishes result assume result holds j consider j theta formula c ff 0 j1 must show aetheta c ffj1 r sigma upsilon theta derivable via single inference rule formulas phi induction hypothesis aephi c ffj r sigma upsilon aetheta derivable aephi 1 aetheta label formula upsilon fffg thus aetheta c ffj1 r sigma upsilon lemma rank e less equal rank e 0 proof let j rank e 0 formula psi 0 c ff 0 j lemma aepsi 0 must c ffj r sigma upsilon since aepsi 0 equals psi extension event e must rank j less feedback event e feedback event feedback event formula psi 0 either member cr sigma label formula upsilon 0 first case lemma implies aepsi 0 hence psi member cr sigma upsilon suppose psi label formula upsilon since psi 0 label formula upsilon 0 fff 0 g label formula upsilon 0 expression ff 0 must proper subexpression psi 0 implies aeff 0 proper subexpression thus ff proper subexpression psi implies psi label formula upsilon thus e feedback event locality recognition procedure takes boundedlocal rule set r automatically constructs proof locality r using technique used proving locality rule set proof locality involved showing every extension event instance one four specific templates order construct analogous proof arbitrary boundedlocal rule set r procedure must generate finite set extension event templates specific rule set r must show finite set extension event templates covers extension events r recognition procedure uses single process generate extension event templates prove generated templates cover extension events process starts set null templates generates new templates iteratively passing existing templates inference rules definition null template kind ff psi fpsig fg ff metavariable kind extension event rank 0 instance null template without loss generality consider syntactic kinds used inference rules need consider finite set null templates following lifting lemma states existence procedure passing templates inference rules lifting lemma let r finite rule set let finite template set covers extension events r rank less possible compute finite template set rt covers extension events rank less proof lifting lemma procedure computing rt given appendix ii definition rule set r define 0 r set null templates define j1 r covers every extension event r rank j less lemma r local j j r contains feedback event proof suppose exists feedback event r extension event must finite rank j must covered element j r templates feedback events 2 efficient definition states j1 r equals j r plus elements already covered element j r cover feedback events j r must contain feedback event lemma r jboundedlocal j r contain feedback events j r covers rt j r every member j r rank j less 3 proof first suppose j r covers rt j r since covering transitive implies j r covers extension events less argument implies covers extension events rank less fact covers extension events addition j r contain feedback events feedback events r r must local templates j r rank less since template cover extension event greater rank extension events r must rank j less suppose r jbounded local since feedback events r j r must contain feedback event since every extension event rank j less j r must cover extension events implies j r covers rt j r finally since extension events r rank j less every template j r must rank j less recognition theorems follow directly lemmas procedure based lemmas implemented claims made paper boundedlocality particular rule sets mechanically verified 6 additional examples section presents additional examples boundedlocal rule sets examples intended support hypothesis boundedlocal rule sets 3 natural procedure constructing rt ensures every extension event j r rank j less quite common easily constructed examples also intended support hypothesis recognizing locality usually difficult three examples local rule sets discussed boolean rule set b equality rule set e monotonicity rule set additional examples boundedlocal rule sets derived considering various unions rule sets eg turns unions boundedlocal general however union local rule sets need local similarly subset local rule set need local locality various combinations b e determined mechanical verification except rule set b 1boundedlocal combinations rule sets b e 2boundedlocal next example rule set based syntactic structure english montague semantics rules involve expressions three different syntactic kinds class expressions specified noun phrases formulas expressions given simple semantics class expression denotes set formula denotes truth value specified noun phrase denotes operator maps sets truth values second order predicate example x denotes set every x specified noun phrase denotes second order predicate true set case set x subset set formula form every x true case x similarly formula form x true case element set x member set ie case x nonempty binary relation r class expression c let r c r every c class expressions example let kissed binary relation let man woman class expression constants class expressions kissed woman kissed every woman formulas every man kissed woman alternatively man kissed every woman meaning expressions form r c r every c defined formulas natural meaning inference rules shown figure 2 sound natural semantics let n natural set inference rules given figure 2 runs 22 every x x every x every z every x z x x x x x 26 x every z x z every x every r x r 28 every x every r every r every x 29 x every r every x r figure 2 natural rule set rule set n local however notion locality used construct polynomial time decision procedure relation n first see n local note combining inference rules 25 c n every r every r c however derivation expression occurs proper subexpression formula derivation appear statement inference problem cs 6 n every r every r c spite fact n local locality recognition procedure used show relation n polynomial time decidable let n 0 rule set constructed n replacing formulas form every c c formulas form isevery c issome c respectively formula phi set formulas sigma similarly define phi 0 sigma 0 sigma n phi sigma 0 n 0 phi 0 suffices show n 0 polynomial time decidable one machineverify fact n 0 4boundedlocal refined tractability lemma implies exists order n 3 decision procedure relation n 0 several technical questions remain unanswered first although procedure shows kbounded locality decidable arbitrary rule sets known whether unbounded locality decidable another open question regards inference relations rather rule sets inference relation called local generated local rule set possible rule set r nonlocal yet relation r generated rule set r 0 r 0 local relation r local even though r given rule set r one determine relation r local say relation kboundedlocal generated kboundedlocal rule set one determine r kboundedlocal seems likely definition locality improved consider natural rule set n given rule set local trivial syntactic transformation yields essentially equivalent boundedlocal rule set n 0 general replacing formulas form p formulas form p currying predicate p transform local rule set one local fact locality sensitive trivial syntactic changes suggests robust notion locality possible ideally definition locality property locality arbitrary rule set decidable locality rule set guarantees generated inference relation polynomial time decidable class local relations closed certain simple syntactic transformations currying improved notion locality might also lead improvements refined tractability lemma ideally one able mechanically recognize boolean inference relation linear time decidable rather quadratic tractability lemma would indicate similarly single rule transitivity generates relation decidable linear time rather cubic examples efficient algorithm viewed tighter restriction forward chaining inference automatic construction fast congruence closure algorithm perhaps much expect fast congruence closure simply matter tightening restriction forward chaining inference however may reasonable invoke special case mechanisms rule sets include equality rules subset hopefully framework presented paper first step toward powerful general theory tractable inference relations tractability lemma tractability lemma states finite rule set r relation r polynomial time decidable statement tractability lemma refined give useful upper bound order polynomial involved refinement requires additional terminology inference rule r said order k exist expressions e e either metavariable proper subexpression formula rule r every metavariable appears r also appears e example rule order two two expressions satisfy requirements conditions note rule order one equation fs proper subexpression formula rule similarly rule order one rule order two refined tractability lemma fixed finite rule set r possible determine whether sigma r phi order n k time n total size sigma phi rules r order k less proof purposes proof rule set r called normal every rule r r every metavariable r appears proper subexpression formula r first reduce problem determining whether sigma r phi problem determining whether sigma r phi case r normal sigma empty inference rule r empty set antecedents sigma 6 r phi thus assume without loss generality either sigma nonempty rule r antecedents consider rule r metavariable psi appears r appear proper subexpression formula r place psi appear r antecedent conclusion psi antecedent conclusion r removed rule set without affecting relation r psi antecedent conclusion comments sigma r imply rule r replaced rule r 0 antecedent psi removed psi conclusion r antecedent r replace r rule r 0 derived r replacing conclusion psi new formula constant f let r 0 rule set derived r making removals replacements sigma r phi case sigma r 0 phi sigma r 0 f furthermore r 0 normal rule set rules r 0 order k less without loss generality assume r normal rule set let upsilon fixed rule set r set upsilon order elements sigma r phi case exists derivation phi sigma r psi label formula upsilon let r inference rule r metavariable substitution ae let aer rule derived ae replacing metavariable r image ae since r normal need consider instances aer ae maps every metavariable r member upsilon let e set expressions satisfy conditions definition r order j e either metavariable proper subexpression formula r implies need consider instances aer ae substitution aee 1 members upsilon since every metavariable r appears e set instances aer computed matching expressions e elements upsilon fixed rule r independent size n set possible matches elements upsilon computed order n j time restriction aee element upsilon guarantee conclusion antecedents aer label formulas upsilon let ir set instances aer conclusion antecedents aer label formulas upsilon set ir computed order n j time let ir union sets ir rules r r set ir computed order n k time sigma r phi case phi derived sigma rules ir purely propositional reasoning need consider substitution rules ir equivalent determining given proposition symbol derived set proposition symbols using set propositional horn clauses existence derivation determined time proportional total size set propositional horn clauses since ir computed order n k time total size order n k ii lifting lemma lifting lemma stated follows lifting lemma let r finite rule set let finite template set covers extension events r rank j less possible compute finite template set rt covers extension events rank less template set rt constructed r follows r set inference rules let set extension event templates individual metavariable appears one rule template rules templates resolved apart define rt set extension event templates generated nondeterministically following procedure 1 let theta 1 theta n rule r let ff exists metavariable substitution ae aetheta 2 let ae general substitution satisfying conditions 3 let ff expression aeff ff 4 let fs set top level proper subexpressions aephi ie proper subexpressions aephi proper subexpressions larger proper subexpression aephi 5 let fu disjoint sets whose union exists substitution ae 0 ae 0 6 let ae 0 general substitution satisfying conditions selected expressions um 7 let ff 0 ae 0 ff 8 let phi 0 ae 0 aephi 9 let sigma 0 ae 0 ae 10 let upsilon 0 least subexpression closed set containing following closed variablefree proper subexpressions formulas appear rule set r b proper subexpressions sigma 0 c sets form ae 0 aeupsilon proper subexpressions ff 0 e expressions ae 0 w 11 ff 0 member upsilon 0 output ff set extension event templates r rt also set extension event templates r templates rank less templates rt less proof let ff tuple rt extension event template extension event may contain metavariables show tuple satisfies conditions extension event r step 10 ensures upsilon 0 subexpression closed steps 10a 10b ensure upsilon 0 condition step 11 ff 0 upsilon 0 ensure ff 0 one step extension upsilon 0 steps 3 4 5 6 10e ensure every immediate subexpression phi 0 either member upsilon 0 equal ff 0 guarantees phi 0 label formula upsilon 0 ff 0 must also show formula phi 0 member c ff 0 j1 templates selected step 1 procedure let ae 00 substitution maps every expression e ae 0 aee ae ae 0 substitutions constructed steps 2 6 spectively construction substitution ae 0 ensures phi 0 derivable ae 00 psi single inference rule psi psi member c ffj show ae 00 cr sigma cr sigma theta formula cr sigma must show ae 00 theta member cr sigma 0 upsilon 0 let derivation theta sigma every formula label formula upsilon ae 00 derivation ae 00 theta ae 00 sigma furthermore since every proper subexpression every formula member upsilon every proper subexpression every formula ae 00 member upsilon 0 thus ae 00 theta member cr sigma subset cr sigma 0 upsilon 0 since psi member c ff j depth j derivation ae 00 psi ae 00 cr sigma subset cr sigma 0 upsilon 0 exists depth j derivation ae 00 psi argument similar one shows every formula derivation label formula upsilon 0 fff 0 g thus ae 00 psi member c ff 0 j derivable one step ae 00 psi thus phi 0 must member c ff 0 j1 set templates covers extension events rank less rt covers extension events rank j 1 extension event ff 00 phi 00 sigma 00 upsilon 00 rank j 1 use double primes allows names used proof agree names used procedure definition phi 00 member c ffj1 r sigma upsilon member c ffj r sigma upsilon implies exist formulas c ff 00 j inference rule r form theta 1 theta n r allows phi 00 derived psi 00 n applying substitution oe inference rule oetheta extension events ff 00 psi 00 extension event e 00 rank j less thus e 00 covered template let cover extension events e 00 via substitutions ae respectively assumed metavariable appears one r therefore define substitution metavariable x x appears r x equals oex x appears e x equals ae x otherwise x equals x thus theta n substitution satisfies conditions given step 1 procedure let ae general substitution satisfying conditions constructed step 2 procedure substitution ae least general implies substitution written ae followed another substitution 0 ie expression e e equals 0 aee let ff aeff defined step 3 procedure since 0 aeff ff 00 0 ff equals ff 00 expression 0 aephi equals phi equals phi 00 thus 0 aephi label formula upsilon 00 fff 00 g implies immediate subexpression aephi 0 equals ff 00 member upsilon 00 let set immediate subexpression u aephi 0 u equals ff 00 let set immediate subexpressions w aephi 0 w member upsilon 00 note u 0 thus 0 substitution satisfies requirement step 5 let ae 0 substitution defined step 6 procedure ie general substitution ae 0 substitution ae 0 least general 0 implies 0 written ae 0 followed another substitution 00 ie expression e 0 e equals 00 ae 0 e expression e defined steps 7 8 9 10 procedure let e 0 tuple ff show e 0 extension event template covers original extension event via substitution 00 00 ff 0 equals equals ff 00 similarly 00 phi 0 equals phi 00 furthermore case analysis steps 10a 10d used show 00 upsilon 0 subset upsilon 00 implies ff 0 member upsilon 0 otherwise would 00 ff 0 member 00 upsilon 0 ff 00 would member upsilon 00 violates original condition ff 00 onestep extension upsilon 00 since ff 0 member upsilon 0 tuple e 0 output procedure thus member rt lemma e 0 extension event template finally must show 00 sigma 0 subset cr sigma 00 upsilon 00 set 00 sigma 0 equals subset cr sigma r variations common subexpression problem natural language based inference procedures applied schuberts steamroller complexity finitely presented algebras taxonomic syntax first order inference knowledge representation system mathematics computational complexity taxononic inference fast decision procedures based congruence closure algorithm reasoning equality tr ontic knowledge representation system mathematics taxonomic syntax first order inference fast decision procedures based congruence closure variations common subexpression problem algorithm reasoning equality complexity finitely presented algebras ctr hubert comonlundh vronique cortier security properties two agents sufficient science computer programming v50 n13 p5171 march 2004 hans jrgen ohlbach elimination selfresolving clauses journal automated reasoning v20 n3 p317336 june 1998 rakesh verma algorithms reductions rewriting problems ii information processing letters v84 n4 p227233 november 2002 harald ganzinger efficient deductive methods program analysis acm sigplan notices v36 n3 p102103 march 2001 david basin harald ganzinger automated complexity analysis based ordered resolution journal acm jacm v48 n1 p70109 jan 2001 stphanie delaune easy intruder deduction problems homomorphisms information processing letters v97 n6 p213218 31 march 2006 robert givan david mcallester polynomialtime computation via local inference relations acm transactions computational logic tocl v3 n4 p521541 october 2002 david mcallester robert givan taxonomic syntax first order inference journal acm jacm v40 n2 p246283 april 1993 pascal lafourcade intruder deduction equational theory exclusiveor commutative distributive encryption electronic notes theoretical computer science entcs v171 n4 p3757 july 2007 javier esparza andreas podelski efficient algorithms pre post interprocedural parallel flow graphs proceedings 27th acm sigplansigact symposium principles programming languages p111 january 1921 2000 boston usa stphanie delaune florent jacquemard decision procedure verification security protocols explicit destructors proceedings 11th acm conference computer communications security october 2529 2004 washington dc usa harald ganzinger viorica sofroniestokkermans uwe waldmann modular proof systems partial functions evans equality information computation v204 n10 p14531492 october 2006 pascal lafourcade denis lugiez ralf treinen intruder deduction equational theory abelian groups distributive encryption information computation v205 n4 p581623 april 2007 nancy durgin patrick lincoln john mitchell andre scedrov multiset rewriting complexity bounded security protocols journal computer security v12 n2 p247311 may 2004 evgeny dantsin thomas eiter georg gottlob andrei voronkov complexity expressive power logic programming acm computing surveys csur v33 n3 p374425 september 2001
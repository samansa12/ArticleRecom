improving static analysis embedded languages via partial evaluation programs embedded languages contain invariants automatically detected enforced host language show use macros easily implement partial evaluation embedded interpreters order capture invariants encoded embedded programs render explicit terms host language demonstrate effectiveness technique improving results value flow analysis b output formatting language java 3 supports declarative sublanguage laying gui elements window plt scheme 9 offers least five languages one formatting console output two regular expression matching one sending queries sql server one laying html pages permission make digital hard copies part work personal classroom use granted without fee provided copies made distributed profit commercial advantage copies bear notice full citation first page copy otherwise republish post servers redistribute lists requires prior specific permission andor fee september 1921 2004 snowbird utah usa many cases though always programs embedded specialpurpose programming languages encoded strings library functions consume strings interpret often interpreters consume additional arguments use inputs little programs take look expression plt scheme regexpmatch httpazaz line function regexpmatch interpreter regular expression language consumes two arguments string regular expression language consider program another string programs input typical use looks like example first string actually specified call site second string often given variable expression reads input port interpreter attempts match regular expression second string plt scheme regular expression language allows programmers specify subpatterns via parentheses running example contains two subexpressions az az regular expression interpreter fails match regular expression string produces false f otherwise produces list n1 elements first one overall match plus one per subexpression say line stands httpaaabbbeduzzz case regular expression matches string regexpmatch produces list list httpaaabbbeduzzz aaabbbedu rest scheme program extracts pieces list computes regexpmatch expression simplified excerpt plt web server 12 slightly larger fragment let r regexpmatch httpazaz line r processurl third r dispatch second r logerror line notice thenclause ifexpression extracts second third elements r without checks confirm length list programmer knows r false list three elements embedded program says regular expression contains two subexpressions unfortunately static analysis tools plt scheme cannot reason levels mrflow 20 static debugger uses constraintbased analysis 22 version setbased analysis 2 13 10 analyze program discover potential er rors finds one draw flow graph source bad value faulty primitive operation letexpression mrflow finds second r third r may raise runtime errors r may contain enough elements paper show using scheme macros partially evaluate calls embedded interpreters regexpmatch greatly increases precision static analysis since use macros library designers easily implement partial evaluation rather relying host language implementor must adhoc solutions section 2 give brief overview setbased analysis mr flow next section explain three examples embedded languages problems cause mrflows static anal ysis present section 4 general approach solving problems based macros overview macro system use given section 5 section 6 presents general technique translating embedded interpreters macros section 7 explain properties static analysis enable find results partially evaluated code finally section 8 show partially evaluating scheme programs contain embedded programs helps mrflow three examples section 9 presents related work conclude section 10 setbased analysis explain results static analysis improved using partial evaluation embedded languages first need describe analysis mrflow static analyzer drscheme uses setbased value flow analysis compute approximation values subexpression program might evaluate runtime 22 approximation computed expression set abstract values displayed demand debugger also draw arrows showing flow values program figure 1 displays example analyzing simple program box next term 3 abstract value term meaning runtime term 3 might evaluate value 3 arrow starting term 3 shows runtime value 3 might flow argument x function f flow reference variable x body f second reference x fthe corresponding arrow shown example box next call scheme primitive gcd abstract value result call since analysis never tries evaluate expressions uses abstract value integer represent result primitive call conservative approximation actual value call might compute runtime biggest box displays type adjacent ifexpression union integer abstract value computed gcd primitive string hello arrows show result ifexpression come elsebranches analysis attempt apply number predicate variable x conservatively assumes branches ifexpression may evaluated runtime 3 three embedded languages turn embedded languages useful technique establishing abstraction layers particular design space functional languages wellsuited writing interpreters embedded languages higherlevel embedded language implemented set functions general purpose host language access features 15 16 24 abstractions come cost program analysis particular tools built examine programs host language cannot derive information programs embedded languages understand semantics languages section demonstrate three examples practical embedded languages scheme show negative effects static analysis first example properties embedded language create possibility errors go undetected analy sis next two examples undetected properties lead analyses conservative resulting many false positives analysis reports errors never actually occur 31 plt scheme library provides format function similar cs sprintf generates string given format specifier variable number additional arguments format specifier string containing combination literal text formatting tags tags interpreted along remaining arguments construct formatted string format function thus interpreter format specifier language format specifier program language additional arguments inputs construct output format function requires number extra arguments match number format tags arguments must appropriate type consider example displaying ascii character encoding hexadecimal example format specifier contains format tags c x literal text expects consume exactly two arguments arguments must character teger respectively incorrect number arguments type mismatch results runtime error unfortunately analysis tools scheme mrflow priori knowledge semantics embedded languages analysis cannot infer information dependencies contents format string rest arguments without knowledge syntax semantics format lan guage result analysis cannot predict certain categories runtime errors shown figure 2 application format underlined error even though arguments appear wrong order analysis correctly computes types c n figure 1 analyzing simple program mrflow 32 regular expressions regular expressions used kinds scheme programs language regular expression patterns embedded scheme strings library functions interpret strings programs consume additional arguments input strings return either list matched subpatterns f indicate failure consider excerpt plt web server section 1 programmers know match succeeds result list contains exactly three elements result entire match results two subpattern matches analysis unable discover invariant figure 3 shows results analyzing sample code mrflow list accessors second third underlined red analysis cannot prove arguments sufficiently long lists programmers must either go false positives prove errors never occur else learn ignore results mrflow neither option de sirable former creates work programmer rather less latter unsafe easily leads overlooked errors 33 schemeql schemeql 28 embedded language manipulating relational databases scheme unlike stringbased format lan guage schemeql programs consist special forms directly embedded inside scheme schemeql implementation provides set macros recognize forms expand scheme code typical database query schemeql might look like directquery name age phone directory corresponding sql statement select name age phone directory result executing query lazy stream representing cursor result set database server element stream list values representing single row result set cursor computes rows need program selects next substream programmers know number elements row cursor equal number columns original request analysis however cannot discover fact automatically figure 4 shows results analysis schemeql query context trivial scheme program example query consists exactly three columns code references third element first row operation never fail analysis unable prove instead conservatively computes row list unknown rectype describes recursive abstract value present case union null pair consisting value top abstract value creating loop abstract value simulates possible list lengths mrflow therefore mistakenly reports error underlining primitive third red since according analysis row might fewer three elements runtime 4 macros partial evaluation embedded languages presented previous section one thing common encode invariants visible analysis general purpose language embedded invariants exposed analyses two ways extending analyses adhoc manner embedded language understand semantics partially evaluating embedded interpreters regard embedded programs make invariants embedded programs explicit invariants host language whenever possible first solution requires modifying analysis support embedded language second solution simply implemented within host language old lisp trick using compiler macros 25 lightweight partial evaluation mechanism present case instead using partial evaluation optimize programs speed use increase precision program analyses lisps compiler macros different regular lisp macros schemes macro system powerful enough equivalent lisps compiler macros implemented regular scheme macros partial evaluation embedded interpreters simply involves replacing libraries functions imple figure 2 imprecise analysis format primitive figure 3 imprecise analysis regexpmatch figure 4 imprecise analysis schemeql query menting interpreters libraries semantically equivalent macros 1 additional advantage done author library functions opposed compilers analyzers implementor case adhoc extensions course partial evaluation embedded interpreters possible input programs known statically ex ample possible expand call format formatting string given first argument computed runtime programmer therefore makes tradeoff precision analyses dynamic code practice though embedded programs often specified statically user code combined simplicity implementing partial evaluation macros makes useful technique improving precision analyses low cost next two sections describe important features scheme macro system explain make use system partially evaluate interpreters embedded languages improve results static analysis 5 macros scheme scheme powerful macro system extending language derived expression forms rewritten expressions core language macros serve means syntactic abstrac tion programmers generalize syntactic patterns ways possible functional abstraction technology also provides hook standard compiler tool chain allowing programmers implement additional program transformations compilation section describe basics standard scheme macros introduce identifier macros generalization contexts macros matched 51 rulebased macros definesyntax special form allows programmer extend scheme derived expression forms compilation execution scheme program occurrences derived forms replaced specified expansions syntaxrules form specifies macro expansions rewrite rules consider following simple macro defines shortcircuit logical derived form definesyntax syntaxrules e1 e2 let tmp e1 tmp tmp e2 macro defines single rewrite rule consisting pattern template pattern matches keyword operator position followed two pattern variables e1 e2 matching arbitrary subexpression argument position template directs macro expansion replace occurrences matched pattern letexpression constructed matched subexpressions 1 transformation strictly speaking partial evaluation reductions performed macros exactly ones performed embedded interpreters however macros share techniques issues partial evaluation since simulate parts interpreters therefore useful describe notice form cannot defined regular function scheme second argument evaluated first argument evaluates false since scheme strict evaluation semantics functional would necessarily evaluate arguments computing result controlling evaluation expressions important use scheme macros macros also abstract syntactic forms ways functions cannot expanding secondclass language constructs define 52 lexical scope macros written standard scheme syntaxrules mechanism hygienic referentially transparent hygienic macro expansion guarantees binding forms inside definition macro template capture free variables macro arguments consider following use macro 2 tmp hygienic expansion automatically renames variable bound inside expanded macro template avoid capturing free variable macro argument referential transparency complements hygiene ensuring inside macro template cannot captured context macro call site example context invokes rebinds name expansion algorithm renames binding callers context avoid capturing variable used template body let 3 f let tmp 1 tmp tmp f combination hygiene referential transparency produces macros consistent schemes rules lexical scope invoked anywhere program without danger unexpected variable capture 3 53 syntaxrules form matches expressions macro name occurs application position ie operator application expression references syntaxrules macro contexts result syntax errors fold f ls plt schemes syntaxidrules form similar syntaxrules matches occurrences macro keyword arbitrary expression contexts operator position operand position target assignment use convention representing macro expansion doublearrow ordinary runtime evaluation single arrow 3 macros also defined exported modules plt scheme 11 following macro demonstrates hypothetical use syntaxidrules clock syntaxidrules set set clock e setclock e clock e maketimestamp getclock e clock getclock list identifiers following syntaxidrules empty previous examples includes set identi fier indicating set treated keyword rather pattern variable first rewrite rule matches expressions clock name occurs target assignment second rule familiar matching macro application position final rule matches identifier clock context matched previous two rules addition usual application context use clock macro argument position clock 10 set target set clock 5 54 programmatic macros language patterns templates recognized syntaxrules syntaxidrules actually special case scheme macros general definesyntax form binds transformer procedure name lambda stx etc argument transformer procedure syntax object similar sexpression representing quoted code also encapsulates information lexical context code source file location variable bindings context information essential allowing drschemes language tools trace errors binding relationships back original source location users code macro invoked syntax objects similar quoted data standard library includes syntaxobjectdatum procedure strips lexical information syntax object returns corresponding datum example datum corresponding syntax object representing literal number numeric value datum corresponding identifier symbol representing identifiers name syntax transformer procedure accepts argument syntax object representing expression invoked macro produces new syntax object macro expansion algorithm uses replace original expression scheme macros syntax transformers although syntaxrules syntaxidrules forms use lambda notation implemented macros expand syntax transformer procedures syntaxcase facility allows construction macros pattern matching syntaxrules syntaxidrules arbitrary expressions place templates result expressions example macro would defined definesyntax lambda stx syntaxcase stx e1 e2 let tmp e1 tmp tmp e2 macro almost two refinements first syntaxcase form takes argument stx explicitly whereas syntaxrules implicitly defines transformer procedure operates procedure argument second result expression prefixed syntaxquoting operator analogous schemes quote operator whereas expression prefixed evaluates quoted sexpression expression becomes quoted syntax object also includes lexical informa tion similarly quasisyntax operator unsyntax operator behave syntax objects like quasiquote unquote operators sexpressions respectively use arbitrary computations result expression allows macros expand differently based results actual computations lambda stx syntaxcase stx swap b identifier let tmp b set tmp raisesyntaxerror swap expects identifiers example swap given identifiers arguments raisesyntaxerror function uses lexical information stx syntax object highlight original swap expression users code conditional matching also achieved using pattern guards inspect matched expression determine whether accept lambda stx syntaxcase stx swap b identifier let tmp b set tmp pattern guard new expression inserted pattern result expressions guarded match succeeds guard evaluate false guard fails pattern matcher falls attempt next pattern list 6 macros interpreters section present general technique specializing embedded interpreters macros explain apply technique three embedded languages described section 3 technique summarized following steps 1 write interpreter compositionally module library functions 2 replace interpreters main function macro unfolds case dispatch input embedded program known statically 3 default original function input known compile time writing interpreters compositionally serves two purposes first delegating interpretation program constructs make embedded program separate functions becomes possible share code original interpreter macro replaces effectively limits macros responsibility simple dispatch second compositionality makes easier guarantee unfolding terminates since recursive macro calls always operate smaller terms 61 format strings implementation string formatter involves number simple library functions convert possible type argument strings formatting tag corresponds one combi nators example c tag corresponds combinator accepts character converts string x tag corresponds formathex converts integers hexadecimal representation forth string formatter simply dispatches combinators based content formatting string define format args cond substring 0 stringappend formatchar car args apply format substring 2 cdr args etc interpreter accepts formatting string based formatting tags like c finds decomposes string series applications corresponding combinators successive arguments format represented args reassembles transformed pieces standard stringappend function order specialize format interpreter replace macro reuses associated combinators define formatdynamic args lambda stx syntaxcase stx format sexp string syntaxobjectdatum sexp let syntaxobjectdatum sexp cond substring 0 stringappend formatchar a1 format substring 2 a2 etc format sexp formatdynamic sexp format identifier format partial evaluation works unfolding interpreters toplevel case dispatch program text rather delaying inspection string runtime macro precomputes result decomposition statically whenever string given literal identify literal strings use pattern guard precisely macro inspect syntax object sexp corresponding formats first argument determine whether converted string via syntaxobjectdatum conversion succeeds pattern guard allows match suc ceed partial evaluation proceeds macro expansion resulting program text consists application stringappend calls library func tions references interpreter stringappend formatchar c formathex n order replacement original function macro unobservable macro must behave exactly like original function contexts format applied dynamic formatting string macro defaults original functional im plementation similarly format passed argument higherorder function use technique identifier macros refer original function 4 62 regular expressions one plt schemes regular expression engines uses two continuation model backtracking 1 regular expression matcher represented function accepts success continuation failure continuation matcher succeeds matching input applies success continuation accepted input fails match invokes failure continuation allows interpretation alternation operator try alternate pattern sequentially alternation matcher tries match first pattern failure continuation try second pattern thus first pattern fails matcher invokes failure continuation tries second pattern otherwise failure continuation disregarded matcher applies success con tinuation skips second pattern returns result first match regular expression constructions corresponds functional combinator produces matcher combinators express standard operators regular expressions suc cess failure alternation concatenation repetition ie kleene star also submatch combinator parenthesized subpatterns original regular expression successful regexpmatch returns list entire matched string followed submatch corresponding parenthesized subpat tern subpattern match corresponds entry false f result list example following successful 4 case set critical since plt scheme imported module references cannot target assignment match contains failed regexpmatch abc ac list ac c f c regardless contents second argument always exactly one element result list parenthesized subpattern regular expression submatch operator accomplishes wrapping given matcher continuations add either result successful match false list indexed submatches accumulated match initial suc cess continuation regexpmatch sorts accumulated list indexed submatches adding false entries submatches never reached backtracking partial evaluation regular expression library works unfolding definitions combinators well contents initial continuation application combinator gets replaced application copy body combinators definition 5 recursive code constructs result list success continuation gets expanded explicit chain cons expressions regexpmatch abc input buildmatcher input lambda subs cons lookup subs cons lookup subs 1 cons lookup subs 2 cons lookup subs lambda since size result list known possible unfold recursive definitions initial continuation constructs match result make structure result explicit finally cases embedded program known stat ically regexpmatch used nonapplication contexts macro expands original functional definition 63 schemeql schemeql language differs examples programs embedded strings rather special forms recognized library macros means queries select fixed set columns length cursor rows always known statically column names specified sequence identifiers syntax query form interpreters stringbased embedded programs perform case dispatch contents program strings schemeql macros dispatch shape query expressions cases partial evaluation possible captured inserting additional rules original librarys macros partial evaluation schemeql queries uses technique regular expression library recursive function constructs cursor row unfolded explicit chain cons ex pressions since know length cursor row statically unfolding guaranteed terminate 5 convenient define kleene star operator recursively e however noncompositional definition leads infinite macro expansion macro must carefully avoid unfolding definition since schemeql library implemented macros need capture cases query forms used nonapplication contexts adding special cases existing macro affect set allowable contexts similarly cases row length known statically already handled existing schemeql macros 7 static analysis scheme mrflows value flow analysis extension ordinary setbased closure analysis like palsbergs 22 every expression program mrflow statically computes conservative approximation set values expression might evaluate runtime given expression creates graph simulates flow values inside expression analysis simulates evaluation propagating abstract values graph reaching fixed point set abstract values propagate given node analysis reconstructs type displayed user drschemes graphical interface extensions basic analysis include among things analyzing functions take number arguments analyzing assignments variables set analyzing generative data structure definitions mrflow also supports primitives defined r 5 rs 17 vast majority primitives defined using special typelike language embedded inside alyzer given primitive corresponding type translates graph simulates primitives internal flows analysis proceeds like expression remaining primitives need special handling imperative nature setcar vectorfill analyzed adhoc manner default mrflow analyzes format primitive based following pseudotype description string top string constructor means primitive function take number arguments input beyond ones explicitly specified present case function must receive string first argument followed number arguments type represented pseudotype top returns string given description errors mrflow detects primitive given something string first argument given argument partial evaluation application format replaced calls individual library functions formatchar formathex functions respectively pseudotypes char string integer string using precise information mrflow detect arguments original format call wrong type checking format primitive receives right number arguments given formatting string happens partial evaluation analyzer never sees arity errors expanded code since drschemes syntax object system keeps track program terms macro expansions 11 mrflow able trace detected errors back original guilty terms users program flag graphically arrows representing flow values also displayed interactively terms original program allowing user track program sources values triggered errors essence requirement mrflow analyze partially evaluated code format specify pseudotypes library functions introduced transformations like formatchar 6 similarly enough define pseudotypes functions used partially evaluated form schemeqls query mrflow automatically compute precise results without modifications partial evaluation regular expressions challenging consider example section 1 let r regexpmatch httpazaz line r processurl third r dispatch second r call regexpmatch variable r either list three elements false based conservative pseudotype specification regexpmatch mrflow computes r either list unknown length false turn triggers two errors second third primitives one error primitive might applied false expected list one error might applied list short second kind false positives removed partially evaluating regexpmatch make structure result explicit mrflow described section 62 analysis determines primitive returns either list three elements false turn checks second third applied list enough elements still possible return values regexpmatch may contain false indeed false value returned runtime line given regexpmatch match pattern programmer test condition explicitly processing result way mrflow show false positive second third presence false value make analysis aware dependency test r two branches ifexpression form flowsensitive analysis ifexpressions difficult implement general since bound complexity tested ex pression practice however appreciable proportion tests simple enough adhoc solution sufficient case test simply variable reference enough create two corresponding ghost variables one branch establish filtering flows variable r two ghost variables make sure ghost variable binds r variable references respective branch ifexpression filtering flows prevent false abstract value flowing branch ifexpression prevent everything false value flowing else branch combination flow sensitivity ifexpressions partial evaluation regexpmatch gives analysis results false positives 6 specifying pseudotypes even necessary mrflow knows analyze plt scheme contracts subject forthcoming paper flowsensitive analysis ifexpressions added pseudotype descriptions necessary primitives provided analysis partial evaluation makes false positives described section 3 disappear illustrate next section 8 improvement static analysis partially evaluating format eliminates possibility runtime arity errors since macro transformations statically check invariants also allows mrflow detect type errors could detect since corresponding invariants described embedded formatting language invariants explicit scheme level transformed program use simpler primitives like formatchar formatinteger figure 5 shows program figure 2 applying partial evaluation format primitive blamed two type errors could found runtime error messages show user simply gave arguments n c wrong order similarly specializing regular expression engine respect pattern eliminates false positives length list returned regexpmatch cannot directly computed analysis since information hidden inside regular expression pattern result applications second third figure 3 flagged potential runtime errors omitted fairly large error messages figure specialization structure value returned regexpmatch exposed analysis mrflow prove regexpmatch returns list must contain three elements false positives second third disappear figure 6 course regexpmatch also return false runtime analysis correctly predicts regardless whether partial evaluation used adding flow sensitivity ifexpressions described section 7 removes last spurious errors figure 6 partial evaluation allows precise analysis schemeql queries well figure 7 shows precise analysis program figure 4 time partial evaluation regexpmatch analysis previously computed cursorcar could return list length therefore flagged call third potential runtime error call free spurious errors since partial evaluation exposes enough structure list returned cursorcar mrflow compute exact length verify third cannot fail runtime results computed analysis become precise partially evaluating interpreters three embedded languages use paper results code bigger original program bigger code turn means analyses take time complete therefore tradeoff precision efficiency analyses intend turn tradeoff user option mrflow user might also exercise full control embedded languages partially evaluated using either functional macro versions embedded languages interpreters switching two judicious use module system example 11 note partial evaluation always benefit analyses regexpmatch example figure 6 spurious errors disappear mrflow able prove list r length three therefore applying primitives second figure 5 precise analysis format primitive figure 6 precise analysis regexpmatch figure 7 precise analysis schemeql query third r cannot fail analysis hindleymilnerlike type system though difference would seen whether partial evaluation used indeed type system could statically prove arguments given second third lists would attempt prove lists required length runtime test would still required using partial evaluation expose property analysis would therefore useless simply put making invariants embedded programs explicit host language matters system analyzing host language cares invariants mean partial evaluation always useless used conjunction hindleymilner type system though partially evaluating format example would allow type system verify formatting string agrees types remaining arguments contrast adhoc solution used ocaml 19 type check printf primitive use dependent types case cayenne 4 9 related work work analogous designing typesafe embedded languages one printf 21 4 problems involve determining static information programs based values embedded programs cases designers typed languages simply extend host language include specific embedded languages ocaml language example contains special library printf 19 uses printf typechecked adhoc manner similarly gcc compiler c language uses adhoc checking find errors printf format strings danvy 7 hinze 14 suggest implementations printf ml haskell respectively obviate need dependent types recasting library terms individual combinators system individual combinators automatically introduced macro expansion c language 26 likewise avoids problem checking invariants printf breaking functionality smaller operations require use embedded formatting language work closely related cayenne language 4 augustsson uses form partial evaluation specialize dependent types regular haskelllike types used type system check users program macro system uses macroexpansion time computation specialize expressions subsequent flow analysis compute precise value flow results augustssons dependent type system uses computation performed typechecking time specialize dependent types rest type checking compute precise type information specialization done system use type computing functions specified user evaluated type system main difference system used compute specialized types verify program safe original program typed compiled asis type checking turned means case format example formatting string processed twice type checking time prove safety program run time compute actual result system used compute specialized expressions means evaluation formats string needs done specialized program either run analyzed prove safety cases format string reprocessed since completely replaced specialized code another difference system nonspecialized programs still valid programs analyzed proved safe run though result analysis probably conservative analyzing corresponding partially evaluated program proving safety might difficult possible cayenne since programs dependent types cannot run without going partial evaluation phase first much work gone optimization embedded languages hudak 15 elliott et al 8 backhouse 5 christensen 6 veldhuizen 27 discuss use partial evaluation improve efficiency embedded languages although none makes connection partial evaluation static analysis back houses thesis discusses need improve error checking embedded languages erroneously concludes syntactic analyses cannot used due embedded nature domainspecific embedded languages lisp programming language 25 section 84 provides compiler macros programmers use create optimized versions existing functions compiler required use though knowledge literature showing use compiler macros improve results static analyses lisp also support inlining functions might help monovariant analyses duplicating code function call sites thereby simulating polyvariant analyses bigloo 23 scheme compiler routinely implements embedded languages via macros thus probably provides benefits presented paper compilers internal anal yses compiler switch enable optimization macro expansion though seem documentation literature describing exact effect using switch programs embedded languages contain invariants automatically enforced host language shown using macros partially evaluate interpreters little languages embedded scheme respect input programs recapture invariants convey flow analysis based macros technique require adhoc modification either interpreters analyses thus readily available programmers makes sweet spot programming complexity versus precision landscape program analysis intend investigate relationship macros program analyses similar manner acknowledgments thank matthias felleisen mitchell wand kenichi asai discussions led work helpful feed back thanks matthew flatt help presentation scheme macros thanks dale vaillancourt proofreading paper ryan culpepper macrological wizardry r structure interpretation computer programs introduction set constraintbased program anal ysis java programming language abstract interpretation domainspecific embedded languages functional unparsing compiling embedded languages componential setbased anal ysis want programming web highlevel programming languages based program analysis formatting class act modular domain specific languages tools research domainspecific embedded languages program generators c programming lan guage objective caml system functional logic overloading closure analysis constraint form portable optimizing compiler strict functional languages little language common lisp language schemeunit schemeql two little languages tr common lisp language c programming language based program analysis closure analysis constraint form cayennemyampersandmdasha language dependent types componential setbased analysis introduction set constraintbased program analysis functional logic overloading c programming language third edition structure interpretation computer programs java programming language composable compilable macros revised report algorithmic language scheme programming web highlevel programming languages compiling embedded languages universal scripting framework lambda modular domain specific languages tools formatting class act drscheme programming environment scheme functional unparsing
making nondeterminism unambiguous show context nonuniform complexity nondeterministic logarithmic space bounded computation made unambiguous analogous result holds class problems reducible contextfree languages terms complexity classes stated nlpoly b introduction paper combine two useful algorithmic techniques inductive counting technique imm88 sze88 isolation lemma mvv87 give simple proof two fundamental concepts complexity theory coincide context nonuniform computation unambiguous computation focus much attention past three decades unambiguous contextfree languages form one important subclasses class contextfree languages complexity class first defined studied valiant val76 necessary precondition existence oneway functions p properly contained supported part dfg project la 61831 komet supported part nsf grant ccr9509603 work performed author visiting scholar wilhelmschickard institut fr informatik universitt tubingen supported dfg grant tu 71171 gs88 although one intenselystudied subclasses np neither known widelybelieved contains sets hard np interesting notion reducibility although valiant vazirani showed uniquesatisfiability hard np probabilistic reductions vv86 language uniquesatisfiability unless nondeterministic unambiguous spacebounded computation also focus much work computer science nondeterministic logspace nl captures complexity many natural computational problems proof nl closed complementation imm88 sze88 answered longstanding open question whether complement every contextsensitive language contextsensitive remains open question every contextsensitive language unambiguous grammar unambiguous version nl denoted ul first explicitly defined studied bjlr92 aj93 language ul nondeterministic logspace machine accepting every x one accepting computation input x motivated part question whether spacebounded analog result vv86 could proved wigderson wig94 gw96 proved inclusion nlpoly philpoly weaker statement nl phil still known hold phil class languages nondeterministic logspace bounded machine x 2 odd number accepting computation paths input x given complexity class c cpoly class languages exists sequence advice strings fffn j n 2 ng language b 2 c x ffjxj 2 b classes form c provide simple link nonuniform circuit complexity classes machinebased complexity classes p np nl phil etc natural characterizations terms uniform circuit families worth emphasizing showing equality ulpoly nlpoly must show every b nlpoly nondeterministic logspace machine never one accepting path input advice sequence ffn x ffjxj accepts stronger merely saying advice sequence ffn nondeterministic logspace machine x ffjxj never one accepting path accepts x 2 b proof main result wig94 gw96 wigderson observed simple modification construction produces graphs shortest distance every pair nodes achieved unique path refer graphs following minunique graphs wigderson wrote see application observation proof main result application st connectivity problem takes input directed graph two distinguished vertices determines path graph wellknown complete problem nl jon75 following lemma implicit wig94 gw96 completeness make explicit lemma 21 logspacecomputable function f sequence ad vice strings fffn j n 2 ng jffnj bounded polynomial n following properties ffl graph g n vertices fg ffl graph g st path g st path ffl g st path g minunique graph proof first observe standard application isolation lemma technique mvv87 shows edge g assigned weight range 1 4n 4 uniformly independently random probability least 3 4 two vertices x path x one path minimum weight sketch probability one minimum weight path x bounded sum edges e probability event bade x e occurs one minimumweight path x another given weight assignment w 0 edges g e one value z property weight e set z occurs thus probability two minimumweight paths two vertices bounded xye xye advice string ff consist sequence n 2 weight functions weight function assigns weight range 1 4n 4 edge strings possible n logspace computable function f takes input graph g sequence n 2 weight functions produces output sequence graphs hg graph g result replacing edge g path length j x j weight given e ith weight function advice string note ith weight function satisfies property one minimum weight path two vertices g minunique graph suffices observe two vertices x g vertices x 0 0 vertices original graph g lie every path x ffl one path x x 0 one path 0 ffl minimum weight path x unique let us call advice string bad g none graphs g sequence fg minunique graph g probability randomlychosen advice string ff bad bounded probability g minunique n 2 thus total number advice strings bad g 2 n 2 thus advice string ffn bad theorem 22 nlulpoly proof suffices present ulpoly algorithm st connectivity problem show nondeterministic logspace machine takes input sequence digraphs hg processes g sequence following properties ffl g minunique unique path determines fact goes process g paths rejecting ffl g minunique graph st path unique accepting path ffl g minunique graph st path accepting path combining routine construction lemma 21 yields desired ulpoly algorithm algorithm enhancement inductive counting technique imm88 sze88 call double counting technique since stage count number vertices distance k start vertex also sum lengths shortest path vertex following description algorithm denote numbers c k sigma k respectively let us use notation dv denote length shortest path graph g start vertex v path exists thus using notation sigma fxjdxkg dx useful observation subgraph g distance k start vertex minunique correct values c k sigma k provided unambiguous logspace machine input g k c k sigma k v compute boolean predicate dv k achieved routine shown figure 1 see routine truly unambiguous preconditions met note following precisely routine check every vertex x one minimal length path start vertex x sufficient purposes straightforward modification routine would provide unambiguous logspace routine determine entire graph g minunique graph input g k c k sigma k v count 0 sum 0 pathtov false x 2 v guess nondeterministically dx k guess dx k begin guess path length l k x fails halt reject count count 1 sum sum l endfor return boolean value pathtov else halt reject endprocedure figure 1 unambiguous routine determine dv k ffl routine ever guesses incorrectly vertex x dx k variable count never reach c k routine reject thus paths run completion guess correctly exactly set fx j dx kg ffl routine ever guesses incorrectly length l shortest path x dx l path length l found dx l variable sum incremented value greater dx latter case end routine sum greater sigma k routine reject clearly subgraph distance 0 start vertex minunique c part construction involves computing c k sigma k c kgamma1 sigma kgamma1 time checking subgraph distance k start vertex minunique easy see c k equal c kgamma1 plus number vertices note case dv edge x v dx k gamma 1 graph fails minunique graph exist v x well edge v code shown figure 2 formalizes considerations searching st path graph g expressed routine shown figure 3 given sequence hg routine processes g turn g minunique precisely subgraph g reachable start vertex minunique graph one unique computation path routine returns value badgraph goes process g input g k c output also flag badgraph vertex v x x v edge begin x 0 6 x edge dx 0 badgraph true endfor endfor endfor point values c k sigma k correct figure 2 computing c k sigma k input g repeat compute c k sigma k c c false st path g dt k figure 3 finding st path minunique graph computation paths halt reject otherwise g minunique routine unique accepting path g st path case routine halts accepting computation paths corollary 23 nlpoly ulpoly logcfl class problems logspacereducible contextfree language two important useful characterizations class summarized following proposition sac 1 auxpdalog n n o1 defined following paragraphs proposition 31 auxiliary pushdown automaton auxpda nondeterministic turing machine readonly input tape spacebounded worktape pushdown store subject spacebound class languages accepted auxiliary pushdown automata space sn time tn denoted auxpdasn tn auxpda satisfies property every input x one accepting computation auxpda said unambiguous gives rise class uauxpdasn tn sac 1 class languages accepted logspaceuniform semiunbounded circuits depth olog n circuit family semiunbounded gates fanin 2 gates unbounded fanin long nl shown closed complementation imm88 sze88 logcfl also shown closed complementation proof also used inductive counting technique bcd 89 similar history followed years later long shown nl contained philpoly wig94 gw96 isolation lemma used show logcfl contained phisac 1 poly gal95 gw96 noted gw96 independently shown h venkateswaran section show techniques used section 2 used prove analogous result logcfl fact would also possible derive result section 2 modification proof section since readers may interested nl logcfl chosen present direct proof nlpoly ulpoly first step state analog lemma 21 need definitions weighted circuit semiunbounded circuit together weighting function assigns nonnegative integer weight wire connecting two gates circuit let c weighted circuit let g gate c certificate c list gates corresponding depthfirst search subcircuit c rooted g weight certificate sum weights edges traversed depthfirst search informal definition made precise following inductive definition noted definition differs unimportant ways definition given gal95 gw96 ffl g constant 1 gate input gate evaluating 1 input x certificate g string g certificate weight 0 ffl g gate c inputs h 1 h 2 h 1 lexicographically precedes h 2 string form gyz certificate g certificate h 1 z certificate h 2 w weight edge connecting h g weight certificate yz plus sum weights certificates z ffl g gate c string form gy certificate g certificate gate h input g c w weight edge connecting h g weight certificate gy w plus weight certificate note c logarithmic depth certificate length bounded polynomial n weight bounded 2 times maximum weight edge every gate evaluates 1 input x certificate gate evaluates 0 certificate say weighted circuit c minunique input x every gate g evaluates 1 input x minimalweight certificate unique lemma 32 language logcfl sequence advice strings ffn length polynomial n following properties ffl ffn list weighted circuits logarithmic depth hc ffl input x x 2 c ffl input x x 2 c minunique input x lemma 32 sense implicit gal95 gw96 include proof completeness proof let logcfl let c semiunbounded circuit size recognizing inputs length n gal95 gw96 modified application isolation lemma technique mvv87 shows input x wire c assigned weight range 1 4n 3k uniformly independently random probability least 3 minunique input x sketch probability one minimumweight certificate sum wires e probability event bade g e occurs one minimumweight certificate another given weight assignment w 0 edges c e one value z property weight e set z bade g occurs thus probability two minimumweight certificates gate c bounded ge ge ge consider sequences fi consisting n weight functions hw wn weight function assigns weight range 1 4n 3k edge c sequences possible n must exist string fi input x length n n weighted circuit c results applying weight function w c minunique input x sketch proof let us call sequence fi bad x none circuits c sequence minunique input x x probability randomlychosen fi bad bounded probability c minunique n thus total number sequences bad x 2 n 2 gamma2n 2 bn thus sequence fi bad desired advice sequence formed taking good sequence wn letting c result applying weight function w c theorem 33 logcfl uauxpdalog n n o1 poly proof let language logcfl let x string length n let advice sequence guaranteed lemma 32 show unambiguous auxiliary pushdown automaton runs polynomial time uses logarithmic space worktape given sequence circuits input processes circuit turn following properties ffl c minunique input x unique path determines fact goes process c paths rejecting ffl c minunique input x evaluates 1 input x unique accepting path ffl c minunique input x evaluates zero input x accepting path construction similar many respects section 2 given circuit c let c k denote number gates g certificate weight k let sigma k sum gates g certificate weight k minimumweight certificate g let w g denote weight minimumweight certificate certificate exists let value 1 otherwise useful observation gates c certificates weight k unique minimalweight certificates correct values c k sigma k provided unambiguous auxpda input compute boolean value predicate w k achieved routine shown figure 4 input c count 0 sum 0 1 gate h guess nondeterministically w h k guess w h k begin guess certificate size l k h fails halt reject count count 1 sum sum l l endfor return else halt reject endprocedure figure 4 unambiguous routine calculate w g w g k return see routine truly unambiguous preconditions met note following ffl routine ever guesses incorrectly gate h w h k variable count never reach c k routine reject thus paths run completion guess correctly exactly set fh j w h kg ffl gate h w h k exactly one minimalweight certificate found uauxpda find certificate using pushdown execute depthfirst search using nondeterminism gates using olog n workspace compute weight certificate one path find minimalweight certificate gate h certificate weight greater w h guessed variable sum equal sigma k end routine path halt reject clearly gates input level unique minimalweight certificates gates g w input level thus set input bit negation provided along constant 1 sigma part construction involves computing c k sigma k c time checking gate two minimalweight certificates weight k consider gate g turn g gate inputs h 1 h 2 weights w 1 w 2 connecting g inputs w g k w gate suffices check gate h connected g edge weight w w w g one gate found two gates found circuit minunique input x violations sort found k c minunique input x code shown figure 5 formalizes considerations input c x k c output also flag badcircuit gate g begin g gate inputs h connected g edges weighted w g gate h connected g edge weighted w begin h 0 6 h connected g edge weight w 0 badcircuit true endfor endfor endfor point false values c k sigma k correct figure 5 computing c k sigma k evaluating given circuit c expressed routine shown figure 6 given sequence hc routine processes c turn c minunique input x one unique computation path routine returns value badcircuit goes process c computation paths halt reject otherwise routine unique accepting path c case routine halts accepting computation paths corollary 34 logcflpoly uauxpdalog n n o1 poly input compute true exit loop endfor output gate g evaluates 1 unique minimalweight certificate weight l accept w g figure evaluating circuit 4 discussion open problems rytter ryt87 see also rr92 showed unambiguous contextfree language recognized logarithmic time crewpram contrast crew algorithm known problem complete nl even nonuniform setting problem although nl class languages reducible linear contextfree languages although class languages accepted deterministic auxpdas logarithmic space polynomial time coincides class languages logspacereducible deterministic contextfree languages logcfl coincides auxpdalog n n o1 known uauxpdalog n n o1 ul reducible unambiguous contextfree languages work niedermeier rossmanith excellent job explaining subtleties difficulties nr95 crew algorithms closely associated version unambiguity called strong unambiguity terms turingmachine based computation strong unambiguity means one path start vertex accepting configuration fact one path two configurations machine strongly unambiguous algorithms efficient algorithms known general nl ul problems shown al96 problems strongly unambiguous logspace deterministic algorithms using less log 2 n space reader encouraged note minunique graph shortest path two vertices unique bears superficial resemblance property strong unambiguity see application observation natural ask randomized aspect construction eliminated using sort derandomization technique obtain equality corollary work ulpoly closed complement remains open question ul closed complement although unambiguous logspace classes defined using strong unambiguity known closed complement bjlr92 disappointing techniques used paper seem provide new information complexity classes nspacen straightforward show nspacesn contained uspacesn2 osn interesting sublinear sn natural class functions associated nl denoted fnl aj93 defined several equivalent ways ffl class functions computable nc 1 circuits oracle gates problems nl ffl class functions f fx ith bit fx bg nl ffl class functions computable logspacebounded machines oracles nl another important class problems related nl class l counts number accepting paths nl machine l characterizes complexity computing determinant vin91 see also tod dam mv97 val92 ao96 observed aj93 fnl contained l thus corollary result paper fnlpoly lpoly many questions l remain unanswered two interesting complexity classes related l pl probabilistic logspace cl characterizes complexity singular matrices well questions computing rank known natural hierarchies defined using complexity classes collapse contrast corresponding l hierarchy equal class problems ac 0 reducible computing determinant ac 0 known collapse fixed level equality ulpoly nlpoly provide help analyzing hierarchy nonuniform setting acknowledgment thank klausjorn lange helpful comments drawing attention minunique graphs arranging second author spend sabbatical time tubingen also thank v vinay lance fortnow insightful comments r complexity matrix rank feasible systems linear equations relationships among pl two applications inductive counting complementation problems circuits pp pl unambiguity fewness logarithmic space complexity measures publickey cryptosystems boolean vs arithmetic complexity classes randomized reductions nondeterministic space closed complement space bounded reducibility among combinatorial prob lems combinatorial algorithm deter minant matching easy matrix inversion unambiguous auxiliary pushdown automata semiunbounded fanin circuits pl hierarchy collapses observations log n time parallel recognition unambiguous contextfree languages parallel time ologn recognition unambiguous contextfree languages tape complexity deterministic contextfree languages method forced enumeration nondeterministic automata counting problems computationally equivalent de terminant relative complexity checking evaluating boolean complexity theory difficult counting auxiliary pushdown automata semi unbounded arithmetic circuits np easy detecting unique solu tions nlpoly tr ctr martin sauerhoff approximation boolean functions combinatorial rectangles theoretical computer science v301 n13 p4578 14 may allender meena mahajan complexity planarity testing information computation v189 n1 p117134 25 february 2004 allender nlprintable sets nondeterministic kolmogorov complexity theoretical computer science v355 n2 p127138 11 april 2006
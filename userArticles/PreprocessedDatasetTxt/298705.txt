basic operations otismesh optoelectronic computer abstractin paper develop algorithms basic operationsbroadcast window broadcast prefix sum data sum rank shift data accumulation consecutive sum adjacent sum concentrate distribute generalize sorting random access read writeon otismesh 1 model operations useful development efficient algorithms numerous applications 2 b introduction optical transpose interconnection system otis proposed marsden et al 4 hybrid optical electronic interconnection system large parallel computers otis architecture space optics connect distant processors electronic interconnect connect nearby processors specifically maximize bandwidth power efficiency minimize system area volume 1 processors n 2 processor otis computer partitioned n groups n processors processor indexed tuple g g g group index ie group processor p processor index within group inter group interconnects optical intra group interconnects electronic optical otis interconnects connect pairs processors form g p p g group processor indices transposed optical interconnect electrical intra group interconnections according well studied electronic interconnection networks mesh hypercube mesh trees forth choice electronic interconnection network defines subfamily otis computers otismesh otishypercube forth figure 1 shows 16 processor otismesh small square represents processor number inside processor square processor index p processor squares pair p pair gives row column index processor p within n theta n mesh large work supported part army research office grant daa h049510111 group 3 figure 1 square encloses group processors group index g may also given pair g x g g x g row column indices group assuming n theta n layout groups zane et al 11 shown n 2 processor otismesh simulate move n theta n theta n theta fourdimensional 4d mesh computer using either one electronic move one electronic two otis moves depending dimension 4d mesh move along also shown n 2 processor otishypercube simulate move n 2 processor hypercube using either one electronic move one electronic two otis moves sahni wang 10 9 developed efficient algorithms rearrange data according bit permutecomplement permutations otismesh otishypercube computers respectively rajasekaran sahni 7 developed efficient randomized algorithms routing selection sorting otismesh paper develop deterministic otismesh algorithms basic data operations parallel computation studied 8 shown 8 algorithms operations used arrive efficient parallel algorithms numerous applications image processing computational geometry matrix algebra graph theory forth consider synchronous simd synchronous mimd models processors operate lockstep fashion simd model active processors perform operation step active processors move data along dimension along otis connections mimd model processors perform different operations step move data along different dimensions 2 basic operations 21 data broadcast data broadcast perhaps fundamental operation parallel computer operation data initially single processor g p broadcast transmitted processors otismesh data broadcast accomplished using following three step algorithm data processors group g step 2 perform otis move step 3 processor g group broadcasts data within group following step 2 one processor group copy data following step 3 processor otismesh copy simd model steps 1 3 take 2 electronic moves step 2 takes one otis move simd complexity 4 electronic moves 1 otis move total 4 moves note algorithm optimal diameter otismesh 4 example data broadcast initially processor 00 data needs reach processor distance 4 3 mimd model complexity steps 1 3 depends value ranges low approximately high 2 overall complexity 4 moves one otis move contrast simulating 4dmesh broadcast algorithm using simulation method 11 takes 4 electronic moves 4 moves simd model many moves mimd model 22 window broadcast window broadcast start data top left w theta w submesh single group g w divides n following window broadcast operation initial w theta w window tiles groups window broadcast within across groups algorithm window broadcast step 1 window broadcast within group g step 2 perform otis move step 3 intra group data broadcast processor g group step 4 perform otis move following step 1 initial window properly tiles group g left task broadcasting group g groups step 2 data dg p g p moved step 3 dg p broadcast processors moved p step 1 window broadcast algorithm takes 2 moves simd mimd models step 3 takes 2 moves simd model moves mimd model total cost 4 moves simd model many moves mimd model simulation 4d mesh window broadcast algorithm takes number electronic moves also takes 4 moves 23 prefix sum index g p processor may transformed scalar gnp 0 n 2 let di data processor 0 n 2 prefix sum processor computes simple prefix sum algorithm results following observation sdi sum di processors group smaller group lp local prefix sum within group simple prefix sum algorithm step 1 perform local prefix sum group step 2 perform otis move prefix sums computed step 1 processors g n gamma 1 step 3 group modified prefix sum values received step 2 modification processor p computes rather step 4 perform otis move modified prefix sums computed step 3 step 5 group local broadcast modified prefix sum received processor step processor adds local prefix sum computed step 1 modified prefix sum received step 5 local prefix sums steps 1 3 take 3 moves simd mimd models local data broadcast step 5 takes 2 moves overall complexity 8 moves 2 otis moves reduced moves 2 otis moves deferring step 1 moves step 5 step 1 group compute row prefix sums r step 2 column group computes modified prefix sums r values step 3 perform otis move prefix sums computed step 2 processors g n gamma 1 step 4 group modified prefix sum values received step 3 step 5 perform otis move modified prefix sums computed step 4 step group broadcasts modified prefix sum received step 5 along column mesh step 7 column processors add modified prefix sum received step 6 prefix sum r values computed step 2 minus r value computed step 1 step 8 result computed column processors step 7 broadcast along mesh rows step 9 processor adds r value value received step 8 simulate best 4d mesh prefix sum algorithm resulting otis mesh algorithm takes moves 24 data sum operation processor compute sum values processors optimal simd data sum algorithm step 1 group performs data sum step 2 perform otis move step 3 group performs data sum simd model steps 1 3 take 4 moves step 2 takes 1 otis move total cost 8 moves note since distance processors 0 moves since needs get information least 8 needed moves needed send information 0 0 n gamma cannot overlapped simd model also note simulation 4d mesh data sum algorithm takes 8 moves mimd complexity reduced computing group sums middle processor group rather bottom right processor complexity becomes 4 electronic 1 otis moves n odd 4 n electronic 1 otis moves even simulation 4d mesh however takes 4 moves notice mimd algorithm near optimal diameter otismesh isp 25 rank rank operation processor flag si 2 f0 1g 0 n 2 compute prefix sums processors operation performed 7 electronic 2 otis moves using prefix sum algorithm section 23 26 shift although many variations shift operation ones believe useful application development mesh row shift zero fill shift data processor g x n shift done zero fill end discard ie p data p discarded b mesh column shift zero fill similar along mesh column p x c circular shift mesh row shift data processor g x circular shift mesh column similar c instead p x used row shift zero fill similar except g used place p f group column shift zero fill similar e along group column g x circular shift group row similar c g rather p circular shift group column similar g g x place g shifts types done using best mesh algorithms types e h done 1 perform otis move step 2 shift p x originally g x shift p originally g shift shift step 3 perform otis move shifts types b take electronic moves simd mimd models c take electronic moves simd model maxfjsj moves mimd model e f take electronic 2 otis moves simd mimd models g h take n electronic 2 otis moves simd model maxfjsj electronic 2 otis moves mimd model simulate corresponding 4d mesh algorithms obtain complexity e f take additional 2s gamma 2 otis moves g h take additional 2 theta maxfjsj moves 27 data accumulation processor accumulate values neighboring processors along one four dimensions g x g data processor data accumulation along g x dimension example processor accumulates array data values g x specifically accumulation dimensions similar accumulation operation done using circular shift gammam appropriate dimen sion complexity readily obtained circular shift operation see section 26 28 consecutive sum n 2 processor otismesh tiled onedimensional blocks size blocks may align four dimensions g x g p x p processor values xj ith processor block compute sum xis block specifically processor block computes j indices relative block onedimensional blocks size align p x p dimensions consecutive sum performed using tokens block accumulate sums si assume blocks align along p x processor block initiates token labeled processors intra block index tokens processors 0 right bound gamma 1 left bound odd time steps right bound tokens move one processor right along block even time steps left bound tokens move one processor left along block token reaches rightmost leftmost processor block reverses direction token visits processor block twice moving left moving right rightward visits adds appropriate x value processor time steps hence moves tokens return originating processors done mimd model left right moves done simultaneously electronic moves needed onedimensional size blocks align g x g first otis move run either p x p consecutive sum algorithm otis move number electronic moves p x p alignment however two additional otis moves needed simulation corresponding 4d mesh algorithm takes additional case g x g alignment simd model additional moves mimd model 29 adjacent sum operation similar data accumulation operation section 27 except accumulated values summed operation done complexity data accumulation using similar algorithm 210 concentrate subset processors contain data processors ranked section 25 data really pair r data processor r rank pair r moved processor r 0 r b b number processors data using g p format processor index see r routed originating processor processor brnc r mod n accomplish using steps step 1 pair r routed processor r mod n within current group step 2 perform otis move step 3 pair r routed processor brnc within current group step 4 perform otis move theorem 1 four step algorithm given correctly routes every pair r processor proof step 1 routing second coordinate step route two pairs processor provided group two pairs since group n pairs ranks pairs contiguous integers group two pairs r 1 mod processor one pair pair correct processor group though possibly wrong group get pairs correct groups without changing within group index step 2 performs otis move moves data processor g p processor p g pairs group r mod n value different brnc values routing brnc values step 3 routes one pair processor otis move step 4 therefore gets every pair correct destination processor 2 group 0 step 1 concentrate localized group remaining groups step 1 generalized concentrate ranks increased amount groups may use mesh concentrate algorithm 6 accomplish routing 4 moves step 3 also concentrate brnc values pairs ascending order 0 moves simd model mimd model 6 therefore overall complexity concentrate 8 electronic 2 otis moves simd model 4 moves mimd model improve simd time 7 moves using better mesh concentrate algorithm one 6 new simpler algorithm given case generalized concentration n theta mesh step 1 move data column right current one rightwards proper processor row step 2 move data column left current one leftwards proper processor row step 3 move data smaller row upwards proper processor column step 4 move data bigger row downwards proper processor column concentrate operation square mesh data begins two processors row ends different columns rank two data differs 2 leave two data processor steps 3 4 get data proper row hence proper processor note possible two data items processor following step 1 step 3 complexity concentrate algorithm simd mesh 2 mimd mesh overlap steps 1 2 well steps 3 4 mimd mesh ordinary concentrate ranks begin 1 step 4 omitted data moves column row bigger index ordinary concentrate takes 3 moves improves simd concentration algorithm 6 takes 4 moves ordinary concentrate actually show four step concentration algorithm stated optimal simd model consider ordinary concentrate instance selected elements processors 0 0 ranks 0 1 delta delta delta 1 data processor 0 moved processor 00 requires moves yield net moves also data processor moved processor 0 requires net moves moves none moves overlapped simd model every simd concentrate algorithm must take least moves directions left right total least 3 moves generalized concentrate algorithm ranks need start zero suppose two elements concentrate one processor 00 rank n gamma 1 processor rank n data 00 moved cost right moves data moved 00 cost net left moves least 4 needed theorem 2 otismesh data concentration algorithm described optimal simd mimd models every simd concentration algorithm must make 7 electronic 2 otis moves worst case b every mimd concentration algorithm must make 4 moves proof suppose data concentrated processors shown table 1 let denote processor let c denote processor 0100 ranks b c n 32 n 32 respectively therefore following concentration data da db dc initially processors b c processors 0100 0 respectively figure 2 shows initial concentrated data layout case change g x g p x p values final initial locations da db dc shown table 2 c x x x x x x x x x x x x x x x x x x x x x x x x x x x x b c x x x x x x x x x x x x x x x x x x x x x x x x x x figure 2 data configuration initial b concentrated table 1 processors data concentrate data g x g da gamma table 2 net change g x g p x p maximum net negative change g x g p x p gamma 1 since net negative change g x overlapped net negative change p x since db needs gamma negative change g x p x must make least 2 moves decrease row index within mesh similarly das requirements least 2 moves increase column index within n theta mesh must made turning attention net positive changes see dbs requirements must least 2 moves increase column index dc requires moves increase row index since positive net moves cannot overlapped negative net moves since net moves along g x p x cannot overlapped net moves along g p concentration configuration table 1 must take least 7 moves addition 7 moves need least 2 otis moves concentrate data table 1 see consider data initially group 01 data group 00 following concentration least one otis move needed move data group 01 nontrivial otismesh 2 processors row n theta n submesh otismesh least two pieces data must move group 01 group 00 single otis move scatters data group 01 different groups data going different group least one additional otis move must made get data back group therefore concentration configuration table 1 cannot done fewer 2 otis moves b consider initial configuration table 1 since shortest path processor b destination processor 4 one otis move least many electronic moves made worst case every concentration algorithm reason least 2 otis moves needed complete concentration 2 211 distribute inverse concentrate operation section 210 start pairs first q 1 processors 0 route pair processor q algorithm section 210 tells us start pairs processor move running backwards start route complexity distribute operation concentrate operation shown concentrate algorithm section 210 optimal follows distribute algorithm also optimal 212 generalize start initial configuration distribute operation objective processors j simulate 4d mesh algorithm generalize using simulation strategy 11 takes 8 8 moves perform generalize operation simd otismesh improve 8 moves run generalize algorithm 6 adapted use otis moves necessary outer loop algorithm 6 examines processor index bits 2p gamma 1 0 first p iterations moving along bits g index last p iterations along bits p index otismesh would break two parts 1 perform otis move step 2 run generalize procedure 6 bit maintaining original index step 3 perform otis move step 4 run generalize algorithm 6 bit mimd otismesh algorithm takes 4 moves reduce simd complexity 7 moves using better algorithm generalize operation 2d simd mesh algorithm uses observation used us section 210 speed 2d simd mesh concentrate algorithm four possible move directions three possible generalize 2d n theta n mesh possible move directions data increasing row indexes decreasing increasing column indexes observation algorithm generalize 2d mesh becomes step 1 move data along columns increasing row indexes data needed row higher index step 2 move data along rows increasing column indexes data needed processor row higher column index step 3 move data along rows decreasing column indexes data needed processor row smaller column index correctness preceding generalize algorithm established using argument theorem 1 optimality follows theorem 2 fact distribute operation inverse concentrate operation special case generalize operation new efficient generalize algorithm may used step 2 otismesh generalize algorithm cannot used step 4 generalize step requires full capability code 6 permits data movement four directions mesh use new generalize algorithm step 2 otismesh generalize algorithm perform generalize simd otismesh using 7 moves new algorithm optimal simd mimd models follows lower bound concentrate operation established theorem 2 observation made distribute operation special case generalize operation inverse concentrate operation lower bound 213 sorting case operations considered far time algorithm sort obtained simulating similar complexity 4d mesh algorithm sorting 4d mesh figure 3 rowcolumn transformation leightons column sort algorithm kunde 2 fastest simulation sort snakelike rowmajor order usingp n electronic 12 otis moves simd model 7 electronic 6 otis moves mimd model sort rowmajor order additional moves reverse alternate dimensions needed means otismesh simulation kundes 4d mesh algorithm sort rowmajor order take electronic 16 otis moves simd model show leightons column sort 3 implemented otismesh sort rowmajor order using 22 electronic 38 otis moves simd model 11 n electronic 38 otis moves mimd model otismesh sorting algorithm based leightons column sort 3 sorting algorithm sorts r theta array r using following seven steps step 1 sort column step 2 perform rowcolumn transformation step 3 sort column step 4 perform inverse transformation step 2 step 5 sort column alternating order step apply two steps comparisonexchange adjacent rows step 7 sort column figure 3 shows example transformation step 2 inverse figure 4 shows step step example leightons column sort gamma 11 gamma figure 4 example leightons column sort although leightons column sort explicitly stated r theta arrays r used sort arrays rowmajor order interchanging roles rows columns shall use leightons method sort n 12 theta n 32 array interpret n 2 otismesh n 12 theta n 32 array g x giving row index g giving column index element processor shall subdivide g x g p x p g x 4 left right use g x 2gamma4 example since bits g x p8 bits notations helpful describing transformations steps 2 4 column sort use bpc permutations 5 realize transformations bpc permutation 5 specified vector 2 fsigma0 b ja permutation 0 destination data processor may computed following manner let binary representation processors index let destination processors index definition gamma0 regarded 0 0 0 table 3 shows example bpc permutation defined permutation vector gamma3 16 processor otismesh source destination processor g p binary binary g p processor 9 21 1001 0000 00 0 table 3 source destination bpc permutation gamma0 1 2 gamma3 16 processor otis mesh describing sorting algorithm shall times use 4d array interpretation otismesh interpretation processor otismesh corresponds processor 4d mesh use g x denote bit positions g x leftmost p2 bits processor index g x1 represent leftmost p8 bit positions p represent rightmost p2 bit positions p 3gamma4 represent rightmost p4 bit positions strategy sorting steps 1 3 5 7 leightons method collect row recall since sorting n 12 theta n 32 array columnsort steps leightons method become rowsort steps n 12 theta n 32 array n 38 theta n 38 theta n 38 theta n 38 4d submesh otismesh sort row simulating 4d mesh sort algorithm 2 strategy translates following sorting algorithm rows n 12 theta n 32 array n 38 theta n 38 theta n 38 theta n 38 4d submeshes perform bpc permutation p 2 sort row n 12 theta n 32 array sort 4d submesh size n 38 theta n 38 theta n 38 theta n 38 3 inverse step 1 perform columnrow transformation move rows 38 theta n 38 theta n 38 theta n 38 submeshes perform bpc permutation p row n 12 theta n 32 array sort 4d submesh size n 38 theta n 38 theta n 38 theta n 38 5 inverse step 1 perform rowcolumn transformation move rows 38 theta n 38 theta n 38 theta n 38 submeshes perform bpc permutation p 0 x 1gamma3 row alternating order sort 4d submesh size n 38 theta n 38 theta n 38 theta n 38 7 move rows back 4d submeshes perform bpc permutation p 0 step 8 apply two steps comparisonexchange adjacent rows submeshes size n 38 theta n 38 theta n 38 theta n 38 perform bpc permutation p row n 12 theta n 32 array sort 4d submesh size n 38 theta n 38 theta n 38 theta n 38 rows back 4d submeshes perform bpc permutation p 0 2gamma4 notice row 4d submesh transform accomplished bpc permutation p 2gamma4 elements row n 12 theta n 32 array interpretation g x value 4d mesh interpretation elements 38 theta n 38 theta n 38 theta n 38 submesh g x 1 value p results prop erty go step 2 step 3 leightons method need first restore n 12 theta n 32 array interpretation using inverse permutation p perform bpc permutation 2gamma4 perform columnrow transform using bpc permutation finally map rows n 12 theta n 32 array 4d submeshes size n 38 thetan 38 thetan 38 thetan 38 using bpc permutation p three bpc permutation sequence equivalent single bpc permutation p preceding otismesh implementation column sort performs 6 bpc permutations 4 4d mesh sorts two steps comparisonexchange adjacent rows since sorting steps take 38 time use kundes 4d mesh sort 2 followed transform snakelike rowmajor rowmajor since remaining steps take 12 time shall ignore complexity sort steps reduce number bpc permutations 6 3 follows first note p step 1 moves elements rows n 12 theta n 32 array n 38 theta n 38 theta n 38 theta n 38 4d submeshes sort step 2 doesnt really matter n 32 elements go 4d submesh initial configuration arbitrary unsorted configuration may eliminate note bpc permutations steps 7 9 cancel perform comparisonexchange step 8 moving data one n 38 theta n 38 theta n 38 theta n 38 4d submesh adjacent one back 38 time observations algorithm sort otismesh becomes 1 sort subarray size n 38 theta n 38 theta n 38 theta n 38 step 2 perform bpc permutation p c step 3 sort subarray step 4 perform bpc permutation p 0 c step 5 sort subarray step apply two steps comparisonexchange adjacent subarrays step 7 sort subarray step 8 perform bpc permutation p 0 using bpc routing algorithm 10 three bpc permutations done usingp n electronic 3 log moves simd model n electronic moves mimd model careful analysis based development 5 10 reveals permutations p 0 p c p 0 c done 28 n electronic log moves simd model 14 n electronic 3 log mimd model using p 0 2gamma4 permutation cost becomes 22 n electronic log 2 n5 otis moves simd model 11 log 2 n5 otis moves mimd model total number moves thus 22 electronic 38 otis moves simd model 11 38 otis moves mimd model superior cost sorting algorithm results simulating 4d rowmajor mesh sort kunde 2 214 random access read rar random access read rar 8 processor wishes read data variable processor steps suggested 8 operation step 0 processor creates triple initially empty 1 sort triples step 2 processor checks processor 1 deactivates triples third coordinate step 3 rank remaining processors step 4 concentrate triples using ranks step 3 step 5 distribute triples according third coordinates step load triple value processor step 7 concentrate triples using ranks step 3 step 8 generalize triples get configuration following step 1 step 9 sort triples first coordinates using simd model rar algorithm 8 take 79 moves 38 otis moves mimd model takes 45 moves 215 random access write raw processor wants write data processor 0 n 2 steps raw algorithm 8 step 0 processor creates tuple di 1 sort tuples second coordinates step 2 processor deactivates second coordinate tuple second coordinate tuple step 3 rank remaining processors step 4 concentrate tuples using ranks step 3 step 5 distribute tuples according second coordinates implements arbitrary write method concurrent write one processors wishing write location permitted succeed priority model may implemented sorting step 1 within priority common combined models also implemented increased complexity simd model raw takes 43 moves mimd model takes 26 moves 3 conclusion developed otismesh algorithms basic parallel computing algorithms 8 algorithms run faster simulation fastest algorithms known 4d meshes table 4 summarizes complexities algorithms corresponding ones obtained simulating best 4dmesh algorithms note worst case complexities listed broadcast window broadcast operation case n even presented data sum operation mimd model also complexities listed circular shift data accumulation adjacent sum assume shift distance n2 mimd model table 4 gives dominating n terms sorting algorithms data broadcast data sum concentrate distribute generalize optimal r routing sorting meshconnected arrays tight bounds complexity parallel sorting optical transpose interconnection system architectures optimal routing algorithm meshconnected parallel computers data broadcasting simd computers randomized routing hypercube algorithms applications image processing pattern recognition bpc permutations otishypercube optoelectronic computer bpc permutations otismesh optoelectronic computer scalable network architectures using optical transpose interconnection system otis tr ctr alayyoub awwad k day ouldkhaoua generalized methods algorithm development optical systems journal supercomputing v38 n2 p111125 november 2006 behrooz parhami hamiltonicity swapped otis networks built hamiltonian component networks information processing letters v95 n4 p441445 31 august 2005 ahmad awwad otisstar attractive alternative network proceedings 4th wseas international conference software engineering parallel distributed systems p16 february 1315 2005 salzburg austria khaled day abdelelah alayyoub topological properties otisnetworks ieee transactions parallel distributed systems v13 n4 p359366 april 2002 xiaofan yang graham megson david j evans oblivious shortestpath routing algorithm fully connected cubic networks journal parallel distributed computing v66 n10 p12941303 october 2006 behrooz parhami swapped interconnection networks topological performance robustness attributes journal parallel distributed computing v65 n11 p14431452 november 2005 ahmad awwad otisstar attractive alternative network proceedings 4th wseas international conference software engineering parallel distributed systems p16 february 1315 2005 salzburg austria khaled day optical transpose kary ncube networks journal systems architecture euromicro journal v50 n11 p697705 november 2004 prasanta k jana polynomial interpolation polynomial root finding otismesh parallel computing v32 n4 p301312 april 2006 chihfang wang sartaj sahni matrix multiplication otismesh optoelectronic computer ieee transactions computers v50 n7 p635646 july 2001 chihfang wang sartaj sahni image processing otismesh optoelectronic computer ieee transactions parallel distributed systems v11 n2 p97109 february 2000
efficient algorithm row minima computations basic reconfigurable meshes abstracta matrix size mn containing items totally ordered universe termed monotone every j 1 jm minimum value row j lies right minimum row monotone matrices variations thereof known many important applications particular problem computing row minima monotone matrix import image processing pattern recognition text editing facility location optimization vlsi first main contribution exhibit number nontrivial lower bounds matrix search problems lower bound results hold arbitrary infinite twodimensional reconfigurable meshes long input pretiled onto contiguous nn submesh thereof specifically context show every algorithm solves problem computing minimum nn matrix must take log log n time lower bound shown hold problem computing minimum row arbitrary nn matrix byproduct obtain log log n time lower bound problem selecting kth smallest item monotone matrix thus extending best previously known lower bound selection reconfigurable mesh finally show omega left sqrt loglog n right time lower bound task computing row minima monotone nn matrix second main contribution provide nearly optimal algorithm rowminima problem monotone matrix size mn mn pretiled one item per processor onto basic reconfigurable mesh size rowminima algorithm runs olog n time 1 2 oleft log n log mloglog right time 2 case nepsilon constant epsilon0 epsilon le 1 algorithm runs olog log n time b introduction recently attempt reduce large computational diameter meshconnected architecture enhanced various broadcasting capabilities involve endowing mesh static buses buses whose configuration fixed cannot change recently researches proposed augmenting mesh architecture reconfigurable broadcasting buses highspeed buses whose configuration dynamically changed response specific processing needs examples include bus automaton 25 26 reconfigurable mesh 21 mesh bypass capability 12 content addressable array processor 31 reconfigurable network 7 polymorphic processor array 1620 reconfigurable bus shift switching 15 gatedconnection network 27 28 parbs 30 polymorphic torus network 13 17 see comprehensive survey paper nakano 22 among reconfigurable mesh variants turned valuable theoretical models allowed researchers fathom power reconfiguration relationship pram practical standpoint however reconfigurable mesh variants 2130 omit important properties physical architectures consequently provide complete precise characterization real systems moreover models flexible powerful turned impossible derive highlevel programming models reflect flexibility intrinsic power 16 20 worse yet recently shown reconfigurable mesh parbs scale consequence immediately support virtual parallelism 18 19 motivated goal developing algorithms scalable model computation adopt restricted version reconfigurable mesh call basic reconfigurable mesh brm short model derived polymorphic processor array ppa proposed 1620 brm shares ppa restrictions reconfigurability directionality bus system brm differs ppa allow torus connections result brm potentially weaker ppa important stress programming model developed 16 20 ppa also applies brm particular broadcast primitives developed 16 20 exception using torus connections inherited brm fact algorithms developed paper could easily written using extended c language primitives 1620 opted specifying algorithm conventional fashion make presentation easier follow consider twodimensional array ie matrix size theta n items totally ordered universe matrix termed monotone every smallest value row j lies right smallest value row illustrated example row minima highlighted matrix said totally monotone every submatrix monotone concepts monotone totally monotone matrices may seem artificial contrived first rather surprisingly however concepts found dozens applications problems optimization vlsi design facility location problems string editing pattern recognition computational morphology among many others reader referred 16 many applications discussed detail one recurring problem involving matrix searching referred rowminima computation 6 particular aggarwal et al 2 shown task computing rowminima theta n monotone matrix sequential lower bound omegagamma n log also showed lower bound tight exhibiting sequential algorithm rowminima problem running log time case matrix totally monotone sequential complexity reduced best knowledge time lower bound rowminima problem obtained parallel models computation spite importance problem first main contribution paper propose number nontrivial time lower bounds matrix search problems lower bounds hold general twodimensional reconfigurable meshes infinite size long input pretiled onto contiguous submesh size n theta n specifically context show every algorithm solves problem computing smallest item n theta n matrix must takeomegagamma238 log n time lower bound shown hold problem computing minima row arbitrary n theta n matrix byproduct obtain omegagamma13 log n time lower bound problem selecting kth smallest item monotone matrix previously hao et al 10 obtained log n lower bound selection arbitrary matrices finite reconfigurable meshes thus lower bound extends result 10 two directions show lower bound applies selection monotone matrices reconfigurable mesh infinite size finally show almost tight omegagamma log log n time lower bound task computing row minima monotone n theta n matrix second main contribution provide efficient algorithm rowminima problem monotone matrix size theta n n pretiled one item per processor onto brm size rowminima algorithm runs log n log log log time case constant ffl 0 algorithm runs olog log n time remainder work organized follows section 2 introduces model computations adopted paper section 3 discusses number relevant lowerbound results section 4 presents basic algorithms key subsequent rowminima algorithm section 5 gives details rowminima algorithm finally section 6 offers concluding remarks poses open problems 2 basic reconfigurable mesh basic reconfigurable mesh brm short size theta n consists mn identical simd processors positioned rectangular array rows n columns usual assumed every processor knows coordinates within mesh let p j denote processor placed row column j p 1 1 northwest corner mesh figure 1 basic reconfigurable mesh size 4 theta 4 processor p j connected four neighbors p gamma exist four ports n e w illustrated figure 1 local connections ports established subject following restrictions 1 time unit one pairs ports n ew set moreover 2 processors connect pair ports must connect 3 broadcasting resulting subbuses unidirectional example processors set ew connection resulting horizontal buses broadcasting done either eastbound else westbound figure 2 examples unidirectional horizontal subbuses refer reader figure 2ab illustration several possible unidirectional sub buses brm much like recently proposed ppa multiprocessor array except brm torus connections present ppa series papers 16 1820 maresca coworkers demonstrated ppa architecture corresponding programming environment feasible costeffective implement also enjoys additional features set apart standard reconfigurable mesh parbs specifically researchers argued convincingly reconfigurable mesh powerful unrestricted support virtual parallelism presentday technology contrast ppa architecture shown scale thus support virtual parallelism 16 18 brm easily shown inherit attractive characteristics ppa including support virtual parallelism cbased programming environment making eminently practical 16 assume ideal communications along buses delay although inexact series recent experiments ppa 16 gcn 27 28 seem indicate reasonable working hypothesis 3 lower bounds main goal section demonstrate nontrivial lower bounds several matrix search problems lower bound arguments use restrictions brm holding powerful reconfigurable meshes allow local connections fact arguments hold arbitrary twodimensional reconfigurable meshes infinite size provided input placed contiguous n theta n submesh thereof formally section deals following problems problem 1 given n theta n matrix pretiled one item per processor onto n theta n submesh reconfigurable mesh find minimum item matrix problem 2 given n theta n matrix pretiled one item per processor onto n theta n submesh reconfigurable mesh find minimum item row problem 3 given n theta n monotone matrix pretiled one item per processor onto n theta n submesh 1 theta 1 reconfigurable mesh find minimum item row problem 4 given n theta n totally monotone matrix pretiled one item per processor onto n theta n submesh 1 theta 1 reconfigurable mesh find minimum item row show problems 1 2 anomegagamma29 log ntime lower bound problem 3 omegagamma log log ntime lower bound lower bound problem 4 still open proofs based technique detailed 11 29 uses following graphtheoretic result turan 8 recall independent set graph set pairwise nonadjacent vertices lemma 31 e arbitrary graph g independent set u lemma used implicit adversary argument bound number items matrix possible choices minimum let v set candidates minimum beginning current iteration let e stand set pairs candidates compared within current iteration situation benefits represented graph e v e representing respectively vertices edges graph intuitively obvious adversary choose outcome comparisons way next set candidates larger size independent set u g words set v candidates set e pairs compared minimum finding algorithm items independent set u potential becoming minimum consequently items u still candidates minimum comparing pairs e make presentation easier follow assume time unit partitioned following three stages phase 1 bus reconfiguration ie processors set local connections phase 2 broadcasting ie processors send data item port receive piece data port phase 3 local computation ie every processor selects two elements stored local memory compares changes internal status begin proving following lemma lemma 32 every algorithm solves problem 1 log n time proof evaluate number pairs compared algorithm phase 3 time unit notice phase 2 time unit 4n items sent outside submesh hence altogether 4nt items sent execution phase 3 time unit therefore outside submesh compare mostb 4nt1 items inside submesh compare n 2 pairs phase 3 consequently phase 3 time unit 16n 2 compared 1 theta 1 reconfigurable mesh let c number candidates minimum phase 3 time unit virtue lemma 31 applying logarithm obtain log c 2 log c complete algorithm end time units c must less equal 1 therefore must hold turn implies 2omegagamma400 log n claimed 2 worth mentioning lemma 32 implies similar lower bound task selection monotone matrices see note given arbitrary matrix size n theta n construct monotone matrix 0 size n theta n 1 simply adjoining column vector whose entries gamma1 clear minimum item precisely n smallest item 0 thus following result lemma 33 every algorithm selects kth smallest item monotone matrix size n theta n requires omegagamma108 log n time previously hao et al 10 obtained log n lower bound selection arbitrary matrices finite reconfigurable meshes thus lemma 33 extends result 10 two directions first shows omegagammaat log n remains lower bound selection monotone matrices second shows lower bound must hold even infinite reconfigurable meshes lemma 34 every algorithm solves problem 2 log n time proof suppose contrary problem 2 requires olog log n time however using algorithm proposition 41 section 4 minimum matrix computed o1 time contradicts lemma 32 2 lemma 35 every algorithm solves problem 3 requires omegagamma log log n time proof since algorithm solves problem 3 olog log n time see section 5 assume upper bound problem 3 olog log n assume rowminima algorithm spent time found rowminima far execute phase 3 time unit ffl log log n small fixed ffl 0 proceeding proof lemma 32 see 17n 2 2 pairs compared phase 3 time unit simple counting argument guarantees n 1gamma14 rows assigned least 17n comparisons time unit hence time least n gamma 1gamma14 rows assigned 17n 114 assume topmost row assigned 17n 114 comparisons time unit number candidates top row end phase 3 time unit applying logarithm log c 2 log c hence small fixed ffl 0 c ffl log log n 1 large n therefore least n gamma tn 1gamma14 rows including topmost row cannot find rowminima phase 3 time unit consequently tn 1gamma14 rows find rowminima phase 3 time unit turn implies exist ntn 1gamma14 consecutive rows cannot find rowminima phase 3 time therefore find submatrix size n 14 theta n 14 n 14 rowminima rowminima found let theta size submatrix rowminima rowminima found time addition large holds thus large applying logarithm twice write log log log log log log log log hence order 1 must case 2 omegagamma log log n proof 4 preliminaries data movement operations central many efficient algorithms parallel machines constructed interconnection networks processors purpose section review number basic data movement techniques basic reconfigurable meshes consider sequence n items 1 interested computing prefix maxima defined every j 1 j n setting z g recently olariu et al 23 showed task computing prefix maxima sequence n numbers stored first row reconfigurable mesh size theta n solved olog n time log n log algorithm crucial understanding algorithm computing row minima monotone matrix present adaptation algorithm 23 brm begin exhibit o1 time algorithm computing prefix maxima n items brm size n theta n idea first algorithm involves checking j 1 j n whether j maximum 1 details spelled following sequence steps reader referred figure 3af algorithm illustrated input sequence 7 3 8 6 algorithm step 1 establish vertical bus every column j 1 every processor p 1 j 1 broadcasts item j southbound along vertical bus column j step 2 establish horizontal bus every row 1 every processor p broadcasts item n1gammai westbound along horizontal bus row step 3 end step 2 every processor p j stores items n1gammai sets local variable b ij follows step 4 every processor p j connects ports e w every processor p j broadcasts 0 eastbound every processor receives 0 w port sets b in1gammai 0 step 5 every processor p j connects ports n every processor p northbound bus column every processor copies value received b 1i every processor p 1 connects ports e w every processor p 1 1 value received port w correctness algorithm easily seen thus following result proposition 41 prefix maxima n items totally ordered universe stored one item per processor first row basic reconfigurable mesh size n theta n computed o1 time next following 23 briefly sketch idea involved computing prefix maxima n items 1 n brm size theta n partitioning original mesh submeshes size theta apply prefixmaxima1 submesh size theta combine groups consecutive submeshes size theta submesh size combine groups consecutive submeshes size theta 2 submesh size mthetam 3 note prefix maxima group consecutive submeshes known prefix maxima combination computed essentially prefixmaxima1 details refer reader 23 summarize discussion state following result proposition 42 prefix maxima n items totally ordered universe stored one row basic reconfigurable mesh size theta n computed log n log time proposition 42 following important consequence proposition 43 let ffl arbitrary constant range 1 prefix maxima n items totally ordered universe stored one item per processor first row basic reconfigurable mesh size n ffl theta n computed o1 time later reference solve particular instance rowminima problem call selective row minima problem consider arbitrary matrix size k theta n stored one item per processor k consecutive rows brm size theta n simplicity exposition assume stored first k rows platform essential goal compute minima rows 1 proceed follows algorithm selectiverowminima 76 b c figure 3 illustrating algorithm prefixmaxima1 r r r r r r i2 r i1 figure 4 illustrating algorithm selectiverowminima step 1 partition bmr nk submeshes r 1 nk size k theta k illustrated figure 4 partition submesh r 1 nk submeshes k size k theta k step 2 compute minimum first row submesh r ij o1 time using proposition 43 let i1 k minima first row r i1 using appropriately established horizontal buses arrange every ij moved processor first row j kth column r ij step 3 perceive original brm size theta n consisting k submeshes k size theta n goal becomes compute every 1 minimum row gamma 1 easy see established vertical buses columns brm partial minima row gamma 1 k1 broadcast southbound first row step 4 using algorithm proposition 42 compute minimum first row log n gammalog k log gammalog log n log time thus proved following result lemma 44 task computing minima rows 1 arbitrary matrix size k theta n stored one item per processor k rows brm size theta n performed log n log time 5 algorithm goal section present details efficient algorithm computing row minima theta n monotone matrix matrix assumed pretiled one item per processor onto brm r size every stores ai j begin stating technical results come handy later begin consider subset rows let ji 1 k 1 k p minimum row r k since matrix monotone must submatrices defined follows consists intersection first rows first ji 1 columns ffl every k consists intersection rows columns ji ffl p consists intersection rows columns ji p n following result used remainder section lemma 51 every matrix k 1 k p monotone proof first let k arbitrary subscript 2 k p refer figure 5 let b k consist submatrix consisting intersection rows columns similarly let c k submatrix consisting intersection rows figure 5 illustrating proof lemma 51 since matrix monotone since ai minimum row none minima rows occur submatrix b k similarly since ai k ji k minimum row k minima rows submatrix c k follows minima rows must occur submatrix k consequently k monotone violate monotonicity perfectly similar argument shows 1 p also monotone completing proof lemma 2 matrices k 1 k p defined pairwise share column following technical result shows one always transform matrices involve distinct columns purpose consider matrix 0 k obtained k replacing every dropping column ji k words 0 k obtained k retaining minimum values first next column removing last column last matrix 0 p taken p following result whose proof omitted used implicitly algorithm lemma 52 every matrix 0 outline algorithm computing rowminima monotone matrix proceeds follows first solve instance selective row minima whose result used partition original matrix number monotone matrices described lemmas 51 52 process continued row minima resulting matrices solved directly problem trivial solution running thetalog n time also best possible even powerful reconfigurable mesh 23 shall therefore assume 2 exposition shall assume c i1 r c i1 figure illustrating partition submeshes r algorithm rowminimaa step 1 partition r size theta n every r illustrated figure 6 step 2 using algorithm lemma 44 compute minima items first row every submesh log n log step 3 let c columns r containing minima tively computed step 2 monotonicity guarantees c 1 c 2 c p submesh consisting processors p r c words r consists intersection rows columns c illustrated figure 6 c i1 figure 7 illustrating submeshes step 4 partition mesh r submeshes 1 illustrated figure 7 log log iterations repeat steps 13 submesh correctness algorithm easy see turn complexity steps 13 combined complexity log step 4 c lemma 44 iteration step 4 also runs log time since essentially log log iterations overall complexity algorithm log log log summarize findings state following result theorem 53 task computing rowminima monotone matrix size theta n pretiled one item per processor brm size solved olog n log log log 2 theorem 53 following consequence corollary 54 task computing rowminima monotone matrix size theta n pretiled one item per processor brm size solved olog log n time 6 conclusions open problems shown problem computing rowminima monotone matrix solved efficiently basic reconfigurable mesh brm weaker variant recently proposed polymorphic processor array 16 specifically exhibited algorithm monotone matrix size theta n stored brm size input solves rowminima problem olog n time case 2 o1 log log log time otherwise particular fixed ffl 0 algorithm runs olog log n time second main contribution propose number nontrivial time lower bounds matrix search problems lower bounds hold general twodimensional reconfigurable meshes infinite size long input pretiled onto n theta n submesh thereof specifically context show every algorithm solves problem computing smallest item n theta n matrix smallest item row n theta n matrix must takeomegagamma453 log n time result implies omegagamma17 log n time lower bound problem selecting kth smallest item monotone matrix extending result 10 two directions show lower bound applies selection monotone matrices reconfigurable mesh infinite size finally showed almost tight omegagamma log log n time lower bound task computing row minima monotone n theta n matrix first nontrivial lower bounds kind known authors number problems remain open first noted discrepancy time lower bound obtained task computing rowminima monotone matrix upper bound provided algorithm narrowing gap hard problem leave future research second nontrivial lower bounds problem computing rowminima totally monotone matrix known us promises exciting area future research yet another problem interest would solve rowminima problem special case totally monotone matrices trivially algorithm monotone matrices also works totally monotone ones unfortunately date able find nontrivial lower bound problem acknowledgement authors wish thank mike atallah many useful comments pointing number relevant references r applications generalized matrix searching geometric problems geometric applications matrixsearching algorithm notes searching multidimensional monotone arrays efficient parallel algorithms string editing related problems faster parallel algorithm matrix searching problem efficient parallel algorithm row minima totally monotone matrix power reconfiguration graphs hypergraphs pattern classification scene analysis selection reconfigurable mesh introduction parallel algorithms ieee transactions computers reconfigurable buses shift switching concepts applications ieee transactions parallel distributed systems connection autonomy simd computers vlsi implementation virtual parallelism support reconfigurable processor arrays hierarchical node clustering polymorphic processor arrays hardware support fast reconfigurability processor arrays parallel computations reconfigurable meshes bibliography published papers dynamically reconfigurable architectures fundamental data movement reconfigurable meshes fundamental algorithms reconfigurable meshes ultimate limitations parallel processing bus automata bit serial associate processor gated interconnection network dynamic programming parallelism comparison problems constant time algorithms transitive closure problem applications ieee transactions parallel distributed systems image understanding architecture tr ctr schwing larry wilson optimal algorithms multiple query problem reconfigurable meshes applications ieee transactions parallel distributed systems v12 n9 p875887 september 2001 tatsuya hayashi koji nakano stephen olariu olog log n2 time algorithm compute convex hull sorted points reconfigurable meshes ieee transactions parallel distributed systems v9 n12 p11671179 december 1998 r lin k nakano olariu c pinotti j l schwing zomaya scalable hardwarealgorithms binary prefix sums ieee transactions parallel distributed systems v11 n8 p838850 august 2000 alan bertossi alessandro mei time work optimal simulation basic reconfigurable meshes hypercubes journal parallel distributed computing v64 n1 p173180 january 2004
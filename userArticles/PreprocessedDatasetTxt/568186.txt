unifying objectoriented programming typed functional programming wide practice objectoriented programming current software construction evident despite extensive studies typing programming objects still undeniably challenging research task design type system objectoriented programming effective capturing program errors unobtrusive program construction paper present novel approach typing objects makes use recently invented notion guarded dependent datatypes show approach address various difficult issues eg handling self type typing binary methods etc simple natural typetheoretical manner remedying deficiencies many existing approaches typing objects b introduction popularity objectoriented programming current software practice evident popularity may result part tendency chase latest fads programming languages undeniably real substance growing use objectoriented program ming particular objectedoriented programming significantly software organization reuse encapsulation inheritance polymorphism building previous experience dependent ml 20 18 partially supported nsf grants ccr0081316 ccr0092703 permission make digital hard copies part work personal classroom use granted without fee provided copies made distributed profit commercial advantage copies bear notice full citation first page copy otherwise republish post servers redistribute lists requires prior specific permission andor fee asiapepm02 september 1214 2002 aizu japan naturally interested combining objectoriented programming dependent types however straightforward combination dependent types objectoriented programming eg following javalike approach largely un satisfactory approach often requires substantial use runtime type downcasting search satisfactory approach noticed recently invented notion guarded recursive datatype constructors 19 combined dependent types enable construction type system programming objects needs use type downcasting highly desirable type downcasting probably one common causes program errors objectoriented languages like java briefly outline basic idea behind approach typing programming objects central idea objectedoriented programming course programming ob jects really programming object unfortu nately currently simple answer question unlikely paper take view programming objects spirit smalltalk 12 14 suggest conceptualize programming object little intelligent capable performing actions according messages receives suggest think programming object record fields methods paper present example illustrate view objects formulated typed setting assume existence type constructor msg takes type forms message type msg receiving message type msg object supposed return value type therefore assign following type obj objects suppose declared msggetfst msggetsnd msgsetfst msgsetsnd message constructors following types 1 stands unit type msggetfst msgsetfst figure 1 implement integer pairs messagepassing style withtype clause type annotation assigns type int int obj defined function newintpair 1 note mllike syntax used present examples throughout paper given integers x 1 reason newintpair welltyped explained section 2 figure 2 value constructors associated gr datatype constructor hoas fun newintpair x val val fun dispatch msggetfst xref dispatch msggetsnd yref dispatch msgsetfst dispatch msgsetsnd dispatch dispatch end withtype int int obj figure 1 implementation integer pairs construct integer pair anintpair calling newintpairxy send message msggetfst pair obtain first component anintpairmsggetfst also reset first component x sending message msgsetfstx operations second component pair performed similarly exception raised runtime anintpair cannot interpret message sent obviously exists serious problem approach implementing objects since every object currently assigned type obj cannot use types dierentiate objects instance suppose msgfoo another declared message constructor type 1msg anintpair msgfoo welltyped execution leads uncaught exception unknownmessage runtime clearly undesirable anintpairmsgfoo rejected compiletime illtyped expression address issue many ones objectedoriented programming making use restricted form dependent types developed dependent ml 20 18 type constructor msg call guarded recursive gr datatype constructor notion gr datatype constructors extends notion datatypes ml recently invented setting functional programming handling intentional polymorphism runtime type passing 19 write guarded type type variable context may contain type constraints instance 1 guarded type type equivalent int int since must map 1 int order satisfy type constraint 1 2 int bool type 2 also guarded type equivalent type void ie type element since type constraint 1 2 int cannot satisfied 1 2 1 2 notice type following interesting feature instantiating type 0 obtain type equivalent 1 1 0 form 1 2 void 0 forms guarded recursive datatype constructor recursively defined type constructor constructing guarded datatypes a1a2 a1a2 a1a2 a2 hoasapp a1 a2 hoas a1 hoas a1 a1 hoaslift a1 figure 3 example gr datatype constructor special form sum types component guarded type present short example gr datatype constructor follows illustrating tion details examples found 19 syntax figure 3 essentially declares type constructor hoas take type form another type hoas intuitively value type hoas represents higherorder abstract syntax tree 9 16 value type value constructors associated hoas given types figure 2 note type constructor hoas cannot defined ml negative occurrence hoas argument type hoaslam hoas cannot inductively defined either reason calling hoas guarded recursive datatype constructor hoas defined follows fixedpoint operator kind types value constructors associated hoas readily defined use foldunfold recursive types injection sum types define evaluation function follows computes value represented given higherorder abstract syntax tree fun evalhoastup x1 evalhoaslam evalhoasapp x1 withtype hoas note withtype clause type annotation provided user indicates eval function type hoas words evaluation function eval typepreserving rest paper present type system support gr datatype constructors outline approach implementing programming objects explaining various issues objectoriented programming addressed types 1 1 2 1 2 patterns p x p1 p2 cp clauses ms p1 e1 pn en expressions e x f c e case e ms values v x c v v1 v2 exp var ctx typ var ctx 1 2 figure 4 syntax internal language 2g 2 language 2g present language 2g based explicitly typed secondorder polymorphic calculus present static dynamic semantics 2g show type system 2g supports gr datatype con structors sound 21 syntax present syntax 2g figure 4 mostly standard use type variables 1 unit type possibly empty sequence types 1 n two kinds expression variables x lamvariables f fixvariables use xf either lamvariable fixvariable form abstraction lamvariable fixedpoint expression fixvariable note lamvariable value fixvariable use c constructors assume every constructor unary 2 also require body either fix value syntax patterns explained section 24 use substitutions mapping type variables types dom domain note assume dom extends mapping similar notations also used substitutions mapping variables xf expressions write result applying type expression type variable context expression variable context etc use type variable contexts 2g require explanation usual declare type variable type variable context use mean wellformed type every type variable declared type formation rules standard thus omitted also declare type equality 1 2 intuitively deciding type equality assume types 1 2 equal 1 2 declared given two types 1 2 write mean 1 equivalent 2 following rules deriving judgments form roughly means matches 2 constructor taking argument treat constructor taking unit argument pattern typing rules p pattup patcons clause typing rule p clauses typing rule ms 1 2 figure 5 pattern typing rules use 1 2 type constraint constraint satisfied 12 every derivable expected following proposition proposition 21 derivable holds 1 2 holds 2 1 also holds 1 2 2 3 hold 1 3 also holds 22 solving type constraints need solving type constraints form 1 2 form typing rules 2g tunately decision procedure based set rules figure 7 rules use range type constructors either builtins userdefined gr datatype constructors skolemized constants theorem 22 1 2 holds 1 2 derivable proof induction derivation 1 2 23 gr datatype constructors use kind types kind type constructors arity n n number use recursive type constructor arity n associate list value constructors c1 ck 1 k type c form sequence types expression typing rules tycons tysnd case e ms 2 figure typing rules expressions free occurrences free occurrences fresh skolemized constant figure 7 rules solving type constraints stands possibly empty sequence quantifiers assuming concrete syntax declared follows typecon type 2 k n ck k present simple examples gr datatype constructors facilitate understanding concept example 1 following syntax top declares value constructor top type top top defined equivalent example 2 following syntax nil cons list declares two constructors nil cons types 1 list list list respectively type constructor list define follows essentially equivalent type constructor t1 note usual list type constructor ml defined 24 pattern matching use p patterns usual either type variable value variable may occur pattern use judgment form v p mean matching value v pattern p yields substitutions type value variables p rules deriving judgments listed follows given type variable context 0 pattern p type use rules figure 5 derive judgment form 0 p whose meaning formally captured lemma 24 25 static dynamic semantics present typing rules 2g figure 6 assume existence signature types constructors declared typing rules standard type tyeq indicates type equality 2g modulo type constraint solving please notice great dierence rules presented figure 5 typing clauses standard ones 15 form dynamic semantics 2g use evaluation contexts defined evaluation context e fste snde e ev e ee case e ms definition 23 redex defined follows fstv1 v2 redex reduces v1 sndv1 v2 redex reduces v2 x ev redex reduces ex v v redex reduces v let e end redex reduces ex v fixf v redex reduces vf fixf v case v ms redex v p derivable clause p e ms redex reduces e note may certain amount nondeterminism reduction case v ms v may match patterns several clauses ms given redex e1 write e1 e2 e1 reduces e2 e1 redex reducing e2 say reduces e 2 one step let reflexive transitive closure say e1 reduces e2 many steps e1 e2 holds given closed welltyped expression e 2g use e type erasure e expression obtained erasing types e evaluate e untyped calculus extended pattern matching clearly holds e evaluates e words 2g supports typeerasure semantics 26 type soundness given expression variable context x closed type x dom write derivable x general write mean derivable holds following lemma essentially verifies rules deriving judgments form p properly formed lemma 24 assume 0 p derivable holds v closed value type 0 derivable v p 0 0 holds proof structural induction derivation 0 p usual need following substitution lemma establish subject reduction theorem 2g lemma 25 assume e derivable holds e derivable proof structural induction derivation e theorem 26 subject reduction assume e derivable e e holds e also derivable proof assume e1 reduces e2 proof follows structural induction e case proof proceeds induction height derivation handling various cases use lemma 25 handling typing rule tycase lemma 24 needed however cannot prove e welltyped nonvalue expression e must reduce another welltyped expression case case v ms redex v match pattern ms evaluation e becomes stuck far reason evaluation expression become stuck 3 implementing objects section briefly outline approach implementing objects use gr datatype constructors 31 section 1 noticed serious problem type obj allows dierentiation objects address problem providing type constructor msg another parameter given type class c msgc type intuition message type sent objects class c assign type objc defined follows first foremost emphasize class type really tag used dierentiate messages instance may declare class intpairclass associate fun newpair x val val fun dispatch msggetfst xref dispatch msggetsnd yref dispatch msgsetfst dispatch msgsetsnd dispatch dispatch end withtype ab b objpairclassab figure 8 constructor pairs following message constructors corresponding types msggetfst msgsetfst function newintpair given type int int objintpairclass since anintpair type objintpairclass anintpair msgfoo becomes illtyped msgfoo type 1msgc class c intpairclass although classes treated types syntactically feel better treat type index expressions following dependent ml 20 18 use class sort classes following presentation assume availability gr datatype constructors dml 32 parameterized classes immediate need class tags parameterizing types suppose generalize monomorphic function newintpair polymorphic function newpair take arguments x types return object representing pair whose first second components x respectively need class constructor pairclass takes two given types 1 2 forms class 1 2pairclass may use syntax declare class constructor associate following polymorphic message constructors msggetfst msgsetfst function newpair constructing pair objects implemented figure 9 33 subclasses inheritance major issue objectoriented programming significantly facilitate code organization reuse approach issue inheritance introducing predicate sort class given two classes c1 c2 c1 c2 means c1 subclass c2 type message constructor mc general form ac msga ac1 2msga c means subset sort class c ie sort subclasses class c sequence types length mc becomes message constructor polymorphic subclasses therefore mc used fun newpair x val fun dispatch msggetfst xref dispatch msggetsnd yref dispatch msgsetfst dispatch msgsetsnd dispatch dispatch end withtype ab b objabpairclass fun newcoloredpair c x val fun dispatch msggetcolor cref dispatch msgsetcolor dispatch msggetfst xref dispatch msggetsnd yref dispatch msgsetfst dispatch msgsetsnd dispatch dispatch end withtype ab color b figure 9 functions constructing objects classes pairclass coloredpairclass construct message object tagged subclass class c0 instance message constructors associated pairclass assigned types figure 10 suppose introduce another class constructor coloredpairclass takes two types form class also assume following ie 1 2 coloredpairclass subclass 1 2p airclass types 1 2 coloredpairclass pairclass associate coloredpairclass message constructors msggetcolor msgsetcolor assigned types figure 10 implement function newcoloredpair figure 9 constructing colored pairs clearly implementation newcoloredpair shares lot common code newpair provide proper syntax later programmer eciently reuse code implementation newpair implementing newcoloredpair 34 binary methods approach typed objectoriented programming offers particularly clean solution handling binary meth ods instance declare class eqclass associate two message constructors msgeq msgneq given following types suppose self object type objc c eq pass message msgeqother self required type objc order self msgeqother welltyped unfortunately requirement cannot enforced type system java consequence msggetfst msgsetfst msggetcolor coloredpairclass color msggetcolor msgsetcolor coloredpairclass color 1msgsetcolor figure 10 message constructors types type downcasts often needed implementing testing equality objects 35 self type approach also oers particularly clean solution handling notion self type namely type receiver message suppose want support message msgcopy sent object obtain copy object 3 may assume msgcopy message constructor associated class objclass c objclass holds class c assign msgcopy following type indicate returned object class object message sent done java state type system java object return another object receiving message msgcopy imprecise rich source use type downcasting 36 inheritance inheritance done smalltalklike manner significant dierence use concrete example illustrate inheritance implemented also proper place us introduce syntax designed facilitate objectoriented programming use following syntax declare class objclass message constructor msgcopy type note selftype merely syntactic sugar class objclass msgcopy selftype self addition syntax also automatically induces definition function superobj written follows mllike syntax self ordinary variable fun dispatch msgcopy self dispatch dispatch end withtype objclass obja obja function superobj present solely explaining inheritance implemented function 3 actual implementation copy constructed occur source program type function objclassobja obja indicates function takes object tagged subclass c objclass returns object tagged class general class c super function type cobja obja associated c soon clear function holds key implementing inheritance use following syntax declare classes int1class coloredint1class well message constructors associated class int1class inherits objclass msggetx int msgsetx int unit msgdouble unit class coloredint1class inherits int1class color already defined type msggetc msgsetc super functions associated classes int1class coloredint1class automatically induced follows fun dispatch msgdouble dispatch dispatch end withtype int1class obja obja fun dispatch dispatch end withtype coloredint1class obja obja functions constructing objects classes int1class coloredint1class implemented figure 11 something really interesting suppose use newint1 newcoloredint1 construct objects o1 o2 tagged int1class coloredint1class respectively send message msgcopy o1 copy o1 o1 returned send msgdouble o2 integer value o2 doubled inherits corresponding method class int1class remarkable object o2 returned send message msgcopy o2 reason copying method defined o2 searching copying method eventually finds one defined class objclass method defined either class coloredint1class class int1class desirable consequence o2 treated object fun newint1 x0 val fun dispatch dispatch msgsetx dispatch msgcopy newint1 x dispatch dispatch msg dispatch end withtype int objint1class fun newcoloredint1 c0 color x0 val fun dispatch dispatch msgsetc dispatch dispatch msgsetx dispatch dispatch msg dispatch end withtype int objcoloredint1class figure 11 functions constructing objects int1class coloredint1class class int1class either fbounded polymorphism matchbounded polymorphism returned object would class int1class class coloredint1class would generated newint1 o2msgget x making type system unsound currently aware approach correctly typing simple exam ple note function newint becomes illtyped employ notion mytype 37 subtyping explicit subtyping relation ap proach instead use existentially quantified dependent types simulate subtyping instance given class tag c type acobja sum types obja satisfying c hence c1 c objc1 regarded subtype objectc value type objc1 coerced value type objectc example type objobjecteqclassobjecteqclasspairclass pair objects whose components support equality test 4 related work conclusion work related intentional polymorphism type classes already rich body studies literature passing types runtime typesafe manner 11 10 17 many studies follow framework 13 essentially provides construct typecase term level perform type analysis primitive recursor typerec type names type level define new type construc tors language ml 13 subsequently extended r 11 support typeerasure semantics type constructor r r seen special gr datatype constructor system type classes haskell provides programming methodology great use practice common approach implementing type classes dictionarypassing dictionary essentially record member functions particular instance type class 1 encountered notion gr datatype constructors seeking alternative implementation type classes intensional polymorphism approach implementing type classes use gr datatype constructors found 19 dependent datatypes dml 20 18 also shed light gr datatype constructors instance following dependent datatype declaration dml datatype list nnat consn1 listn syntax introduces type constructor list takes type type index sort nat form list type constructors nil cons assigned following types cons given type natural number n type listn lists length n element type formally type constructor list defined follows clearly also form guarded datatype constructor guards constraints type index expressions rather types notion objects paper largely taken smalltalk 12 particularly clean intuitive articulation found 14 literature types objectoriented programming simply vast us give even modestly comprehensive overview related work please see 5 references instead focus closely related work either directly influences motivates current work bounded polymorphism 8 6 essentially imposes subtyping restrictions quantified type variables instance suppose want implement class ordered sequences order insert element sequence must compare elements sequence therefore insert elements class provide appropriate methods comparison achieved bounded polymorphism fbounded polymorphism 7 generalizes simple bounded polymorphism introduced handle complex issues typing binary methods objectoriented programming since adopted design gj 2 helping significantly increase expressiveness type system java however fbounded polymorphism seem interact well subclass relation eg please see example page 59 5 matchingbounded polymorphism similar bounded polymorphism main dierence matching constraints imposed quantified type variables instead subtyping constraints notion mytype 4 essentially refers type receiving object mes sage matchbounded polymorphism notion mytype allow possibility dispensing uses fbounded polymorphism language 4 really stateoftheart objectoriented programming language static typing concerned work carried 3 imperative features introduced type system design shares many common features work 4 though employ completely dierent typetheoretical approach particular intend simplify notion mytype also make eective capturing program invariants currently particularly interested implementing closlike object system top dml extended gr datatype constructors facilitating objectoriented programming styles typed functional programming setting 5 r implementing haskell overloading making future safe past adding genericity java programming language paradigmatic objectoriented programming language design foundations objectoriented languages modest model records understanding types formulation simple type theory types flexible type analysis intensional polymorphism typeerasure semantics compiling polymorphism using intensional type analysis definition standard ml revised computation deduction fully reflexive intensional type analysis dependent types practical programming guarded recursive datatype constructors dependent types practical programming tr smalltalk80 language implementation understanding types data abstraction polymorphism fbounded polymorphism objectoriented programming implementing haskell overloading compiling polymorphism using intensional type analysis smalltalk objects design making future safe past intensional polymorphism typeerasure semantics dependent types practical programming flexible type analysis foundations objectoriented languages definition standard ml dependent types practical programming
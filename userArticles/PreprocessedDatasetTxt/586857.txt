approximating throughput multiple machines realtime scheduling consider following fundamental scheduling problem input problem consists n jobs k machines jobs associated release time deadline weight processing time machines goal find nonpreemptive schedule maximizes weight jobs meet respective deadlines give constant factor approximation algorithms four variants problem depending type machines identical vs unrelated weight jobs identical vs arbitrary variants known nphard two variants involving unrelated machines also maxsnp hard specific results obtained follows identical job weights unrelated machines greedy 2approximation algorithm identical job weights k identical machines greedy algorithm achieves tight frac11kk11kk1 approximation factor arbitrary job weights single machine lp formulation achieves 2approximation polynomially bounded integral input 3approximation arbitrary input unrelated machines factors 3 4 respectively arbitrary job weights k identical machines lpbased algorithm applied repeatedly achieves frac11kk11kk1 approximation factor polynomially bounded integral input frac112kk112kk1 approximation factor arbitrary input arbitrary job weights unrelated machines combinatorial 32sqrt2 approx 5828approximation algorithm b introduction consider following fundamental scheduling problem input problem consists n jobs k machines jobs associated release time deadline weight processing time machines goal nd schedule maximizes weight jobs meet deadline scheduling problems frequently referred realtime scheduling problems objective maximizing value completed jobs frequently referred throughput consider four variants problem depending type machines identical vs unrelated weight jobs identical vs arbitrary garey johnson 13 see also 14 show even simplest decision problem corresponding problem already nphard strong sense decision problem input consists set n jobs release time deadline processing time goal decide whether jobs scheduled single machine within time window show two variants involving unrelated machines also maxsnp hard paper give constant factor approximation algorithms four variants problem best knowledge rst paper gives approximation algorithms guaranteed performance approximation factor problems say algorithm approximation factor maximization problem weight solution least 1opt opt weight optimal solution note dened approximation factor would always least 1 specic results obtained listed summarized table given figure 1 weight function identical machines unrelated machines identical job weights 2 18 arbitrary job weights 2 18 integral polysize input arbitrary job weights 3 278 arbitrary input figure 1 entry contains approximation factors identical job weights unrelated machines give greedy 2approximation algorithm identical job weights k identical machines show greedy algorithm achieves tight 11k k approximation factor arbitrary job weights round fractional solution obtained linear programming relaxation problem distinguish case release times deadlines processing times integral polynomially bounded case arbitrary former case achieve 2approximation factor single machine 3approximation factor unrelated machines latter case get 3approximation factor single machine 4approximation factor unrelated machines arbitrary job weights k identical machines achieve 11k k approximation factor polynomially bounded integral input 112k k approximation factor arbitrary input note k tends innity factors tend e 158198 e 254149 respectively arbitrary job weights unrelated machines also present combinatorial 3 2 approximation factor 3 computational diculty problems considered due slack time available scheduling jobs general time window job scheduled may much larger processing time interestingly special case slack time solved optimally polynomial time even multiple machines 3 moreover problem solved single machine execution window less twice length job another special case considered earlier literature case jobs released time equivalently case deadlines special case remains nphard even single machine however sahni 24 gave fully polynomial approximation scheme special case problems considered many applications hall magazine 17 considered single machine version problem context maximizing scientic military commercial value space mission means selecting scheduling advance set projects undertaken space mission individual project typically executable part mission indicated 17 25 budget space mission may spent making decisions hall magazine 17 present eight heuristic procedures nding optimal solution together computational experiments however provide performance guarantees solutions produced heuristics also mention applicability problems patient scheduling hospitals applications related work scheduling literature see 8 11 survey 22 preemptive version problem single machine studied lawler 21 identical job weights lawler showed apply dynamic programming techniques solve problem polynomial time extended techniques obtain pseudopolynomial algorithm arbitrary weights well 21 lawler 20 also obtained polynomial time algorithms solve problem two special cases time windows jobs scheduled nested ii weights processing times opposite order kise ibaraki mine 18 showed solve special case release times deadlines similarly ordered closely related problem considered adler et al 1 context communication linear networks problem messages release times deadlines transmitted bus unit bandwidth goal maximize number messages delivered within deadline turns approximation algorithms case arbitrary weights applied weighted version unbuered case considered 1 obtain constant factor approximation algorithm approximation algorithm given 1 version online version problems jobs appear one one known advance lipton tomkins 23 considered nonpreemptive version online problem koren shasha 19 baruah et al 7 considered preemptive version special cases weight job proportional processing time considered online setting several papers 5 10 12 15 16 6 combinatorial algorithm arbitrary weights borrows techniques used online case algorithms based rounding fractional solution obtained linear programming lp relaxation problem lp formulation single machine variable every feasible schedule jobs constraint job constraint time point naive implementation approach would require unbounded number variables constraints overcome diculty rst assume release times deadlines processing times polynomially bounded integers yields polynomial number variables constraints allowing lp solved polynomial time case arbitrary input show need consider 2 variables constraints n jobs yields strongly polynomial running time expense minor degradation approximation factor rounding lp done reducing problem graph coloring problem extend results single machine multiple machines applying single machine algorithm repeatedly machine machine give general analysis type algorithms interestingly prove approximation factor case identical machines superior approximation factor single machine algorithm served starting point similar phenomenon dierent context observed cornuejols fisher nemhauser 9 analysis unrelated machines case similar one described dierent context awerbuch et al 4 unlike identical machines case unrelated machines case extension multiple machines degrades performance relative single machine algorithms specically lp based algorithms applied achieve approximation algorithms scheduling problems example consider problem compute estimate completion time jobs optimal fractional solution apply algorithms using estimated completion times deadlines get schedule constant fraction jobs indeed nish completion times observation already applied wein 25 achieve constant factor approximation algorithms various problems among minimum owtime problem denitions notations let job system contain n jobs job j characterized quadruple r g interpretation job j available time r release time must executed time deadline processing time machine j ij w weight prot associated job note techniques also extended general case release time deadline job dier dierent machines however simplicity consider case release time deadline job machines hardness results also proved assumption refer case job weights unweighted model case job weights arbitrary weighted model unweighted case goal maximize cardinality set scheduled jobs refer case processing times jobs machines identical machines model case processing times dier unrelated machines model unweighted jobs identical machines model job j characterized triplet r without loss generality assume earliest release time time feasible scheduling job j machine j time r ij referred job instance denoted j ij job instance also represented interval time line 0 1 say interval j ij belongs job j general many intervals may belong job set job instances j 1j 1 feasible schedule machine corresponding intervals independent ie overlap belong distinct jobs weight schedule sum weights jobs intervals job instances belong case multiple machines need nd feasible schedule distinct jobs machines objective maximize sum weights schedules distinguish case release times processing times deadlines integers bounded polynomial number jobs case arbitrary inputs former case referred polynomially bounded integral input latter case referred arbitrary input 3 unweighted jobs section consider unweighted model dene greedy algorithm analyze performance unrelated identical models former model show 2approximation algorithm latter model show kapproximation algorithm 31 greedy algorithm greedy strategy single machine follows time step starting algorithm schedules job instance nishes rst among jobs scheduled later note greedy algorithm take consideration deadlines jobs except determining whether jobs eligible scheduling greedy algorithm multiple machines executes greedy algorithm single machine machine machine dene procedure nextt j j procedure determines job instance j ij 0 0 earliest among instances jobs j start time later machine j interval exists procedure returns null otherwise procedure returns j ij 0 algorithm 1greedyj j nds feasible schedule machine j among jobs j calling procedure next repeatedly 1 rst call j 2 assume algorithm already computed let current time let current set jobs j j n fj g 3 algorithm calls nextt j j returns either j h1 j h1 null 4 algorithm terminates round r returns null returns set g algorithm kgreedyj nds k schedules job appears schedules calls algorithm 1greedy machine machine time updating set j jobs scheduled assume output 1greedyj j rst g j feasible schedule machine j 1 j 1 algorithm calls following property algorithm 1greedy used analysis approximation factors algorithms proposition 31 let set jobs found 1greedyj j job system j g let h feasible schedule machine j among jobs j n g jhj jgj proof interval job instance h exists interval g overlaps terminates earlier otherwise 1greedy would chosen interval proposition follows feasibility h since one interval h overlap end point interval g 2 32 unrelated machines based proposition 31 following theorem states performance kgreedy algorithm unweighted jobs unrelated machines model theorem 32 algorithm kgreedy achieves 2 approximation factor unweighted jobs unrelated machines model proof let output kgreedy let opt sets intervals scheduled k machines optimal solution opt note sets considered jobs job instances interchangeably let h set jobs scheduled opt machine j kgreedy schedule machine let set jobs taken kgreedy opt follows opt proposition 31 implies jh j j jg j j true since h j feasible schedule machine among jobs picked kgreedy constructing schedule machine since sets h j mutually disjoint holds sets g j jhj jgkj since jogj jgkj get jopt kj 2jgkj theorem follows 2 33 section analyze kgreedy algorithm unweighted jobs identical machines model show approximation factor case 95 k 1 analysis quite general uses facts algorithm applied sequentially machine machine machines identical let opt k optimal schedule k identical machines let algorithm one machine dene k k known approximation factor compared opt k note comparison done algorithm uses one machine optimal schedule uses machines let ak algorithm applies algorithm machine machine k times next theorem bound performance ak using k theorem 33 algorithm ak achieves k k approximation factor k identical machines proof let set jobs chosen ak ith machine suppose algorithm already chosen sets jobs consider schedule given removing opt k jobs also chosen optimal solution clearly still feasible schedule cardinality least jopt kj therefore denition k set satises ja j 1kjopt kj rearranging terms gives us equation prove induction assume claim holds 1 applying induction hypothesis equation 1 get rearranging terms yields inductive claim setting proves theorem namely apply theorem algorithm kgreedy compute value k algorithm 1greedy observe algorithm kgreedy indeed applies algorithm 1greedy k times assumed theorem 33 theorem 34 approximation factor kgreedy unweighted jobs identical machines model proof recall algorithm 1greedy scans intervals ordered end points picks rst possible interval belonging job picked suppose greedy strategy picks set g consider schedule machines numbered similar arguments proposition 31 machines particular job h chosen must job progress g also job must nish particular job h nishes thus number jobs h executed single machine optimal schedule jgj since jobs executed optimal schedule dierent machines disjoint get jhj kjgj consequently jopt kj theorem follows setting value k theorem 33 2 34 tight bounds greedy subsection construct instance bounds unweighted model algorithm greedy tight rst show one machine unrelated identical models coincide 2approximation tight next generalize construction unrelated model prove tight bound 2 k 1 machines finally generalize construction one machine k 1 identical machines prove tight bound k recall unweighted model job characterized triplet r identical machines model triplet r g unrelated machines model 341 single machine single machine system contains two jobs g 1greedy schedules instance g 1 0 job g 1 cannot schedule instance h 1 optimal solution schedules instances h 1 0 g 1 2 clearly ratio 2 could repeat pattern time axis obtain ratio number jobs construction demonstrates limitation approach algorithm 1greedy approach ignores deadlines therefore capitalize urgency scheduling job h 1 order miss deadline generalize idea k machines 342 unrelated machines machines job system contains 2k jobs g release time jobs 0 deadline gtype jobs 3 deadline htype jobs 2 length job g machine 1 4 machines length job h machine 2 3 machines note jobs g h scheduled machine since jobs long meet deadline hence algorithm kgreedy considers two jobs constructing schedule machine result kgreedy selects instance g 0 scheduled machine cannot schedule htype jobs hand optimal solution schedules instances h 0 g 2 machine algorithm kgreedy schedules k jobs optimal algorithm schedules 2k jobs yields tight approximation factor 2 unweighted jobs unrelated machines model 343 dene job systems j k given k 1 show j k performance kgreedyj k 1k optj k j 1 system one dened subsection 341 j 2 job system contains 2 set algorithm 2greedy make following selections rst machine 2greedy schedules 6 jobs type g 1 true since jobs length less lengths jobs type g 2 jobs type h last g 1 type interval terminates time 60 hence room g 2 type htype interval deadline 70 48 length 11 12 second machine 2greedy schedules 4 jobs type g 2 since shorter jobs type h last g 2 type job terminates time 44 leaves room another job type h jobs show optimal solution schedules jobs schedules 9 jobs machine follows note instances terminate deadlines result get ratio ready dene j k k 1 job system contains kk jobs algorithm kgreedy able schedule kk1 k k k1 exists optimal solution schedules result get ratio j k system composed k jobs 0 setting large enough number xing force algorithm kgreedy select machine jobs type g jobs thus kgreedy schedule htype jobs hand optimal solution able construct schedule k machines starts scheduling 1k htype jobs rst possible instance schedules turn 1k jobs g k g k order values allow schedule omit details set determine deadlines remark validate optimal schedule get lower bounds deadlines force kgreedy schedule get upper bounds deadlines large enough upper bounds larger lower bounds could check following values weighted jobs section present approximation algorithms weighted jobs rst present algorithms single machine unrelated machines based rounding linear programming relaxation problem reapply analysis theorem 33 get better approximation factors identical machines model conclude combinatorial algorithm unrelated machines ecient easy implement however achieves weaker approximation guarantee 41 approximation via linear programming subsection describe linear programming based approximation algorithm rst describe algorithm case single machine generalize case multiple machines linear programming formulation based discretizing time suppose time axis divided n time slots complexity algorithms depends n however assume n part input discretization time ne enough represent feasible schedule small shifts later show get rid assumptions expense slight increase approximation factor linear program relaxes scheduling problem following way fractional feasible solution one distributes processing job job instances intervals belonging restriction given point time sum fractions assigned intervals belonging jobs exceed 1 end job interval belonging ie r would convenient assume x value 1 n linear program follows maximize subject time slot 1 job 1 n x 1 0 x 1 easy see feasible schedule denes feasible integral solution linear program vice versa therefore value optimal fractional solution linear program upper bound value optimal integral solution compute optimal solution linear program denote value variable x solution q denote value objective function optimal solution opt show round optimal solution linear program integral solution show linear program used dene coloring intervals collection intervals belonging set jobs j regarded interval representation interval graph dene set intervals independent two intervals set set belong job note denition restrictive regular independence relation interval graphs clearly independent set intervals denes feasible schedule weight independent set p wp dened sum weights jobs intervals belong goal color intervals color class induces independent set note intervals required colored interval may receive one color suppose collection color classes independent sets nonnegative coecients exists color class p 1 wp opt2 color class dened approximate solution approximation factor 2 remains show obtain desired coloring take short detour dene group constrained interval coloring problem let interval representation maximum number mutually overlapping intervals 1 suppose intervals partitioned disjoint groups group contains 2 intervals legal group constrained coloring intervals q coloring overlapping intervals allowed get color ii intervals belonging group allowed get color theorem 41 exists legal group constrained coloring intervals q uses proof use greedy algorithm obtain legal coloring using 1 intervals q left endpoint color intervals left right respect ordering interval considered algorithm colored one free colors available time show induction algorithm considers interval always free color true initially algorithm considers interval q colors cannot used q occupied either intervals overlap q intervals belong group q since considering intervals sorted left endpoint intervals overlapping q also overlap hence 1 1 intervals 2 1 intervals belong group q since number available colors always free color 2 back problem coloring intervals let n round fraction q optimal solution closest fraction form 0 1 n 0 incurs negligible error 1nn factor value objective function generate interval graph 0 replacing interval j 2 q n 0 parallel intervals dene group constrained coloring problem 0 group instances job j note 0 maximum number mutually overlapping intervals bounded n 0 maximum number intervals belonging group also n 0 theorem 41 exists group constrained coloring 0 uses 2n 0 1 colors attach coecient 1n 0 color class clearly sum coecients less 2 also construction sum weights intervals color classes multiplied coecient 1n 0 opt conclude theorem 42 approximation factor algorithm rounds optimal fractional solution 2 note technique rounding fractional solution decomposing convex combination integral solutions also used albers et al 2 411 strongly polynomial bounds diculty linear programming formulation rounding algorithm complexity algorithm depends n number time slots show choose n polynomial number jobs n expense losing bit approximation factor first note case release times deadlines processing times integral may assume without loss generality job scheduled integral point time addition restricted integers polynomial size number variables constraints bounded polynomial turn attention case arbitrary inputs let pn n 2 polynomial partition jobs j two classes big slack jobs j small slack jobs j obtain fractional solution separately big slack jobs small slack jobs rst explain obtain fractional solution big slack jobs big slack job j nd pn nonoverlapping job instances assign value 1pn interval note many nonoverlapping intervals found since r large enough claim assignment ignored computing solution via lp small slack jobs true point time sum fractions assigned intervals belonging big slack jobs npn thus eect fractional solution negligible worst case scale fractions corresponding small slack jobs factor 1 npn nevertheless big slack job contributes weight fractional objective function restrict attention set small slack jobs explain compute fractional solution solve lp bound number variables constraints lp partition time n pn slots instead variable job instance consider n 2 pn1 variables job j n pn jth variable represents job instances j start jth time slot similarly consider n pn jth constraint covers jth time slot small slack job j along time axis points r pn dening n pn dividers time slots determined adjacent dividers main observation small slack job j interval fully contained time slot ie two consecutive dividers lp formulation modied variables constraints slightly dierent original formulation see consider feasible schedule mentioned job instance cannot fully contained time slot however schedule considering may consist two instances jobs one terminates within time slot starts within keep constraints stipulate sum variables corresponding intervals intersect time slot bounded 1 would able represent schedule formulation overcome problem relax linear program allow every time slot sum fractions assigned intervals intersect 2 relaxed linear program following maximize subject time slot job 1 n x 1 0 x 1 easy see relaxation guarantees value objective function linear program least big value optimal schedule round optimal fractional solution way previous section since relaxed constraints note run group constrained interval coloring algorithm number mutually overlapping intervals twice number intervals group therefore generate color classes guarantee yielding approximation factor 3 conclude theorem 43 approximation factor strongly polynomial algorithm rounds fractional solution 3 412 unrelated machines section consider case k unrelated machines rst present linear programming formulation clarity give lp formulation polynomially bounded integral inputs however construction given achieves strongly polynomial algorithm arbitrary inputs applied well assume n time slots job j machine j dene variable x itj instance maximize subject time slot machine j job 1 n j 0 x itj 1 algorithm rounds fractional solution machine machine let rounded solution rounding machine rst discard fractional solution intervals belonging jobs chosen denote approximation factor achieved rounding single machine namely inputs arbitrary inputs theorem 44 approximation factor algorithm rounds kmachine solution proof let f 1 k denote fractional solution machine let wf denote value denote f 0 fractional solution machine discarding intervals belonging jobs chosen know 1 k c adding inequalities since sets mutually disjoint get c recall job sum values fractional solution assigned intervals belonging machines exceed 1 therefore yielding ws subsection apply theorem 33 case weighted jobs identical machines distinguish cases polynomially bounded integral input arbitrary input theorem 45 exists algorithm weighted jobs identical machines case achieves approximation factor polynomially bounded integral input arbitrary input proof shown linear program formulated value optimal solution least big value optimal schedule let n 0 chosen way discussion preceding theorem 42 claim using rounding scheme feasible solution denes interval graph colored k1n 0 1 colors integral polynomial size inputs 2k colors arbitrary inputs consider rst case integral polynomial size input interval graph induced solution lp n 0 intervals correspond job group kn 0 intervals mutually overlap point time applying group constrained interval coloring get valid coloring k similarly arbitrary inputs interval graph induced solution lp n 0 intervals correspond job group 2kn 0 intervals mutually overlap applying group constrained interval coloring get valid coloring implies polynomial size input arbitrary input words approximation factor achieved single machine compared optimal algorithm uses k identical machines setting values paradigm transforming algorithm single machine algorithm k identical machines yields claimed approximation factors 2 remark note k tends innity approximation factor e 158192 unweighted jobs weighted jobs integral polynomial size inputs arbitrary input approximation factor e 254149 setting get bounds coincide bounds single machine every k 2 cases bounds improve upon bounds unrelated machines 3 4 42 combinatorial algorithm section present combinatorial algorithm weighted machines model rst present algorithm singlemachine version show extend case k 1 machines even unrelated machines model 421 single machine algorithm inspired online call admission algorithms see 12 7 scan jobs instances intervals one one job instance either accept reject note rejection irrevocable decision acceptance temporary ie accepted job may still rejected later point time remark case nonpreemptive online call admission constant competitive factor cannot achieved algorithm reason due online nature problem jobs must considered order release time algorithm freedom order jobs dierent way yielding constant approximation factor outline algorithm feasible intervals jobs scanned left right time axis sorted end points algorithm maintains set currently accepted intervals new interval considered according sorted order immediately rejected belongs job already instance immediately accepted overlap interval case acceptance interval added overlaps one intervals accepted weight determined later times sum weights overlapping intervals case say preempts overlapping intervals add discard overlapping intervals process ends intervals scan formal description algorithm called algorithm admission given figure 2 main diculty implementing algorithm scanning innite number intervals proving performance algorithm show overcome diculty informally say interval caused rejection preemption another interval j algorithm admission 1 let set accepted job instances initially 2 let set yet unprocessed job instances initially set feasible job instances 3 empty repeat following procedure let 2 j job instance terminates earliest among instances let w weight let w sum weights instances h overlap n fig b j 6 reject c else fig else w w accept preempt g reject figure 2 algorithm admission either interval directly rejected preempted interval j preempted another interval caused rejection preemption interval j note relation dened recursively interval may preempt another interval preempted intervals turn rejected intervals case interval caused rejection preemption intervals fix interval accepted algorithm consider intervals chosen optimal solution rejection preemption caused interval prove total weight intervals f times weight accepted interval function f optimizing get 3 theorem 46 approximation factor algorithm admission 3 2 proof let set intervals chosen optimal algorithm opt let set intervals accepted algorithm admission denoted interval 2 dene set ri intervals accounted set consists case 2 intervals rejection preemption caused formally assume accepted rule 3c set ri initialized case 2 empty set otherwise assume accepted rule 3d ri initialized contain intervals directly preempted union sets ri 0 intervals 0 preempted addition ri contains case 2 assume j 2 rejected rule 3b let 2 interval caused rejection j note j belong job case add j ri assume j 2 rejected rule 3e let h intervals overlapped j time rejection let w weight j let w j weight j view j h imaginary intervals j weight j j w j w g note due rejection rule follows weight j j times weight j hard see interval portion use rule 3e belongs exactly one set ri 2 thus union sets ri 2 covers x interval 2 let w weight let w sum weights intervals ri dene w goal bound interval may directly reject one interval let w r weight portion interval r 2 ori directly rejected exists otherwise let w observe w r w since otherwise r would rejected let 0 2 interval belongs job one belongs maybe exists denition weight 0 w let w r sum weights rest intervals ri dene w follow assume inductively bound valid intervals earlier end point end point since overall weight jobs directly preempted w get w implies 1 therefore equation minimized implies 2 finally since bound holds intervals since union ri sets covers interval taken opt get value opt times value hence approximation factor 3 2 2 implementation observe step 3 algorithm invoked status change ie either new job becomes available n times job schedule ends n times time step 3 invoked total number jobs instances examined n one job implement algorithm employ priority queue holds intervals according endpoint point time enough hold one job instance job priority queue turns total number operations retrieving next instance log n totalling 2 log n operations 422 unrelated machines number unrelated machines k 1 call algorithm admission k times machine machine arbitrary order set jobs considered ith call contain jobs already scheduled machines analysis shows 3 5828 bound carries case unrelated machines similar analysis presented proof theorem 46 main dierence denition ri interval 2 executed machine dene set ri consist case 2 intervals executed machine optimal schedule ii rejection preemption jobs caused 5 maxsnp hardness show problem scheduling unweighted jobs unrelated machines maxsnp hard done reducing variant max2sat variable occurs three times problem variant max2sat given collection clauses consisting two boolean variables additional constraint variable occurs three times goal nd assignment values variables would maximize number clauses satised ie contain least one literal true value problem known maxsnp hard cf 26 given instance max2sat problem show construct instance problem unweighted jobs unrelated machines value max2sat problem equal value scheduling problem variable x associated machine clause c j associated job release time job 0 deadline 3 job executed two machines corresponding variables clause c j contains words processing time job rest machines innite suppose clause c j contains variable x positive negative literal processing time job corresponding c j 3k k 2 f1 2 3g number occurrences variable x positive negative literal note case variable x occurs positive negative forms occurs exactly one forms since variable x occurs three times overall follows feasible schedule machine cannot execute job corresponds positive literal occurrence job corresponds negative literal occurrence conclude jobs scheduled clauses satised direction hard verify clauses satised jobs scheduled since max2sat restriction variable occurs three times maxsnp hard unweighted jobs unrelated machines case maxsnp hard well acknowledgment indebted joel wein many helpful discussions especially suggestion consider general case maximizing throughput jobs release times deadlines r scheduling timeconstrained communication linear networks minimizing stall time single parallel disk systems scheduling jobs competitive bandwidth allocation preemption competitiveness online realtime task scheduling scheduling computer manufacturing systems location bank accounts optimize oat note scheduling intervals online two processor scheduling start times deadlines computers intractability guide theory np completeness patience virtue e maximizing value space mission solvable case one machine scheduling problem ready due dates optimal online scheduling algorithm overloaded realtime systems sequencing minimize weighted number tardy jobs dynamic programming algorithm preemptive scheduling single machine minimize number late jobs sequencing schedul ing algorithms complexity online interval scheduling algorithms scheduling independent tasks approximation maximum satis tr ctr cash j costello christopher p diehl amit banerjee hesky fisher scheduling active camera observe people proceedings acm 2nd international workshop video surveillance sensor networks october 1515 2004 new york ny usa lixin tang gongshu wang jiyin liu branchandprice algorithm solve molten iron allocation problem iron steel industry computers operations research v34 n10 p30013015 october 2007 thomas erlebach klaus jansen implementation approximation algorithms weighted unweighted edgedisjoint paths bidirected trees journal experimental algorithmics jea 7 p6 2002 randeep bhatia julia chuzhoy ari freund joseph seffi naor algorithmic aspects bandwidth trading acm transactions algorithms talg v3 n1 february 2007 thomas erlebach frits c r spieksma interval selection applications algorithms lower bounds journal algorithms v46 n1 p2753 january laura barbulescu jeanpaul watson l darrell whitley adele e howe scheduling spaceground communications air force satellite control network journal scheduling v7 n1 p734 januaryfebruary 2004 julia chuzhoy joseph seffi naor new hardness results congestion minimization machine scheduling proceedings thirtysixth annual acm symposium theory computing june 1316 2004 chicago il usa julia chuzhoy rafail ostrovsky yuval rabani approximation algorithms job interval selection problem related scheduling problems mathematics operations research v31 n4 p730738 november 2006 amotz barnoy reuven baryehuda ari freund joseph seffi naor baruch schieber unified approach approximating resource allocation scheduling journal acm jacm v48 n5 p10691090 september 2001 thomas erlebach klaus jansen conversion coloring algorithms maximum weight independent set algorithms discrete applied mathematics v148 n1 p107125 amotz barnoy sudipto guha yoav katz joseph seffi naor baruch schieber hadas shachnai throughput maximization realtime scheduling batching proceedings thirteenth annual acmsiam symposium discrete algorithms p742751 january 0608 2002 san francisco california julia chuzhoy joseph seffi naor new hardness results congestion minimization machine scheduling journal acm jacm v53 n5 p707721 september 2006 reuven baryehuda keren bendel ari freund dror rawitz local ratio unified framework approximation algorithms memoriam shimon even 19352004 acm computing surveys csur v36 n4 p422463 december 2004 faisal z qureshi demetri terzopoulos surveillance camera scheduling virtual vision approach proceedings third acm international workshop video surveillance sensor networks november 1111 2005 hilton singapore
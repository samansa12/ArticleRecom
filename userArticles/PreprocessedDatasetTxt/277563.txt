minimization communication cost caching mobile environments abstractusers mobile computers soon online access large number databases via wireless networks limited bandwidth wireless communication expensive wire communication paper present analyze various static dynamic data allocation methods objective optimize communication cost mobile computer stationary computer stores online database analysis performed two cost models one connection time based cellular telephones user charged per minute connection message based packet radio networks user charged per message analysis addresses average case worst case determining best allocation method b introduction users mobile computers palmtops notebook computers personal communication systems soon online access large number databases via wireless networks potential market activity estimated billions dollars annually access communication charges example road passengers access airline carriers schedules weather information investors access prices financial instruments salespeople access inventory data callers access location dependent data eg nearest taxicab see 10 24 routeplanning computers cars access traffic information limited bandwidth wireless communication expensive wire commu nication example cellular telephone call costs 035 cents per minute another example ram mobile data corp charges average 008 per data message mobile computer actual charge depends length message clear users perform hundreds accesses day wireless communication become ex pensive therefore important mobile computers access online databases way minimizes communication assume online database collection data items data item example webpage file users access data items unique id key one time minimize communication using appropriate dataallocation scheme example user frequently reads dataitem x x updated infrequently beneficial user allocate copy x herhis mobile computer words mobile user subscribes receive updates x way reads access local copy require communication infrequent updates transmitted online database mobile computer contrast user reads x infrequently compared update rate copy x allocated mobile computer instead access ondemand every read request sent stationary computer stores online database thus onecopy twocopies two possible allocation schemes data item x mobile computer first scheme stationary computer copy x whereas second scheme stationary mobile computer copy x allocation method determines whether allocation scheme changes time static allocation method allocation scheme change time whereas dynamic one following example dynamic allocation method allocation scheme changes twocopies onecopy result larger number writes reads window four minutes mobile computing geographical area usually divided cells stationary controller stationary computer confused stationary controller stationary computer node stationary network fixed given data item change mobile computer moves cell cell paper analyze two static allocation methods namely one uses onecopy scheme one uses twocopies scheme family dynamic data allocation methods methods suggested need select allocation scheme according readwrite ratio reads frequent methods use twocopies allocation scheme otherwise use onecopy scheme family consists methods allocate deallocate copy data item mobile computer based sliding window k requests every read update often refer updates writes latest k requests examined number reads higher number writes mobile computer copy copy allocated mobile computer number writes higher number reads mobile computer copy copy deallocated thus allocation scheme dynamically adjusted according relative frequencies reads writes algorithms family distributed implemented software residing mobile stationary computers different algorithms family differ size window k analysis static dynamic algorithms addresses worstcase expected case reads writes poissondistributed furthermore analysis done two cost models first connection time based user charged per minute cellular telephone connection model mobile computer reads item stationary database computer readrequest well response executed within one connection minimum length say one minute writes propagated mobile computer propagation also executed within one minimumlength connection second cost model message based model user charged per message exact charge depends length message therefore model distinguish datamessages longer controlmessages shorter data messages carry dataitem control messages carry control information specifically readrequests mobile computer stationary computer deleterequests deleterequest message deallocates copy mobile computer thus remote readrequest necessitates one control message response necessitates data message write propagated mobile computer necessitates datamessage rest paper organized follows next section present summary results paper section 3 formally present model section 4 precisely present slidingwindow family dynamic allocation algorithms section 5 develop results connection cost model section 6 develop results message model section 7 discuss dynamic allocation methods extensions handle read write operations multiple data items section 8 compare work relevant literature section 9 discuss conclusions analysis 2 summary results consider single data item x single mobile computer analyze static allocation methods st 1 mobile computer copy x st 2 mobile computer copy x dynamic allocation methods sw k slidingwindow windowsize k assume reads mobile computer issued according poisson distribution parameter r namely time unit expected number reads r writes stationary computer issued independently according poisson distribution parameter w requests ignored paper since cost affected allocation scheme let denote w rw analysis one algorithms uses three measures first called expected cost denoted exp gives expected cost readwrite request case known fixed second called average expected cost denoted av g important case unknown varies time equal probability value 0 1 gives average expected cost request possible values third measure worst case based notion competitiveness 1 see 9 18 23 29 32 online algorithm intuitively data allocation algorithm said ccompetitive sequence readwrite requests cost c times much minimum cost namely cost incurred ideal offline algorithm knows whole sequence requests advance contrast algorithms online sense service current request without knowing next request remainder section summarize results one two cost models discussed introduction results interpreted discussed intuitive level conclusion section 21 summary results connection model connection model results follows st 1 expected cost ie expected number connections per request expected number connections per request sw k expected cost per request ff k probability majority k consecutive requests reads formula probability equation 5 furthermore show fixed k sw k lower g thus 1 static allocation method st 1 best expected cost per request 1 static allocation method st 2 best expected cost per request next consider average expected cost sw k best average possible values expected cost per request cost 1 1 decreases k increases coming within 6 optimum contrast st 1 st 2 average expected cost 1for worst case show st 1 st 2 competitive ie ratio performance performance optimal perfectknowledge algorithm unbounded contrast show sw k 1competitive competitiveness factor tight summary worst case cost sw k family allocation algorithms increases k increases whereas average expected cost decreases k increases window size k chosen strike balance two conflicting requirements example k may provide reasonable compromise 1 traditional worst case complexity function size input inappropriate since algorithms discussed paper complexity measure example connection model algorithm sequence requests size algorithm incurs cost 22 summary results message passing model model results follows let cost data message 1 cost control message 0 1 st 1 expected cost per request 1 st 2 expected cost sw 1 expected cost derived expected cost function shown equation 15 section 63 2 formulae expected costs conclude following st 1 best expected cost 2delta st 2 best expected cost otherwise namely 2delta sw 1 algorithm best expected cost dominance graph three strategies shown following figure 1 indicates superior algorithm value figure 1 superiority coverage message model next consider average expected cost obtain following results st 1 average expected cost 1 st 2 average expected cost 1 sw 1 average expected cost 12delta average expected cost sw k k 6 1 given equation section 63 lower bound 2 conclude 04 sw 1 best average expected cost 04 average expected cost decreases window size k increases see corollary 2 section 63 worst case show connection cost model neither st 1 st 2 competitive similarly show slidingwindow algorithm sw 1 12 delta competitive sw k k 1 1 summary tradeoff average expected cost worst case similar connection model namely dynamic allocation algorithm superior static ones worst case improving decreasing window size whereas average expected cost decreases window size increases 2 sw 1 algorithm special case sw k algorithms pointed end section 4 3 model mobile computer system consists mobile computer mc stationary computer sc stores online database consider data item x stored stationary computer times reads writes issued mobile stationary computers actually reads writes stationary computer may originated computers origin irrelevant model furthermore ignore reads issued stationary computer writes issued mobile computer since cost request fixed zero one respectively regardless whether mc copy data item thus relevant requests writes issued stationary computer reads issued mobile computer schedule finite sequence relevant requests data item x example w w schedule request issued either mc copy data item purpose analysis assume relevant requests sequential practice may occur concurrently concurrency control mechanism serialize therefore analysis still holds assume messages stationary computer mobile computer delivered firstinfirstout order consider following two cost models first called connection model model algorithm static dynamic cost requests follows exist copy data item mc read request issued read costs one connection since data item must sent sc otherwise read costs zero write sc mc copy data item write costs one connection otherwise write costs zero total cost schedule denoted cost sum costs requests second model called message cost model model assume data message cost 1 control message cost since length control message higher length data message 0 1 model cost requests follows read request exists copy mc read require communication otherwise necessitates control message forwards request sc data message transfers data mc total cost 1 write request mc copy data item write costs otherwise write costs 1 1 depending algorithm result comparison reads writes executed mc response write request write propagated mc mc deallocate copy response cost 1 mc deallocates copy response cost accounts deallocate request finally explained next section sw 1 propagate writes mc simply deallocates copy mc write request cost write assume reads issued mc poisson distributed parameter r writes issued sc poisson distributed parameter w denote w wr observe since poisson distribution memoryless point time probability next request write wr probability next request read suppose data allocation algorithm r w read write distribution parameters respectively denote expa expected cost relevant request suppose varies time equal probability value 0 1 define average expected cost per request denoted av ga mean value expa ranging 0 1 namely z 1expa 1 average expected cost interpreted follows suppose time subdivided sufficiently large periods first period reads writes distributed parameters 1 r 1 w r second period reads writes distributed parameters 2 r 2 w etc suppose equal probability value 0 1 ie probability densisty function value 1 everywhere 0 1 0 everywhere else words random number 0 1 using algorithm expected cost relevant request periods time integral denoted av ga words av ga expected value expected cost one also argue av ga appropriate objective cost function unknown equal probability value 0 1 worstcase study take competitiveness measure performance online data allocation algorithm formally ccompetitive data allocation algorithm defined follows suppose perfect data allocation algorithm complete knowledge past future requests data allocation algorithm ccompetitive exist two numbers c 1 b 0 schedule call c competitiveness factor algorithm competitive algorithm bounds worstcase cost algorithm within constant factor minimum cost say algorithm tightly ccompetitive ccompetitive number dcompetitive 4 slidingwindow algorithms slidingwindowk algorithm allocates deallocates copy data item x mobile computer examining window latest relevant read write requests window size k ease analysis assume k odd recall reads issued mobile computer writes issued stationary computer observe point time whether mobile computer copy x either mobile computer stationary computer aware relevant requests mobile computer copy x reads issued mobile computer satisfied locally writes issued stationary computer propagated mobile computer thus mobile computer receives relevant requests else ie mobile computer copy reads issued mobile computer sent stationary computer thus stationary computer receives relevant requests thus either mobile computer stationary computer charge maintaining window k requests window tracked sequence k bits eg 0 represents read 1 represents write receipt relevant request computer charge drops last bit sequence adds bit representing current operation compares number reads number writes window number reads bigger number writes copy x mobile computer sw k algorithm simply waits next operation number reads bigger number writes copy mobile computer ie stationary computer charge copy allocated follows observe last request must read stationary computer responds read request sending copy x mobile computer sw k algorithm piggybacks message 1 indication save copy mcs local database sc also commits propagate writes mc 2 current window requests point onwards mc charge number writes bigger number reads copy x mc sw k algorithm waits next request number writes bigger number reads copy x mc ie mc charge copy deallocated follows sw k algorithm sends sc 1 indication sc propagate writes mc 2 current window requests point onwards sc charge concludes description algorithm point make two remarks first window size 1 mc copy x write sc deallocate copy since window consist write therefore instead sending mc copy x sc simply sends deleterequest deallocates copy mc thus sw 1 denotes algorithm optimized observe sw 1 classic writeinvalidate protocol 5 connection cost model section analyze algorithms connection cost model section divided 3 subsections first subsection probabilistically study static data allocation algorithms second study family sliding window algorithms subsections derive expected cost first average expected cost compare algorithms based measures finally section 53 analyze worst case performance algorithms 51 probabilistic analysis static algorithms st 1 algorithm write request costs 0 read request cost 1 connection algorithm every write costs 1 every read costs 0 hence exp st 1 exp st 2 simply equal probabilities request read write respectively thus concerning average expected cost equation 1 equation 2 obtain av g st 2 52 probabilistic analysis sw k algorithms section derive expected cost sw k algorithms show k sw k algorithm higher expected cost one static algorithms derive average expected cost sw k algorithms show k sw k algorithm lower average expected cost static algorithms also show average expected cost sw k algorithms decreases k increases recall assuming size window k 2 odd number point time probability exists copy mc denote probability majority among preceding k requests reads probability number writes preceding k requests less equal n namely theorem 1 every k every expected cost sw k algorithm proof let us consider single request q copy mc expected cost q equal probability q write operation equals copy mc expected cost q expected cost q probability copy mc times expected cost q copy mc plus probability copy mc times expected cost q copy mc thus conclude theorem 2 next theorem compares expected costs sw k static algorithms theorem 2 every k every exp sw k g proof equations 2 5 follows exp sw k theorem follows due fact weighted average two values smaller minimum two values 2 let us consider average expected costs theorem 3 slidingwindow algorithm window size k sw k average expected cost per request z 1exp sw k derivation equation 6 uses following identity positive integers b z 1x using equation 5 straightforward show using equation 4 identity given equation 7 algebraic simplifications shown z 1ff k delta z 1ff k substituting equation 8 simplification get result given equation 6 2 corollary 1 average expected cost sw k algorithms decreases window size k increases av g sw k k 1 proof theorem 3 easy see av g sw k decreases k increases 1 1 equations 3 section 51 conclude corollary53 worst case analysis connection model section show static algorithms st 1 st 2 competitive show sw k algorithm k 1competitive therefore competitiveness study suggests optimizing worst case one choose sliding window algorithm small window size k first lets consider two static strategies st 1 algorithm pick long schedule consists reads cost st 1 algorithm unboundedly higher cost optimal algorithm schedule 0 keep copy mc st 2 algorithm also pick long schedule consists writes cost st 2 algorithm schedule also unboundedly higher optimal cost 0 keep copy mc therefore static algorithms st 1 competitive theorem 4 slidingwindow algorithm sw k tightly prove showing schedule requests cost sw k number read requests occur immediately write request also exhibit schedule 0 cost sw k since shown cost optimal offline algorithm schedule n follows sw k tightly 1competitive assume throughout proof first prove cost sw k 1 let schedule consisting read write requests let n number read requests occur immediately write request divide schedule maximal blocks consisting similar requests formally let r division blocks requests block reads writes successive blocks different requests easy see total number read blocks ie blocks contain read requests less equal n 1 similarly total number write blocks less equal n 1 analyze cost read write requests separately consider read block b easy see first n1 reads may incur connection first n reads window definitely reads writes algorithm maintain two copies consequently reads block cost connections thus cost executing reads b bounded n 1 hence cost reads bounded n 1 similar argument shown cost writes write block bounded n 1 consequence cost writes bounded n 1 delta n rearranging terms get cost sw k show bound tight assume initially single copy data item consider schedule 0 starts block read requests ends block write requests block exactly k requests easy see 6 message cost model section divided 4 subsections first subsection probabilistically analyze static algorithms second analyze sw 1 third analyze family sliding window algorithms sw k k 1 3 one first three subsections study algorithms expected cost first average expected cost also study relation among expected costs static dynamic algorithms relation among average expected costs subsection 64 study worst case algorithms recall model assume data message cost 1 control message cost ranges 0 1 61 probabilistic analysis static algorithms st 1 algorithm write require communication whereas read costs st 2 algorithm every write costs 1 read costs 0 3 mentioned end section 4 sw 1 simply sw k 1 cost model difference algorithms results different analysis thus need separate subsection dedicated analysis sw 1 62 probabilistic analysis sw 1 algorithm first derive expected cost relevant request theorem 5 expected cost sw 1 algorithm proof sw 1 algorithm read immediately follows write costs control message conveys read request 1 data message write immediately follows read costs cost control message deallocating copy mc relevant requests cost communication therefore expected cost request q expected cost read immediately follows write times probability q read plus expected cost write immediately follows read times probability q write namely exp sw 1 next theorem study relation expected costs three algorithms ie exp sw 1 results theorem graphically illustrated figure 1 theorem 6 expected costs exp sw 1 exp st 2 related follows depending exp st 1 exp sw 1 exp st 2 proof straightforward algebraic derivation uses equations 11 13 fact ready consider average expected cost theorem 7 average expected cost sw 1 algorithm av g sw 1 proof equation 14 easily obtained equation 13 based definition average expected cost equation 1 since 0 1 obtain 12delta 1 1 equations 12 section 61 conclude theorem 2 63 probabilistic analysis sw k section consider sw k algorithms first derive formula expected cost sw k show k expected cost sw k higher minimum expected costs sw 1 st 1 st 2 thus conclude known fixed sw k inferior algorithms derive formula average expected cost sw k show sw k best average expected cost k 1 determine optimal k function cost control message theorem 8 every k 1 expected cost sw k algorithm consider write request w costs data message exists copy mc request issued probability copy mc ff k additionally mc deallocates copy result write write necessitate delete message sent mc sc argued omit details occurs sequence k requests immediately preceding w starts read exactly writes therefore expected cost w consider read request r require communication copy mc request issued otherwise costs control message request data message response thus expected cost r therefore expected cost request expected cost write times probability request write plus expected cost read times probability request read namely exp sw k simple algebraic manipulation expression leads equation 15 2 theorem 9 k 1 expected cost algorithm sw k higher expected cost least one algorithms sw 1 st 1 st 2 namely exp sw k g order prove theorem need following three lemmas lemma 1 k 1 05 exp sw k proof equations 11 15 derive decreases k increases definition ff k see equation 4 derive omitted formula see ff k2 gamma ff k negative k 1 hence ff k decreases k consequence ff k 1 2 lemma 3 k 1 05 exp sw k exp sw k proof exp sw k equations 11 15 ff k namely base inequality easy show exp sw k thus proved first claim lemma namely exp sw k based inequality lemma 2 easy show exp sw k proof theorem 9 05 lemma 1 indicates exp sw k g theorem follows 2 lets consider average expected cost sw k algorithms k 1 theorem 10 sw k algorithm window size k 1 average expected cost z 1exp sw k definition ff k section 52 equation 7 equation 15 derive equation 16 tedious intermediate derivation steps omitted 2 corollary 2 k 1 av g sw k decreases k increases av g sw k corollary straight forward equation 16 2 theorem 7 shown average expected cost sw 1 algorithm better ie lower static algorithm following corollaries analyze average expected cost sw k k 1 lower average expected cost sw 1 based two formulae 14 16 corollary 3 show 04 average expected cost sw k always higher sw 1 corollary 3 04 av g sw k k 1 thus theorem 7 corollary 2 conclude corollary 2 next corollary study case 04 show given 04 k 0 k k 0 average expected cost sw k lower sw 1 following figure illustrates results corollaries 3 4 example k 39 sw k algorithm lower expected cost k 7 sw k algorithm lower expected cost sw 1 corollary 4 04 av g sw k k satisfies manipulation using equations 14 16 2 64 worst case message model section study competitiveness algorithms st 1 st 2 sw k k 1 message cost model result sw 1 stated separately since special case see section 4 conclude static algorithms competitive case connection model show sw 1 competitive sw k k 1 show competitiveness factor sw k algorithms deteriorates k increases thus performs best worst case connection model easily derive static algorithms competitive message model theorem 11 algorithm sw 1 tightly competitive message cost model 1 ratio control message cost data message cost similarly proof theorem 4 let n number reads occur immediately write arbitrary schedule requests easy see n minimum cost satisfy requests let r division blocks requests block reads writes successive blocks different requests easy see total number read blocks less equal n 1 read block costs 1 since first read mobile computer keep copy data item total cost reads bounded n similarly total number write blocks less equal n 1 write block costs since first write block invalidate copy mc thus total cost writes bounded n show bound tight assume initially single copy data item consider schedule 0 starts read request ends write request block exactly 1 request easy see cost sw k theorem 12 algorithm sw k k 1 tightly 1 competitive message cost model 1 ratio control message cost data message cost similarly proofs theorems 4 11 prove schedule requests cost sw k number read requests occur immediately write request also exhibit schedule 0 cost sw k constant since shown cost optimal offline algorithm n follows sw k tightly 1 competitive assume throughout proof let schedule consisting read write requests prove cost sw k divide schedule maximal blocks consisting similar requests formally let r division blocks requests block reads writes successive blocks different requests easy see total number read blocks ie blocks contain read requests less equal n 1 similarly total number write blocks less equal n 1 analyze cost read write requests separately consider read block b easy see first may cost 1 first n reads window definitely reads writes algorithm maintain two copies reads block cost communication thus cost executing reads b bounded n hence cost reads bounded 1 consider easy see b j cost n data message since first n window definitely writes reads copy mc deallocated deallocation may cost block additional control message thus cost write block bounded n1 consequence cost writes bounded n1 delta n hence cost sw k rearranging terms get cost sw k show bound tight assume initially single copy data item consider schedule 0 starts block read requests ends block write requests block exactly k requests easy see extensions section discuss various extensions previous methods particular first subsection show modify static algorithms make competitive second subsection discuss extensions algorithm optimize case multiple data items read written single operation 71 modifications static methods presented two simple static methods use onecopy twocopies schemes static methods chosen value known advance example connection model static method using single copy stationary computer best expected cost 05 similarly static method using twocopy scheme best expected cost 05 however static methods good worst case behavior ie competitive example static method using single copy incur high cost sequence requests consisting reads mobile computer cost arbitrarily large depending length sequence even though sequence highly improbable occur nonzero probability overcome problem simple modifications static methods actually make dynamic example modify onecopy static method follows normally use onecopy scheme consecutive reads occur changes twocopies scheme uses scheme next write reverts back onecopy scheme repeats process refer algorithm t1m shown t1m 1competitive expected cost connection model note second term additional expected cost static method shown 05 t1m lower expected cost swm equally competitive price competitiveness thus know 05 choose t1m algorithm instead st 1 appropriate value similarly modify st 2 algorithm obtain t2m algorithm almost expected cost st 2 72 multiple data items paper addressed problem choosing allocation method single data items results extended case multiple data items read written single operation sketch algorithm gives optimal static allocation method connection model multiple data items frequencies operations data items known advance assume multiple data items remotely read one connection similarly remote writes present algorithm case two data items x generalized two data items also discuss approach extended dynamic window based algorithms assume two data items x classify read operations three classes reads x reads reads access x assume three different reads occur according independent poisson distributions frequencies respectively classify writes similarly assume writes occur frequencies wx wy w respectively noted denote frequencies joint reads writes respectively four possible allocation methods x st 1 x one copy st 2 x two copies st 12 one copy one copy st 21 x two copies one allocation methods obtain expected cost single operation using frequencies choose one lowest expected cost example expected cost st 1 rx st 12 rx sum read write frequencies method generalized finite set data items need frequencies various joint operations data items use method given need know frequencies various operations advance frequencies known advance use window based approach dynamically calculates frequencies case need keep track number operations different kind ie jointexclusive readwrite operations multiple data items window numbers calculate frequencies operations compute expected costs similar static methods given previous using frequencies choose appropriate future allocation method avoid excessive overhead recomputation done periodically instead operation future work address performance analysis method 8 comparison relevant literature far know first paper study communication cost static dynamic allocation distributed systems using average case worst case analysis two bodies relevant work discussed one following two subsections first subsection compare paper database literature data allocation distributed systems second subsection compare paper literature caching distributed virtual memory 81 data allocation distributed systems data allocation distributed systems either static dynamic 35 36 considered dynamic data allocation algorithms analyzed using notion convergence different measures used paper namely expected case worst case additionally algorithms works different ones discussed 35 36 consider static allocation algorithms consider connection cost model dynamic data allocation algorithms introduced 22 23 works analyze dynamic data allocation worst case actually sw 1 algorithm first analyzed 23 however model requires minimum two copies system availability purposes thus even worst case results different contrast paper assume availability constraints handled exclusively within stationary system independently mobile computers also work addressing dynamic data allocation algorithms 9 work also addresses worst case additionally model allow concurrent requests requires centralized decision making processor aware requests network contrast algorithms distributed allow concurrent readwrite requests static allocation studied 37 14 works address following fileallocation problem assume readwrite pattern processor known priori estimated find optimal static allocation scheme however works fileallocation problem compare static dynamic allocation quantify cost penalty readwrite pattern deviates estimate many works data replication problem 4 6 11 13 17 21 34 file systems coda 30 33 address solely availability aspect namely ensure availability data item presence failures contrast paper addressed communication cost issue works done alonso ganguly 5 20 also related present paper sense also address optimization issue mobile computers however optimization objective energy whereas communication work broadcast disks 2 also addresses peformance issues related pushpull data mobile computing environment however work assumes readonly data items perform type analytical performance evaluation present paper 82 caching virtual memory computer architecture operating systems literature studies two subjects related dynamic data allocation namely caching distributed virtual memory see 1 3 7 however several important differences caching distributed virtual memory cdvm one hand replicated data distributed systems fore results obtained previously first many cdvm methods focus communication cost alone consider collection factors determine performance complexity resulting problem dictates analysis either experimental uses simulation contrast paper assumed since mobile computing wireless communication involves immediate outofpocket expense optimization wireless communication sole caching objective performed thorough analytical cost evaluation second cdvm size cache assumed limited thus important issues cdvm literature cache utilization page replacement strategy eg lru mru etc namely page replace cache cache full new page brought words contrast replicated data distributed systems may reside secondary even tertiary storage cdvm page may deleted cache results limited storage one may argue whether limited storage major issue distributed databases however paper assumed storage mobile computer abundant cdvm methods consider communication cost one optimization criteria eg treadmarks 26 however use dynamic allocation schemes 9 conclusions paper considered several data allocation algorithms mobile computers particular considered onecopy twocopies allocation schemes investigated static dynamic allocation methods using schemes static method allocation scheme remains unchanged throughout execution dynamic method allocation scheme changes dynamically based window consisting last k requests window reads mobile computer writes stationary computer use twocopy scheme otherwise use onecopy scheme get different dynamic methods different values k dynamic method simply classic writeinvalidate protocol considered two cost models connection model message model connection model cost measured terms number wireless telephone connec tions message model cost measured terms number control data messages considered three different measures expected cost average expected cost worst case cost uses notion competitiveness roughly speaking algorithm said kcompetitive every sequence readwrite requests cost sequence k times cost ideal offline algorithm knows advance algorithm said competitive k 0 kcompetitive expected cost standard expected cost per request assuming fixed probabilistic distributions reads writes believe allocation method chosen based expected cost well worst case cost specifically think allocation method chosen minimize expected cost provided bound worst case behavior explain difference expected cost average expected cost assumed reads mobile computer writes stationary computer occur according independent poisson distributions frequencies r w respectively values r w known specifically value rw known allocation method chosen based expected cost competitiveness however varies equally likely value 0 1 allocation method chosen based average expected cost addition competitiveness average expected cost integral expected cost 0 1 allocation method lower average expected cost lower average cost per request sequence requests frequencies reads writes vary time furthermore average expected cost also provide insight andor measure selecting allocation method case unknown equally likely value 0 1 4 connection model greater 05 ie read frequency lower write frequency static allocation method using one copy stationary computer 4 uniformly distributed average expected cost defined integral expected cost multiplied density function best expected cost similarly smaller 05 static allocation method using one copy stationary computer one mobile computer best expected cost r w change time ie changes time one dynamic methods sw k appropriate value k chosen due fact average expected cost sw k algorithms lower either one static methods value window size k chosen strike balance average expected cost decreases k increases see equation 6 competitiveness sw k algorithm 1competitive thus competitiveness becomes worse k increases example 9 slidingwindow algorithm average expected cost within 10 optimum worst case 10 times worse optimum offline algorithm message model static allocation methods still competitive dynamic allocation methods sw k competitive although different competitiveness factor given expected cost one three methods st 1 st 2 sw 1 lowest particular one depends values ratio control message cost data message cost lowest expectedcost algorithm function given figure 1 unknown varies time one sliding window methods provides optimal average expected cost particular one depends value 04 sw 1 algorithm chosen least average expected cost values higher value k lower average expected cost sw k algorithm see figure 2 appropriate value k chosen strike balance average expected cost competitiveness data allocation methods results paper pertain applications data items accessed various mobile computers mostly disjoint read requests must satisfied mostuptodate version data item applications satisfy assumptions techniques use data broadcasting batching updates may appropriate results need extended subject future work acknowledgement wish thank referees insightful comments r evaluation cache coherence solutions sharedbus multiprocessors balancing push pull data broadcast evaluation directory schemes cache coherence multidimensional voting query optimization energy efficiency mobile enviro ments tree quorum protocol efficient approach managing replicated data adaptive software cache management distributed shared memory architectures shared memory based typespecific memory coherence competitive algorithms distributed data management replication mobility grid protocol high performance scheme maintaining replicated data data caching tradeoffs clientserver bdms architectures distributed concurrency control performance study algorithms distribution replication characterization sharing parallel programs application coherency protocol evaluation evaluating performance four snooping cache coherency protocols achieving robustness distributed database systems competitive paging algorithms client data caching foundation high performance object database systems query optimization mobile enviroments weighted voting replicated data competitive dynamic data replication algorithm dynamic allocation distributed system mobile com puters querying highly mobile distributed environments shared virtual memory loosely coupled multiprocessors treadmarks distributed shared memory standard workstations operating systems memory coherence shared virtual memory systems synchronization multiprocessor caches competitive snoopy caching disconnected operation coda file system disk cache performance distributed systems competitive algorithms online problems coda highly available file system distributed workstation environment majority consensus approach concurrency control multiple copy database distributed algorithms dynamic replication data algorithm dynamic data distribution multicast policy relationship replicated data placement cache consistency concurrency control clientserver dbms architecture tr ctr sandeep k gupta pradip k srimani data management wireless mobile environments handbook wireless networks mobile computing john wiley sons inc new york ny 2002 wang ingray chen chihping chu iling yen replicated object management periodic maintenance mobile wireless systems wireless personal communications international journal v28 n1 p1733 january 2004 ycel saygin zgr ulusoy exploiting data mining techniques broadcasting data mobile computing environments ieee transactions knowledge data engineering v14 n6 p13871399 november 2002 james jayaputera david taniar data retrieval locationdependent queries multicell wireless environment mobile information systems v1 n2 p91108 april 2005 isabel cruz ashfaq khokhar bing liu prasad sistla ouri wolfson clement yu research activities database management information retrieval university illinois chicago acm sigmod record v31 n3 september 2002 w j lin b veeravalli dynamic object allocation replication algorithm distributed systems centralized control international journal computers applications v28 n1 p2634 january 2006 bharadwaj veeravalli network caching strategies shared data distribution predefined service demand sequence ieee transactions knowledge data engineering v15 n6 p14871497 november bharadwaj veeravalli network caching strategies shared data distribution predefined service demand sequence ieee transactions knowledge data engineering v15 n6 p14871497 november anurag kahol sumit khurana sandeep ks gupta pradip k srimani strategy manage cache consistency disconnected distributed environment ieee transactions parallel distributed systems v12 n7 p686700 july 2001 xiaohui lin yukwong kwok vincent k n lau quantitative comparison ad hoc routing protocols without channel adaptation ieee transactions mobile computing v4 n2 p111128 march 2005 sandeep k gupta goran konjevod georgios varsamopoulos theoretical study optimization techniques used registration area based location management models online algorithms proceedings 6th international workshop discrete algorithms methods mobile computing communications september 2828 2002 atlanta georgia usa
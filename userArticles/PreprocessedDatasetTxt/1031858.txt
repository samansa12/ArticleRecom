ioefficient dynamic planar point location present ioefficient dynamic data structure point location general planar subdivision structure uses oinbi disk blocks size ibi store subdivision size ini queries answered ologinfibiinfsup2supini ios worstcase insertions deletions performed ologinfibiinfsup2supini ologinfibiinfini ios amortized respectively part data structure based external version socalled logarithmic method allows efficient dynamization static externalmemory data structures certain characteristics another important part structure external data structure vertical rayshooting among line segments plane endpoints ibi lines developed using external version dynamic fractional cascading believe methods could prove helpful development dynamic external memory data structures b introduction planar point location dened follows given planar subdivision n vertices ie decomposition plane polygonal regions induced straightline planar graph preprocess data structure arbitrary query point p face containing p reported quickly problem arises several applications including graphics spatial databases geographic information systems planar subdivisions arising many applications massive internal memory must reside disk instances io communication bottleneck instead cpu running time work date especially allow edges vertices changed dynamically focused minimizing cpu running time assumption subdivision ts main extended abstract version paper presented sixteenth annual acm symposium computational geometry socg00 supported part national science foundation ess grant eia9870734 ri grant eia9972879 career grant ccr9984099 email largecsdukeedu z part work done visiting duke university email janmathunimuensterde memory 7 11 12 17 20 24 results known ioecient point location subdivision stored external memory 1 5 14 18 27 paper develop rst space ioecient dynamic data structure planar point location general subdivisions previously structure known case monotone 1 subdivision 1 11 previous results internal memory edelsbrunner et al 16 proposed optimal data structure point location monotone subdivisions space preprocessing time olog 2 n query time arbitrary planar subdivisions either preprocessing time space requirement increases log 2 n see eg 20 24 allow edges vertices changed dynamically two linearspace structures known general subdivisions one cheng janardan 11 answers queries olog 2 supports updates olog 2 n time baumgarten et al 7 supports queries olog 2 n log 2 log 2 n time worstcase insertions olog 2 n log 2 log 2 n time amortized deletions olog 2 structures store edges subdivision interval tree 15 constructed xprojection rst suggested 17 use structure answer vertical rayshooting queries query point p nd rst edge hit ray emanating p ydirection answering vertical rayshooting query face containing p found olog 2 n time 23 summary known results found recent survey 25 paper interested problem dynamically maintaining planar subdivision disk number io operations ios used perform query update minimized consider problem standard twolevel io model proposed aggarwal vitter 2 model n denotes number elements problem instance number elements tting internal memory b number elements per disk block n 2 b 2 io operation reading writing disk block external memory computations done elements present internal memory measures performance number ios used solve problem amount space disk blocks used aggarwal vitter 2 considered sorting related problems io model proved sorting requires nb log mb nb ios note assumption b onb log b n searching set n ordered elements requires log b n ios io ecient algorithms data structures developed numerous problemssee recent surveys sample results 3 28 previous results point location external memory either static batched dynamic goodrich et al 18 designed static data structure using onb space store monotone subdivision query answered optimal olog b n ios also developed structure answering batch k pointlocation queries optimal kb log mb n ios arge et al 5 extended batched result general subdivisions see also 14 arge et al 4 oline dynamic setting sequence queries updates given advance queries answered sequence operations performed vahrenhold hinrichs 27 considered problem practical assumptions input data known dynamic structure recently proposed agarwal et al 1 restricted monotone subdivisions linearspace onb 1 polygon called monotone direction line direction 2 intersects polygon connected interval planar subdivision monotone faces monotone xed direction sometimes assumed b m2 simplicity make realistic assumption main memory capable holding b 2 elements techniques developed paper works without assumption disk blocks structure supports queries olog 2 ios worst case updates performed olog 2 12 results paper present rst provably ioecient dynamic data structure point location general planar subdivision structure uses optimal onb disk blocks store queries answered olog 2 ios worstcase insertions deletions performed olog 2 part data structure based new external version socalled logarithmic method 9 allows ecient dynamization static externalmemory data structures certain characteristics precisely assume static externalmemory data structure external orderdecomposable 4 problem p constructed onb log b n ios queries answered olog kq ios deletions performed olog k method used construct linearspace dynamic data structure 0 p answers queries olog kq 1 ios supports insertions deletions olog 2 another important part structure data structure vertical rayshooting among line segments plane endpoints lines developed using new external version dynamic fractional cascading 10 21 direct use fractional cascading line segment data structures complicated fact segments comparable according abovebelow relation ie one total order exist set segments plane believe ideas used data structure independent interest prove helpful development external memory line segment data structures remainder paper organized follows section 2 review static version structure agarwal et al 1 works general subdivisions also discuss structure modied support deletions made semidynamic section 3 discuss general dynamization technique show used obtain dynamic point location structure supporting queries olog 3 ios section 4 show improve bound olog 2 using external version dynamic fractional cascading following concentrate answering vertical rayshooting queries among edges planar subdivision internal memory face containing query point p easily found olog b n ios rayshooting query answered simplify presentation assume wlog vertices distinct xcoordinates make frequent use btrees 19 btrees objects stored leaves level internal nodes except possibly root b children paper b 2 b c constant 0 c 1 node stored o1 blocks tree height olog b c normal btree 8 13 structure case call structure btree unless 3 general 2b b 2 insertion bound olog b n log mb nb general structure constructed onb log mb nb ios assuming 2b made dynamic insertion deletion bounds olog b n log mb nb olog specically stated otherwise assume leaf contains b objects tree uses onb disk blocks total since tree height olog b n search performed olog b n ios insertion deletions also performed olog b n ios using olog b n split fuse operations nodes rootleaf path 19 basic idea static version structure agarwal et al 1 similar one used several main memory structures 7 11 17 set edgessegments stored twolevel tree structure rst level interval treehere external interval tree 6on xprojection base interval tree btree xcoordinates endpoint segments segments stored secondary structures associated nodes node v associated vertical slab v root associated whole plane interior node v v partitioned vertical slabs separated vertical lines called slab boundaries dashed lines figure 1 slab contains number vertices slab associated ith child v segment stored highest node v intersects slab boundary associated v let v set segments stored v leaf z stores segments whose endpoints lie interior slab z number segments stored leaf ob hence occupy o1 blocks let v internal node let segment v suppose left endpoint lies slab l right endpoint lies slab r associated v call subsegment l left subsegment r right subsegment portion lying called middle subsegmentsee also figure 1 let r denote set middle subsegments segments v 1 b let l denote set left resp right subsegments lie store following secondary structures v multislab structure set middle segments r ii 1 b following structures left structure segments l right structure segments r segment v thus stored three secondary structures multislab structure left structure right structure example segment figure 1 stored multislab structure left structure 1 1 right structure 4 4 secondary structures constructed use linear space node v requires ojs v jb disk blocks turn means overall data structure requires onb disk blocks r figure 1 node base tree left subsegment slab 1 right subsegment slab 4 middle subsegment spans 2 3 b answering query ray emanating point p ydirection nd rst segment hit search along path length olog b n root leaf z z contains p internal node v visited query procedure compute rst segment v hit particular rst search nd rst segment r hit next nd vertical slab contains p search nd rst segments l r respectively hit refer figure 1 b rst segment z hit computed testing segments z explicitly query answered choosing lowest segment among olog b n segments found way based ideas due cheng jarnadan 11 agarwal et al 1 showed left right structures implemented eciently lemma 1 agarwal et al 1 set k disjoint segments whose right left endpoints lie single vertical line stored data structure using okb blocks vertical rayshooting query answered olog b k ios updates performed olog b k ios structure constructed okb log b k ios agarwal et al 1 also showed multislab structure implemented queries answered olog b n ios left right structures support general updates agarwal et al 1 managed make multislab structure dynamic monotone subdivisions discuss structure show easily modied support deletions general subdivisions set k disjoint segments endpoints vertical lines stored data structure using okb blocks vertical rayshooting query answered olog b k ios deletion performed olog b k ios structure constructed okb log b k ios lemma 1 2 implies structure agarwal et al 1 answer query ios structure constructed onb log b n ios first base tree constructed sorting endpoints segments using onb log mb onb log b n ios building tree bottomup using additional onb ios next segments sorted left xcoordinate distributed internal nodes onb log b n ios visiting nodes levelbylevel scanning sorted list level finally secondary structures nodes constructed onb log b n ios total lemma 1 2 using onb log b n io construction algorithm deletions also supported delete segment search nd node v stored since multislab structure left right structures support deletions olog b n ios lemma 1 2 delete olog b n ios finally use global rebuilding 22 maintain olog b n height base tree delete endpoints leaves rebalance since space query performance remain asymptotically long deletes performed need rebalance immediately instead simply rebuild structure n2 updates using onb log b n ios olog b nb ios amortized per delete thus following theorem 1 set n disjoint segments stored data structure using onb disk blocks vertical rayshooting query answered olog 2 ios deletes performed olog b n ios amortized structure constructed ios describe multislab structure designed 1 detail prove lemma 2 order need dene partial order nonintersecting segments denition 1 segment plane segment plane exists vertical line l intersecting intersection l intersection l note two segments incomparable cannot intersected vertical line segment sorting problem problem extending partial order total order lemma 3 arge et al 5 set n disjoint segments sorted according partial order onb log mb ios consider set r k disjoint segments whose endpoints lie vertical lines b b1 b let vertical slab bounded b b i1 r hence also subset r 0 r crossing sorted according easily answer rayshooting query olog b n ios using btree r 0 however cannot aord build btree segments crossing slab since could result segment stored times therefore segments stored single multislab structure follows first btree constructed sorted sequence segments r node v 2 let r v denote subsequence r stored subtree rooted v guide processing queries certain segments r v stored internal node v specically let w b denote children internal node v 1 b dene ij maximal segment rw according intersects vertical slab j segment rw intersects j ij undened less stored v o1 blocks note segment stored one rootleaf path btree requires okb disk blocks constructed bottomup okb ios assuming r v sorted according ordering nd rst segment hit query ray follow path root leaf z r z contains rst segment hit node v visited procedure following p lies interior slab r let bg denition ij ensures lr rst lowest segment e v hit contains rst segment r hit therefore visit w l next total query answered olog b n ios one way thinking btree b slabs stored structure answering query slab r sets e v nodes v denes btree segments intersecting r main problem making dynamic insertion new segment may change total order segments r considerably 1 special features monotone subdivisions 26 used limit changes deletion segment hand change sorted sequence segments r still sorted sequence deleting makes easy perform deletions eciently delete stored leaf z rst nd crossed maximal segment j z delete z traverse path z root exchanging relevant segment j rst node encountered ij dened requires olog b n ios deletions may result leaves storing ob segments space query performance remain asymptotically long deletes performed n2 deletes simply rebuild structure using onb log b n ios olog b nb ios amortized per delete proves lemma 2 3 dynamization using logarithmic method section discuss general method transforming static externalmemory data structure certain characteristics ecient dynamic structure method external version logarithmic method 9 see also 22 also discuss method used make semidynamic point location structure described previous section fully dynamic logarithmic method works broad class socalled decomposable searching problems rst dened bentley 9 previously considered external setting arge et al 4 denition 2 arge et al 4 let p searching problem let px v denote answer p respect set objects v query x p called externaldecomposable partition ab v query x px v computed o1 additional ios given px appropriate form vertical ray shooting problem externaldecomposable fact already used section 2 solved problem solving olog b n disjoint segment subsets returning appropriate segment bentley 9 described general method making static data structures decomposable problems dynamic main idea partition set objects v log 2 n subsets v exponentially increasing size 2 build static structure subsets queries performed querying combining answers insertions performed nding rst empty discarding structures j j building new object objects v j j make logarithmic method ioecient need decrease number subsets log b n turn means increasing size v b however contain enough objects build turns build static structure ioeciently enough resolve problem make modied version method work external memory consider static structure externaldecomposable problem p constructed set v n objects onb log mb n ios answers queries olog kq ios also assume supports deletions olog k ios partition v log b n sets v jv construct external memory static data structure v refer figure 2 answer query simply query combine results using log kq ios insertion handled nding rst structure discarding structures j j building new objects structures using ios way chosen know means least b 1 objects moved lower indexed structures j divide construction cost object themv b bv 2 figure 2 logarithmic method structure contains jv objects note 1 contain enough objects build j1 size b j1 pay olog mb nb ios since object never moves higher lower indexed structure charge olog b n times n insertions thus amortized cost insertion olog b n log mb nb ios note key making method work factor b lost charging construction structure size b objects oset b factor win construction bound order support deletions eciently maintain separate btree c objects v object c store information structure contains object note adds extra olog 2 ios insertion bound since need update entries c ob objects moves j j insertion delete given object rst use c determine structure storing object olog b n ios found perform deletion olog k ios finally order guarantee number structures remains olog b n also perform global rebuilding 22 structure half objects deleted collect objects discard data structures build new log b n structure using onb log mb nb ios adds o1b log mb ios amortized deletion cost theorem 2 let p externaldecomposable problem set v size n let linearspace static structure p constructed onb log mb nb ios queries answered olog kq ios deletes performed olog k ios exists linearspace dynamic data structure 0 p answers queries olog kq 1 ios supports insertions deletions olog b n log mb nb olog ios amortized respectively note use b 2 assumption proof theorem 2 theorem holds 2b easy see b 2 static structure constructed onb log b n ios insertion bound becomes olog 2 using method semidynamic structure described section 2 theorem 1 immediately obtain following theorem 3 set n disjoint segments stored data structure using onb disk blocks vertical rayshooting query answered olog 3 ios insertions deletions performed olog 2 b n olog b n ios amortized respectively improved dynamic structure previous section obtained structure answering vertical rayshooting queries olog 3 using logarithmic method full semidynamic structure section 2 result could also obtained alternative way insert segment structure section 2 search base tree olog b n ios nd node v stored since left right structures already support insertions almost thing need consider insert segment multislab structure also need consider insert endpoints base tree agarwal et al 1 showed using weightbalanced btrees 6 insertion endpoint base tree handled amortized means applying logarithmic method multislab structure lemma 2 obtaining olog 2 query insertion structure obtain result theorem 3 section show design modied multislab structure query answered olog b n ios leading improved overall olog 2 query bound consider multislab structure storing set r n disjoint segments whose endpoints lie b1 previously let b vertical slab bounded b b i1 like logarithmic method divide r log b n disjoint subsets r size less n store r data structure main idea use obtain olog b n query bound similar fractional cascading 10 iteratively starting set b segments sampled i1 use segments avoid olog b n io cost searching i1 answering query since two segments plane always comparable denition 1 fractional cascading directly applicable problem normally applying fractional cascading would sample uniformly sorted sequence segments r i1 intuitively knowing rst segment b b hit vertical ray make possible nd rst segment r r i1 hit eciently many segments could b r sorted sequence segments r i1 unfortunately case since many segments incomparable b r could two segments sorted order problem arises even sample segments uniformly slab j following show overcome problems indeed sampling segments uniformly slab additionally designing i1 segments r i1 two known sampled segments l 1 l 2 j searched eciently o1 ios key obtaining result store segments l 1 l 2 crossing j together secondary structure one complication segment cross many slabs careful store segment many secondary structures would make deletion segment inecient help exposition following refer original segments r red segments segments b sampled i1 stored blue segments also refer original segments b i1 green segments g i1 blue segment b stores pointer corresponding green segment g i1 rest section organized follows section 41 rst discuss sample segments b jr section 42 describe show constructed using linear space given r section 43 show answer vertical ray shooting query olog b n ios overall section 44 discuss perform insertions deletions olog 2 b n olog b n ios respectively thus obtain following lemma 4 set r n disjoint segments endpoints vertical lines stored data structure using onb blocks vertical rayshooting query answered ios segments inserted deleted olog 2 respectively constructed onb log b n ios discussed leads main result theorem 4 exists data structure using onb blocks store planar subdivision size n vertical rayshooting query answered olog 2 worst case insertions deletions performed olog 2 respectively 41 sampling segments given k k log b n disjoint sets r 1 red segments jr j n sample blue b green g i1 segments iteratively starting sorted sequence segments r sorted sequence segments v crossing slab j consider constructing set segments g j slab j sampling every th segment v j cutting sampled segments slab boundaries segment sampled v j subsegment j inserted g j set green segments g i1 sampled r i1 consists sampled segments g 1 say two segments consecutive j g 2 successor g 1 j consecutive sorted list segments g j building i1 r i1 b i1 also include segments g i1 b consists copies segments g i1 segment augmented pointer identical segment g i1 since sample every segment slabs inductively prove size b bounded thus jr given red blue segment sets r b green blue segments g b 1 easily computed ioeciently follows starting rst compute sorting segments r using algorithm arge et al 5 done using scanning v collect segments g j slabs j cutting slab boundaries simply maintain counter counting many segments spanning given slab encountered output relevant segments sorted list total use sample segments r b overall use k b log b n k ios construct blue green segment sets b g lemma 5 given red segments r 1 blue green segments constructed k b log b n k ios 42 constructing describe structure build segments r note later describe delete segment delete original red segment blue green segments possibly produced means number red segments green segments sampled slab become much smaller originalp segments structure consists structures main structure red blue green segments r sample structure u ij green segments g j main structure twolevel structure base structure bary tree sorted sequence segments r leaf containing b 3 segments segments also stored secondary structures internal node pair consecutive green segments less 2 segments crossing slab j g 1 g 2 stored minimal common ancestor v leaves containing g 1 segment assigned v several times one copy actually stored g 1 g 2 also store pointers v copy segment secondary structure contains pointer leaf storing finally green segment j also store minimal rst blue segment crossing j number segments stored internal node v bounded ob 3 segments stored v consecutive green segments pair consecutive green segments j storing segments v stored dierent b children v number internal nodes b 3 b total number segments stored secondary structures ob 3 node v internal leaf two secondary structures r v b v storing red blue segments respectively structures implemented multislab structure section 2 using lemma 2 means use linear space vertical rayshooting queries answered deletions performed olog b 2b 3 ios addition r v b v v also contains index block v containing information many red segments stored v green segments storing segments v given segments r b g sorted order constructed ioeciently follows first constructed using b ios levelbylevel bottomup manner next segments leaves scanned sorted order mcag computed consecutive pair green segments slab maintain last encountered green segment slab compute relevant minimal common ancestor searching tree using olog b ios encountering new green segment time also compute minimal blue segment directly green segment total use ojg ios next scan leaves constructing list red blue segments marked internal node need stored note mentioned earlier one copy given segment assigned node sort list onb log mb ios obtain node v segments stored r v b v finally r v b v well v constructed ob 3 node v lemma 2 b ios total thus use b log b n ios construct consider two consecutive segments nonredundant r contains least one red segment crossing j g 1 g 2 dene lowest nonredundant segment green segment g j lowest nonredundant green segment j g note g lowest nonredundant segments naturally partition sorted sequence green segments j thus also sorted sequence endpoints one boundaries j refer figure 3 deletion red segment r may result two partitions merging nonredundant nonredundant find figure 3 six green segments slab j three red segments crossing j two green segments nonredundant partition segments endpoints induced lowest nonredundant segment relationships indicated rightmost endpoints b finding red segment immediately p given green segment g i1 immediately p rmcag 0 g rmcag 00 g 000 queried sample structure u ij maintains lowest nonredundant segment green segment implemented using interval unionfind structure findg returns lowest nonredundant segment g uniong merges partition containing g partition partition ie partition containing successor g 0 2 g findg j section 45 show interval unionfind structure k elements implemented initialized using ok log b k io union operations free amortized find operations take o1 ios construct sample structures u ij b log b n ios follows rst produce list green segments g nonredundant segments marked scanning list sorted segments r collecting green segments main memory keeping track last green segment seen b processing red segment r simply mark green segments slab crossed r scan sorted list green segments slab j produced onb log mb ios sorting list finally produce u ij slab j turn rst initializing interval unionfind structure green segments j performing union operation corresponding redundant segment number green segments b takes lemma 6 given r sorted order constructed b log b n ios 43 answering vertical rayshooting query consider query p slab j nd rst segment hit ray emanating p rst load 1 mainmemory determine rst red segment r 1 2 r 1 rst blue segment repeatedly use pointer blue segment b green segment g i1 i1 compute rst segments r compute blue segment b i1 consider green segment g 0 j immediately g i1 query bmcag 0 g i1 rst blue segment hit segment exists return minimal blue segment g i1 stored g i1 similarly compute red segment r i1 rst query rmcag 0 g i1 red segment found perform findg i1 u ij determine lowest nonredundant green segment g 00 j querying rmcag 00 g 000 000 successor g 00 j obtain r i1 refer figure 3 b query procedure spends o1 ios uses olog b n ios total rayshooting externaldecomposable easily answer query another olog b n ios r 1 log b n found lemma 7 vertical rayshooting query among n segments 1 log b n answered olog b n ios 44 performing updates insertion basically handled general logarithmic method nd rst structure build new red segments r j structures blue segments b using unlike logarithmic method also need rebuild structures j j starting segment sets r ios rst producing sampled segments b j j discussed section 41 lemma 5 building j j discussed section 42 lemma 6 previously argue least red segments moved lower index structures j charging rebuilding cost segments obtain olog 2 amortized insertion bound deletion segment handled follows rst determine structure well leaf l main structure containing next delete rw nodes w path root l way segments assigned secondary structures cannot stored secondary structure deleting rw also decrement relevant counters w counting number red segments pair consecutive green segments storing segments w using counters determine green segments g become redundant result deletion green segment becomes redundant perform uniong relevant sample structure u ij logarithmic method also perform global rebuilding half original segments deleted relevant structure leaf l located olog b n ios querying one endpoints using separate btree discussed section 3 deleting rw updating w olog b n nodes w path l root also performed olog b n ios total discussed earlier charge cost union operations construction note however worst case perform log b n operations finally global rebuilding adds another olog b n ios amortized deletion cost insertions deletions olog 2 amortized respectively 45 ioecient interval unionfind structure consider k ordered elements initially x considered singleton sets findx union operations used join neighboring sets x find return maximal element set consecutive elements formally x j set x joins set elements x l findx l set elements xm findxm findx q findx j g interval unionfind structure implemented ioeciently straightforward way using height one trees initially store n elements consecutively disk element containing pointer root containing copy element findx maintain elements x point find find operation performed o1 ios root elements stored consecutively disk structure occupies onb blocks union operation implemented combining two consecutive sets elements update elements 2 point root 1 update pointers smallest set elements stored consecutively disk accomplished o1 ios root pointer element changed log 2 n times overall cost u union operations bounded ou ios u n obtain following lemma 9 interval unionfind structure n elements implemented using onb disk blocks find performed o1 ios u union operations performed log b n ios total 5 conclusions open problems paper presented linear space ioecient dynamic data structure point location general planar subdivision important parts data structure based new external version logarithmic method 9 well new external version dynamic fractional cascading 10 21 several challenging problems remains open one example query andor insertion bounds improved olog b n note improvement would also lead improved internal memory structure another example develop higherdimensional structures acknowledgments rst author would like thank pankaj agarwal many inspiring point location discussions r inputoutput complexity sorting related problems external memory data structures theory practice io ecient algorithms multidimensional batched searching problems optimal dynamic interval management external memory dynamic point location general subdivisions organization maintenance large ordered indexes decomposable searching problems fractional cascading new results dynamic planar point location ubiquitous btree randomized externalmemory algorithms geometric problems new approach rectangle intersections spaceoptimal solution general region location new data structure representing sorted lists optimal search planar subdivisions design dynamic data structures range searching set line segments planar point location using persistent search trees point location dynamic maintenance planar digraphs planar point location large data sets seek seek external memory algorithms data structures dealing massive data tr planar point location using persistent search trees optimal point location monotone subdivision inputoutput complexity sorting related problems new results dynamic planar point location dynamic point location general subdivisions unified approach dynamic point location ray shooting shortest paths planar maps point location ioefficient dynamic point location monotone planar subdivisions theory practice ioefficient algorithms multidimensional batched searching problems range searching set line segments ubiquitous btree external memory algorithms data structures design dynamic data structures externalmemory algorithms processing line segments geographic information systems extended abstract external memory data structures planar point location large data sets optimal external memory interval management ctr lars arge mark de berg herman j haverkort ke yi priority rtree practically efficient worstcase optimal rtree proceedings 2004 acm sigmod international conference management data june 1318 2004 paris france pankaj k agarwal lars arge ke yi optimal dynamic interval stabbingmax data structure proceedings sixteenth annual acmsiam symposium discrete algorithms january 2325 2005 vancouver british columbia lars arge mark de berg herman haverkort cacheoblivious rtrees proceedings twentyfirst annual symposium computational geometry june 0608 2005 pisa italy
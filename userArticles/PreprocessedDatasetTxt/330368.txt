achilles turtle undecidable boundedness problems small datalog programs datalog language logic programs without function symbols considered paradigmatic database query language possible eliminate recursion datalog program bounded since bounded programs executed parallel constant time possibility automatized boundedness detecting believed important issue studied many papers boundedness proved undecidable different kinds semantical assumptions syntactical restrictions many different proof techniques used paper propose uniform proof method based discovery call achillesturtle machine make strong improvements known undecidability results particular solve famous open problem kanellakis showing uniform boundedness undecidable single rule programs called also sirupsthis paper full version j marcinkowski proc 13th stacs lecture notes computer science 1046 pp 427438 j marcinkowski 11th ieee symposium logic computer science pp 1324 b introduction 11 introduction query relation r answers given directed graph database possible given two nodes reach one odd number steps first order one lack recursion first order logic observation led study datalog database logic programs combine existential positive first order logic recursion example relation r defined odddistance datalog program rxy exy e edge relation graph e called extensional predicate treat input able prove new facts r output intensional predicate idb program proves facts first rule initialization rule extensional predicate body second rule contains intensional predicate among premises used recursively deep proofs constructed clear graph path element b odd length n prove ra b supported kbn grant 8t11c02913 jmatcsuniwrocpl institute computer science wroclaw university ul przesmyckiego 20 j marcinkowski elements proof depth log n may needed huge databases arbitrarily deep proofs necessary evaluate program hand consider program computes 3tail query iii 1tailz ez x v 3tailz 2taily ez 3taila provable exists proof fact deeper 3 regardless number elements database 1tail 2tail 3tail idb predicates second third rules recursive fact recursion eliminated last program possible write equivalent one proofs deep 1 necessary recursion eliminated given program program equivalent first order query priori upper bound depth proofs needed evaluate queries every fact derived program derived constant time parallel polynomially many processors independent size database equivalence proved 3 direction nontrivial programs called bounded 12 previous works contribution problem distinction whether given datalog program bounded important datalog queries optimization general undecidable sufficient conditions boundedness given 17 10 18 19 decidabilityundecidability border cases different syntactical restrictions semantical assumptions studied 20 5 2 6 8 9 24 23 syntactical restrictions considered number rules recursive rules program maximal arity idb symbols linearity rules semantical assumptions concern status idb relations execution program empty deal weak program boundedness arbitrary relations must considered possible idb inputs strong uniform boundedness studied undecidability uniform boundedness implies undecidability program boundedness fixed syntactical restrictions possibly additional initialization rules see section 17 discussion survey previously known results iv illustrates difference level difficulty undecidability proofs uniform program boundedness decidability proved monadic programs program boundedness also uniform 6 5 typed single rule programs 20 also known program uniform boundedness decidable programs single linear recursive rule idb predicate binary 24 moreover program boundedness decidable binary programs idb predicate defined one recursive rule 23 undecidability proved program boundedness linear binary programs 9 achilles turtle small datalog programs 3 ii program boundedness programs one recursive rule two initializations 2 iii program boundedness programs consisting two linear recursive rules one initialization 9 iv uniform boundedness ternary programs 9 v uniform boundedness arity 5 linear programs 8 decidability uniform boundedness programs consisting one rule stated open problem 11 nphardness problem proved 2 12 undecidability results uniform boundedness programs small number rules proved since paper give strong improvements results iiv showing vi uniform boundedness undecidable ternary linear programs section 31 improves results iv v vii uniform boundedness undecidable single recursive rule ternary programs section 33 improves iv additional improvement program syntactically simpler recursive rule quasilinear means generally speaking form j intensional predicates since recursive rule proof program tree one possibly long branch notice vi vii still allow number initializations results hold also program boundedness viii uniform program boundedness undecidable programs consisting one linear recursive rule one initialization section 43 since program boundedness clearly decidable programs consisting one rule result viii closes numberlinearity rules classification program boundedness strong improvement ii iii finally section 45 solve problem kanellakis showing ix uniform boundedness single rule programs undecidable 13 method different techniques used proofs results iv reduction halting mortality problems turing machine reduction halting problem two counters machine syntactical reduction arbitrary datalog program single recursive rule program develop results universal method based encoding conway functions learned conway functions paper philippe devienne patrick lebegue jeanchristophe routier 7 used prove undecidability called cycle unification feel paper would written without previous work encoding nevertheless quite different one 7 first difference language functions used construct call achillesturtle machine variant turing machine next use version conway theorem prove constructed really universal machine encode achillesturtle machine datalog programs due particular simplicity achillesturtle machine one really tempted claim simplest known universal machine possible encode syntactically small datalog programs believe last time achillesturtle machine used undecidability proofs 4 j marcinkowski combine conway functions method technique using binary edb relation order chain long enough relation think represents tape machine chain proofs long method goes back 9 8 14 open problems classification finished program boundedness following syntactical restrictions still give interesting open problems concerning decidability uniform boundedness binary programs ii linear binary programs iii programs consisting single linear rule know example syntactical restrictions uniform boundedness would decidable program boundedness seems likely candidate example class linear binary programs program boundedness known undecidable class 15 preliminaries datalog program finite set horn clauses called rules language first order logic without equality without functions predicates used program bodies rules called extensional predicates edb predicate occurs head rule called intensional idb rule called recursive idb predicate occurs body rule recursive initialization rule recursive rule linear one occurrence idb body program linear recursive clauses linear arity datalog program highest arity idb predicates used example two programs section 11 predicate e extensional predicates intensional rules iii initializations rules ii iv v recursive rules iv v linear 3 tail program linear also monadic odddistance program binary database finite set ground atomic formulas derivation proof ground atomic formula program p database finite tree nodes labeled ground atomic formula ii leaf labeled atom iii nonleaf node exists rule r program p substitution oe oe head r label node substitutions body r labels children iv label root tree depth proof depth derivation tree instead writing proof program p database use expression simply proof context clear notice p linear program pproof sequence ground atomic formulas case use word length depth proof general program p bounded every database atom proved p proof deeper fixed constant c different conventions concerning input output datalog program correspond different definitions boundedness predicate program uniform boundedness studied program predicate bounded respect fixed predicate pre constant c every database facts idb predicates every ground atom atom proof p proof deeper c definition reflects situation edb predicates input one achilles turtle small datalog programs 5 predicate output program program p program bounded predicate bounded idb predicates program uniformly bounded constant c every database suppose idb predicates occur every ground atom atom proof p proof deeper c predicates viewed input output program 16 example program boundedness vs uniform boundedness make difference program boundedness uniform boundedness clear reader give example program bounded uniformly bounded signature program consists one extensional predicate e one intensional predicate predicates binary rules convenient think e graph kind pebble game initialization rule start game placing pebbles node tail length least 2 rule iii need distinguish pebbles rules iv v always move one pebbles neighbouring node finally two pebbles meet node end tail length least two rule ii move pebbles two nodes prove program program bounded uniformly bounded lemma 11 database input predicate empty either proofs pair de elements fact id e proved 7 derivation steps proof consider two cases case 1 elements ea b ebc hold first step use rule prove ia using twice rule v get ic use rule iii get ia c twice rule v get ic c finally rule ii used derive id e case 2 elements database since given empty proofs possible structure proof lemma 11 well structure program good illustration one ideas proofs sections 3 4 program contains initialization rule rules allows start kind game computation exists substructure required form database enough facts database proceed computation terminates use analogon rule ii flood 6 j marcinkowski database otherwise enough facts short proofs possible proofs example lemma 12 constant c exist database nonempty input predicate elements ia b pprovable shortest proof fact requires c steps proof database contains elements c following facts ec show fact ic 2c c 1 provable shortest proof exactly steps first show proof exists kth step use already proved fact derive ic rule used kth derivation step v k odd iv k even show shorter proofs possible notice bodies rules iiiv satisfied rules used define distance nodes follows distance 0 distance b less equal k exists node c either ebc ec b distance b 1 distance pair nodes b pair nodes c defined sum distances c b notice fact form ia b derived k steps fact ic rules iiiv used proof distance b c greater k finally observe distance c 17 program boundedness vs uniform boundedness discussion notions uniform program boundedness formalize technical level informal notion boundedness uniform boundedness need program consideration subprogram bigger one happen predicates supposed output program also part input program boundedness hand corresponds view entire datalog program definition possibly many output predicates similar distinction program uniform equivalence datalog programs see 21 first notion applies entire programs second one subprograms equivalence known program equivalence undecidable uniform equivalence decidable 52122 observe also case boundedness uniform version given syntactical restrictions priori decidable suppose program boundedness decidable syntactical restrictions restrictions allow arbitrary number initializations uniform boundedness also decidable restrictions see consider program p signature idb symbols 1 let q program p signature enriched new edb symbols arity e equal arity k new rules easy see q program bounded p uniformly bounded reduced decision problem uniform boundedness p problem program boundedness program q survey results gives evidence difficult prove undecidability uniform boundedness undecidability program boundedness argument shows reasons hand know example syntactical restrictions uniform boundedness achilles turtle small datalog programs 7 would decidable program boundedness likely candidate example class linear binary programs program boundedness undecidable class decidability uniform boundedness open 2 achillesturtle machine 21 tool conway functions definition 20 conway function function g natural arguments defined system equations q natural numbers q ji means iq natural number q jp conway function g given natural number n let cg n statement asserting exists natural number g see section 23 find nice example giving idea conway function proof following theorem found 4 14 7 theorem 21 conway problem given conway function g natural number n cg n hold undecidable main tool following refined version theorem 21 theorem 22 1 exists computable sequence fgn g conway functions 2g recursive complete ii g n q coefficients definition function 2 iii g n 2 exists universal conway function g set fn cg 2 n g recursive complete ii q coefficients definition function g 2 iii n proof 1 known problem given finite automaton 2 counters computation starting fixed beginning state empty counters reach fixed final state undecidable even require final state reached counters empty read remark end section see precisely mean finite automaton 2 counters given automaton kind construct conway function g satisfies conditions ii iii theorem cga 2 holds computation reaches final state first 8 j marcinkowski need modify little bit construct automaton b terminates terminates satisfies following conditions iv second counter b increased first counter decreased computation step v states b numbered counters increased computation step state changed j details construction b left easy exercise hint must done adding couple new states example instruction increases second counter keeps first unchanged must substituted two instructions first increases first counter changes state new one second increases second counter decreases first suppose states automaton b beginning state let increasing sequence primes sequence found k since density primes around n c log n encode configuration b state first counter contains number n second counter contains natural number 2 easy notice x codes two subsequent configurations b yx depends remainder x mod p yx 2 define required conway function define first step properly put code beginning configuration put also p f reach 1 iteration function next one code final configuration reached 2 use well known fact exists particular finite automaton counters problem computation starting fixed beginning state b given first counter empty second counter reach configuration fixed final state f empty counters undecidable proof similar start computation properly put even p j ji hold n holds g2 n last code beginning configuration remark automata counters notion finite automaton two counters similar one kozens book 13 difference assume automaton input tape since two counter automata readonly input tape powerful turing machines problem whether given automaton kind terminate given input undecidable input separately hide input finite control automaton fact input tape finite object input also problem whether given automaton without input tape terminate started fixed beginning state empty counters undecidable show needed proof second claim theorem 22 exists particular finite automaton 2 counters problem computation starting fixed beginning state b given first counter empty second counter reach configuration fixed final state f empty counters undecidable first observe exists automaton required 3 counters universal achilles turtle small datalog programs 9 turing machine contents part tape left head remembered one counter right head second counter auxiliary third counter needed operating first two use standard techniques encode three counters two see 13 details convention 23 since consider conway functions g n existence proved theorem 22i particular assume claims ii iii theorem 22i hold 22 achillesturtle machine given conway function g given input n construct achillesturtle machine compute subsequent iterations gn variant multihead turing machine readonly tape cell tape coloured one colours k 0 k p definition function g cell x coloured colour k denote fact k x cell sx successor function tape coloured k j p colour k 0 called white called red 3 heads first symbolizes achilles second turtle third called guide transition rules designed way heads never go left achilles guide move right step computation achilles try catch turtle configuration machine described positions heads beginning computation achilles arbitrary white cell x tape turtle guide cell n x beginning configuration conxs n x n x successor function tape idea computation reach configuration form achilles exactly k cells behind turtle g computation step heads machine move according one following transition rules r since q rules r run rules rules j jump rules configurations form called special see section 23 nice example achillesturtle machine following easy lemma gives intuition computation machine proceeds lemma 24 configuration machine turtle cell x guide ii configuration machine turtle cell x achilles k x none jump rules used later j marcinkowski computation iii suppose configuration machine achilles cell x turtle x guide r x one jump rules used later iv special configuration result transition done according one jump rules v achilles always white cell vi configuration machine guide cell x next configuration r x proof claim true beginning configuration every configuration result use jump rule run rules move guide right keep turtle cell ii achilles right turtle jump rule used run rules move achilles right iii follows ii iv guide never left turtle run rules move right execution run rule right turtle v starts white cell moves p cells right step vi since hold every see convention 23 formulate prove lemmas equivalence behaviour conway function result computation achilles turtle machine goal lemma 25 following conditions equivalent cg n holds ii achillesturtle machine reach configuration form iii achillesturtle machine reach configuration form conasasa iv achillesturtle machine reach configuration form lemma 26 suppose special configuration machine achilles cell turtle guide k steps configuration cons gammai ii exactly two configurations reached k proof k steps done according rule r k steps achilles cell kp kpa q turtle ii cons gammai reached k steps rule r may used leads cons pgammai rule j may used leads lemma 27 suppose special configuration machine achilles cell turtle guide p following two conditions equivalent achilles turtle small datalog programs 11 possible reach special configuration conxs l x l x next special configuration proof lemma 26 ii configuration k steps either first case achilles already right turtle lemma 24 iiiv special configuration reached prove equivalence show configuration reached second case form conxs gm x gm x fact conxs gm x gm x lemma 28 following two conditions equivalent achillesturtle machine reach configuration form conxs l x l x ii exists natural number j g j proof iii implication proved induction number special configurations reached computation iii implication proved induction j cases lemma 27 used induction step proof lemma 25 ii iii equivalent lemma 28 convention 23 claim iii theorem 22i clearly ii implies iv also iv implies ii configuration reached number steps k 1 holds consider configuration last step computation done according jump rule last step turtle moved configuration 23 achillesturtle machine example order give reader idea machine works going provide nice example conway function rather conwaylike function achillesturtle machine built function function g start wellknown collatz j marcinkowski function take natural number even divide two odd multiply three add one problem iterations procedure give finally result 1 regardless natural number start open formally spirit definition 20 define function g ae open problem whether multiply number also add 1 really conway function sense definition 20 anyway find example inter esting construct achillesturtle machine function rules example achillesturtle machine initial configuration conxs n x n transition rules run rules jump rules final configuration conxsxsx coefficients run rules white jump rule calculated according definitions r j beginning section 22 left hand side red jump rule cons 2 4 g 4 g would follow definition place add 1 form 3n 1 suppose concreteness example n 5 subsequent iterations g 5 16 8 4 2 1 beginning configuration machine conas 5 5 white cell computation sequence machine cons 4 x 5 x 17 x rr cons 26 x cons 6 x 22 x 22 x rj cons 28 x cons 8 x 22 x 23 x wr cons cons 12 x 22 x 25 x wr cons 34 x 38 x 38 x wj cons 14 x 22 x 26 x wr cons 36 x 38 x 39 x wr achilles turtle small datalog programs 13 cons cons cons 20 x 22 x 29 x wr cons 42 x 42 x 43 x wr cons 22 x 22 x rr means red run rule used obtain configuration wr white run rule rj red jump rule wj white jump rule configurations marked depicted fig 1 3 ternary programs 31 ternary linear program p theorem 31 conway function g n theorem 22i exists efficiently constructed arity 3 linear datalog program p one idb predicate uniformly bounded cgn 2 holds signature program contains one binary edb symbol going serve kind order us p monadic edb symbols play colours ternary idb symbol con program p consists transition rules flooding rule conxyzconst r k 1 km understood k j mod p since longer true successor must explain meaning l symbols rules notational convention example rule understood conx2y 4 x1 conxx1y let us explain meaning rules transition rules achillesturtle machine exception check cells nodes achilles runs painted properly flooding rule proves everything one step turtle red node initialization allows start computation white node properly coloured piece tape near node lemma 32 cgn 2 hold c exists database tuple elements conat g proved p proof conat g requires c steps 14 j marcinkowski g g g g fig 21 subsequent configurations example achillesturtle machine proof long enough schain see definition 34 empty idb relation first prove flooding rule used database provided cgn 2 hold suppose used means proved red follow proof conat g notice gives legal computation achillesturtle machine first fact proof beginning configuration machine achilles turtle small datalog programs 15 contradiction lemma 25 take first element z order initialization conzs 2 z 2 z using 2c times run rule 2 get shortest proof fact cons 2pc going prove lemma 33 cgn 2 holds exists c database every tuple b c elements conabc proved program p exists proof conabc shorter c steps proof suppose holds means start computation achillesturtle machine configuration conxs 2 x 2 x possible reach final configuration conasasa notice computation none heads move left x right sa let k distance x sa let k number steps computation necessary reach final configuration clearly pk1 k going prove ck2 proper constant need definitions definition 34 schain elements database set x sxm xm1 km xm decreasing schain elements database set x km xm km understood k mod p cases say chain begins x 0 definition 35 let k natural number say node w database kfounded exists decreasing schain begins w consists k elements w kfounded chain exist definition 36 let k natural number say database kfounded exists schain consisting k elements obviously kfounded chain exist consider 2 cases lemma 37 kfounded tuple b c elements fact conabc proved proof requires k2 steps proof take x exists schain length k beginning x thanks initialization rule conxs 2 x 2 x provable proof length 1 pretend chain x k x tape start computation achillesturtle machine since transition rules machine rules program p step computation encoded one step proof exists element chain st red proved k1 steps one step using flooding needed prove con every tuple lemma 38 let kfounded database i0 pproof flooding rule used proof k i0 pproof suppose shortest possible proof conam bm cm flooding rule used last step proof iii conabc pproved tuple b c proof requires k proof set subsequence schain length pm j marcinkowski ii suppose step done according flooding rule shorter proof conam iii follows ii ends proof lemma 33 theorem 31 theorem 39 uniform boundedness ternary linear datalog programs undecidable proof follows theorems 22 31 32 arity 5 single recursive rule program r theorem 310 conway function g n theorem 22 exists efficiently constructed arity 5 datalog program r consisting one quasilinear recursive rule initializations uniformly bounded iff holds previous subsection signature program contains one binary edb symbol going serve kind order us p monadic edb symbols play colours ternary idb symbol con also additional idb symbol steer arity 5 program r consists recursive rule g initialization transition rules g g g gk initialization flooding rule steerxt r sk 1 initialization conas 2 2 ak 0 k 1 let us explain going triples achilles turtle guide nodes graph defined 3 means order colouring proof either program p r path graph graph given edb relations defined datalog program without recursion want define vertices beginning node g online computation reaches node p must use one rule rules linear read nothing information edb situation around define graph advance initializations one recursive rule enough graph accessibility program case rule quasilinear makes use additional idb recursive predicate steer reader would ask question steer predicate arity 6 want hide rule achilles initializations simpler recursive clause fact additional problems arise since flooding rule achilles forced design recursive rule way uniformity achilles turtle small datalog programs 17 reasons crucial achilles goes chains thanks say long chains long proofs lemmas 38 312 case 1 could write initializations hypothetical 6ary steer way achilles would move chains running according steer facts proved initializations would control given steer beginning lemma 311 cgn 2 hold c exists database tuple b c elements conabc proved program r proof ca b c requires c steps proof lemma 32 lemma 312 cgn 2 holds exists c every database every tuple b c elements conabc proved r exists proof conabc shorter c steps definition 313 b c tuple elements database say conabc fact proof lemma 312 suppose cgn 2 holds computation achillesturtle machine starting configuration conxs 2 x 2 x reaching conysy sy computation requires space kp distance x kp natural k consider 2 cases case 1 1pfounded every proof fact longer 1 achilles part recursive rule analogous lemma 38 case 2 c take v k1p v chain length k 1p v initialization rule convs 2 v provable proof length 1 pretend chain v kp1 v tape let achilles turtle play game among rules possibly given predicate steer also standard achillesturtle machine rules k moves configuration cons kp v reached allowed use flooding every fact form conabc proved one step new facts proved later course nothing new idb predicate steer proved first step ends proof lemma 312 theorem 310 33 ternary single recursive rule program q theorem 314 conway function g n theorem 22i exists efficiently constructed arity 3 datalog program q consisting one quasilinear recursive rule initializations uniformly bounded iff holds similarly previous subsection signature program contains one binary edb symbol going serve kind order us p monadic edb symbols play colours ternary idb symbol con graph defined arity 5 relation previous section defined intersection four graphs defined ternary constraints four additional ternary idb symbols language program rules program q recursive rule j marcinkowski g g 0 initialization constraints rules g 0 rule g 0 rule 0 rule g g 0 rule g pa g g 0 k 1 initialization prove correctness construction shall argue ternary relations really define graph relation steer last section easy notice steerat g proved one initializations g g 0 also proved opposite inclusion suppose red first consider relation e gtt 0 since guide see far achilles guide constraint allows turtle stay place jump according proper jump rule relation e att 0 decides turtle allowed jump achilles far away turtle wait achilles catch turtle turtle allowed jump see 1 anywhere relation e gtt 0 anywhere g proper way already first two relations force turtle behave relation forces guide move ahead allows guide execute jump rule turtle jumps together prevents achilles turtle small datalog programs 19 danger guide jumps turtle runs whatever turtle guide allowed use proper run rule danger turtle jump guide run allowed achillesturtle machine rules prevented relation e tt 0 remains place guide allowed go anywhere moves guide must join red constraints allow guide turtle go anywhere theorem 315 uniform boundedness single recursive rule ternary datalog programs undecidable proof follows theorems 22i 314 remark could use theorem 22ii instead get universal datalog programs example theorem 31 would form exists arity 3 linear datalog program p one idb predicate computable sequence fpng initialization rules program p pn uniformly bounded cg n holds g universal conway function theorem 22 ii fact form 15 however done section 4 decided present results general versions preserve notational uniformity instead 4 single rule programs 41 constants notational proviso sections 42 45 going encode computation achillesturtle machine small number rules one two afford separate predicate colour instead going one binary predicate col understand colca colour c instead predicates need constants name colours constants datalog fact want use say constants simply increase arity idb symbols k write sequence c variables k last arguments occurrence idb predicate program one reasons programs following sections high arity example program constants b written means p x constants understood b thanks suppose constants language use following constants jump run joker constants colours colour also called white colour 1 red colour 2 pink j marcinkowski 42 achillesturtle game section modify description achillesturtle machine define equivalent version one transition rule make notation compatible database notation going forget tape use kind infinite graph instead distinguish version machine called achillesturtle game transition rules achilles turtle machine indexed three pa rameters first either jump run remaining two colours turtles cell guides cell transition idea going bellow treat parameters arguments occurring goals body single rule solving first four goals body substitute proper parameters variables cond tcolor gcolor parameters used compute positions achilles turtle guide execution rule following definition introduces predicates used construction single rule hope reader understand definition reads proof lemma 42 definition 41 given conway function g theorem 22 achillesturtle graph relational structure g exactly nodes relations listed nodes g colour joker infinite sequence nodes c holds node c colred joker holds iv holds holds j 0 mod p 0 v holds holds holds vi holds achilles turtle small datalog programs 21 holds vii holds holds k holds k viii holds holds ix holds colour holds holds colour trulerun red joker joker holds holds holds holds set nodes c graph natural way understood tape achillesturtle machine notice facts definition local sense elements c c j directly connected fact white node c c j going use relations achillesturtle graph encode rules machine one transition rule conf body conjunction following facts 22 j marcinkowski coltcolort g lemma 42 suppose red computed single computation step achillesturtle machine conf reached conf g single step achillesturtle graph game proof clear move achilles performed way machine game simply moves p cells ahead check also case turtle guide direction easier transition machine done according run rule substitute run variable cond else substitute jump variable tcolor substitute colour turtles cell variable gcolor substitute colour guides cell white node g g 0 substitute exactly one white node substitute node x 1 two nodes substitute first x 1 second x 2 notice condition ii theorem 22 two white nodes g g 0 grule goals lines vvii body satisfied way cond run substitute x 3 notice case cond jump substitute joker x 3 two trule goals body satisfied way satisfy last two goals substitute joker x 4 cond run cond jump substitute g 0 x 4 direction first notice conjunction satisfied really distance achilles turtle transition smaller p jump allowed according achilles turtle machine rules rules guide defined claims vi vii viii definition 41 assure cond tcolor gcolor chosen fair way guide game moves way one machine turtle cond run move fact conjunction satisfied cond jump turtle go node guide conjunction satisfied every choice joker substituted x 3 conjunction achilles turtle small datalog programs 23 satisfied x following lemma much easier prove lemma 42 left exercise reader lemma 43 c red configuration form conf reached conf single step graph game hint put cond equal run tcolor equal red 43 single linear rule program initialization section use achillesturtle game construct datalog program one linear recursive rule one initialization uniformly bounded cg 2 holds edb predicates program used definition 41 one ternary idb predicate config variables g fact form usually understood achilles turtle guide consider database suppose colour run joker occur motorway sequence elements database used playing achilles turtle game definition 44 suppose elements say sequence motorway subgraph ordered sets elements considered g database definition 41 example require sx 3 hold motorway ready write linear recursive rule program conf conjunction facts needed sequence motorway notice last lines rule exactly literals body 0 g 0 occurs run substituted cond red substituted tcolor j marcinkowski initialization program conf thanks last lines recursive rule sure fact conf proved one step conf iga g also proved one step fact form conf red see proof lemma 48 case 1 next goal show long proof using recursive rule possible database long motorway lemma 45 consider sequence elements database 0 k x gamma 1 subsequence motorway also whole sequence motorway proof conditions ix definition 41 local elements c j occur condition white node c c j lemma 46 suppose conf conf conf conf sequence facts 0 conf derived conf single use recursive rule exists sequence elements database motorway proof follows lemma 45 construction recursive rule definition 47 g tuple nodes database say fact ready prove cg 2 holds program uniformly bounded lemma 48 cg 2 holds exists constant c every database program proves fact fact proved c derivation steps achilles turtle small datalog programs 25 proof cg 2 holds achillesturtle game reach configuration conf x sx sx white x sx red suppose k moves needed reach configuration nodes machine graph left right sx visited computation going prove k2 good candidate c consider element 2 possibilities case 1 motorway length k 1p database last node suppose motorway initialization rule conf proved one derivation step next k derivation steps one simulate k steps achillesturtle game k1 steps derive conf since gammap1 red one argue like proof lemma 43 see next derivation step prove 0 g 0 last lines recursive rule facts proved case 2 motorway lemma 46 every proof less k3 steps still need show cg 2 hold program unbounded lemma 49 cg 2 hold constant c exist database empty input idb relation fact proved database proof requires c steps 26 j marcinkowski proof enough show arbitrarily long proofs needed achilles turtle game graph suppose idb input facts start done initialization use 2c times run rule turtle pinkcoloured cell notice position turtle remain unchanged computation final configuration shortest proof fact really requires 2c1 steps including initialization summarize theorem 410 uniform boundedness program boundedness undecidable programs consisting one linear rule one initialization proof problem given conway function g cg 2 hold undecid able even functions satisfying conditions ii iii theorem 22i function construct datalog program one linear rule one initialization program bounded cg 2 hold lemma 49 uniformly bounded cg 2 holds lemma 48 44 single rule program one construct would like modify construction previous section get single rule program problem initialize predicate conf ig simplest solution would initialize check way use motorway goal body rule check needed edb facts hold rule look like conf conf way one could think secure possible start computation achillesturtle machine place derivation step made enough go footsteps proof lemma 48 require initial configuration provable really secured wouldbe rule provable bounded number steps fact one step previous section think new trick assure 45 single rule program construct single recursive rule achilles turtle small datalog programs 27 conf igrun z conf igw run g main premise conf igjump run 2 2 initialization premise jumprun premise constant joker occurs p times predicate motorway added two additional arguments recursive predicate rule asserts something derived first argument run constants run jump interpreted way database fact proved program provable provable 0 steps given part input also fact require deep proof proof possible fact given input jumprun premise normally useless main initialization premise derivation step jump second argument run jump equal database use show anything proved everything proved one step must hold joker red use methods section 43 prove constructed single rule program uniformly bounded cg 2 holds lemma 411 cg 2 holds exists constant c every database fact proved rule proof deeper c proof let k like proof lemma 48 need consider two cases case 1 jump run different elements database 28 j marcinkowski suppose fact proof length least k2 follow proof lemma 48 use fact needed initialization given input short 0step proof show everything proved k2 derivation steps case 2 jump run interpreted element database suppose anything proved p conf igjump jump joker joker joker holds database since holds since joker red every fact form conf igrun z proved one derivation step lemma 412 cg 2 hold constant c exist database fact conf igrun run proved rule database proof requires c steps proof proceed similar way proof lemma 49 following differences longer assume idb input empty instead require following conf ig facts input x c conf ii require x c holds ends proof theorem 413 uniform boundedness single rule datalog programs undecidable achilles turtle small datalog programs 29 r boundedness undecidable datalog programs single recursive rule datalog versus first order logic parallel evaluation recursive rule queries decidable optimization problems database logic programs halting problem one binary recursive horn clause undecidable undecidable optimization problems database logic programs undecidable boundedness problems datalog programs time bound materialization recursively defined views logic programming parallel complexity elements relational database theory handbook theoretical computer science 3 frenchmen method proves undecidability uniform boundedness single recursive rule ternary datalog programs undecidability uniform boundedness single rule datalog programs recursive axioms relational databases data independent recursion deductive databases decidable class bounded recursions computing restricted projections representative instances positive results boundedness multiple recursive rules decidability undecidability results boundedness linear recursive queries tr ctr foto afrati stavros cosmadakis eugnie foustoucos datalog programs persistency numbers acm transactions computational logic tocl v6 n3 p481518 july 2005 evgeny dantsin thomas eiter georg gottlob andrei voronkov complexity expressive power logic programming acm computing surveys csur v33 n3 p374425 september 2001
toward foundational typed assembly language present design typed assembly language called talt supports heterogeneous tuples disjoint sums general account addressing modes talt also implements von neumann model programs stored memory supports relative addressing type safety execution garbage collection shown machinecheckable proofs talt first formalized typed assembly language provide features b introduction proliferation lowcost computing hardware ubiquity internet created situation huge amount computing power idle andin principleaccessible developers goal exploiting idle computational resources existed years beginning setihome 27 1997 handful projects successfully made profitable use idle computational resources internet recently paradigm called grid computing elicited serious interest among academics 5 15 industry general means conducting lowcost supercomputing despite increasing interest grid computing remaining obstacle growth understandable reluctance computer owners download execute software developers know trust may even heard limited practical use grid computing small number potential users able obtain trust thousands computer owners know concert project cmu 9 seeking overcome obstacle developing system trustless dissemination software concert framework machine owner installs steward program ensures safety downloaded software new grid application obtained execution parts concert framework determine takes place application expressed form certified code executable code accompanied certificate proving code safe steward verifies certificate valid permitting code executed form certified code used prototype concert system 7 typed assembly language tal 19 18 implemented talx86 system 17 developed primarily cornell talx86 specializes tal intel ia32 architecture 1 14 enhances number constructs supported theoretical system although certified code eliminates need trust developers grid applications remains need trust soundness steward talx86 productionquality certified code systems java vm 16 proofcarrying code pcc 8 similar need trust stems four issues 1 talx86s safety justified informally analogy tal work rigorous proof 2 safety tal talx86 analogy given terms abstract machine although abstract machine lowlevel type system ways still somewhat highlevel compared concrete architecture obscures important issues thereof 3 safety proofs exist given written form consequently checking veracity errorprone done experts 4 one must trust talx86 type checking software correctly implements type system certain extent need trust steward conditions serious obstacle machine owners routinely trust safety great variety applications far less formal basis moreover certain amount trust required case since participants personally inspect components system using nevertheless minimizing systems trusted computing base always laudable goal known x86 architecture grid computing however desire minimize trust steward goes beyond general considerations key issue extensibility aim enable establishment decentralized grid computing fabric available wide array participants purpose implausible imagine single type system suce potential grid applications furthermore also implausible indeed undesirable single trusted agent would check soundness proposed new type systems thus necessary basic steward safely extended new type systems untrusted sources natural way achieve using foundational certified code entire safety argument safety policy expressed terms concrete architecture given machinecheckable form incarnation foundational pcc 1 binary accompanied complete proof safety proposed foundational tal programs safety argument broken two parts first portion selfcertified type system specification type system machinecheckable proof satisfies established safety policy portion would generally independent particular application second portion applications typing derivation certified type system model grid application developer could devise type system sucient certify applications whenever steward encountered certified application referring unknown type system steward would automatically download type system verify safety proof thereafter accept applications valid typing derivations type system model addresses four issues demanding trust new type system first three issues clearly dealt use complete machinecheckable proofs packaging applications typing derivations opposed type annotations fourth issue also addressed single proof checker check derivations type system new checker need ever employed aim work implement first example foundational typed assembly language intel ia32 architecture also build flexible foundation variety type systems may built accordingly broken development system two stages model hamid et als development featherweight tal 12 first stage develops general typed assembly language specific architecture general language given operational semantics abstract safety established machinecheckable proofs type preservation progress safety garbage collection also established level section 4 second stage shows abstract operational semantics maps correctly onto concrete architecture general type system designed account issues pertain type system including nearly central issues second stage simulation argument topic paper first stage eort second currently underway 11 talt paper presents new typed assembly language called talt tal two aims talt threefold first talt intended provide sucient expressive power serve target language certifying compilers expressive highlevel languages particular standard ml popcorn safe dialect c 17 second talts operational semantics intended account greatest extent possible central issues execution actual hardware second stage foundational safety proof discussed simple albeit lengthy tedious simulation argument third talt intended fully formalized enjoy machinecheckable type safety proof begin discussion overview talt accomplishes aims expressiveness order provide expressive power necessary compile practical highlevel programming languages talt follows talx86 17 adding support heterogeneous tuples ie tuples fields size recursive types disjoint sums arrays unlike talx86 however talt supports constructs using formalized type theory rather using specialized code type checker talt provides expressive power original published talx86 exception tals initialization flags replaced another slightly less general mechanism sec tion 222 later enhancements talx86 supported talt although many could added without diculty completeness operational semantics tal specified terms lowlevel abstract machine including explicit register file memory stackbased tal 18 stack brings tal nearly low level possible without committing details architecture however tal machine model include program counter instead included stream input instructions served surrogate program counter branch instruction machine would discard current stream instructions copy instructions branch address talt hand includes explicit program counter program counter must part model address important issues concrete architecture possible principle write code ahead program counter rarely permitted practice course even since programs fact stored memory essential part foundational safety proof explicitly address issue requisite argument dicult talt follows standard practice makes code readonly machine model must include explicit program counter make argument explicit program counter also necessary account notion relative addressing particularly important ia32 control transfers including conditional jumps relative finally explicit program counter precisely fact instruction individually addressable allows true call instruction return address taken program counter system includes conservative garbage collector 4 part trusted computing base makes garbage collector eectively part architecture accordingly need prove collector safe necessary show programs adhere invariants collector requires 3 2 talt type system accounts invariants using invariants prove type safety disrupted garbage collection section 4 interest simplicity version talt paper provides representative operations add subtract compare also omit discussion floating point ia32s implementation floating point using register stacks idiosyncratic foresee fundamental diculties extending talt either direction talt also follows stackbased tal viewing stack separate unbounded resource rather designated area memory dramatically simplifies type system 18 requires second stage foundational safety proof show talt stack mapped onto concrete stack principal issue stack overflow address section 6 machinecheckable proofs talt formalized lf 13 mechanized twelf system 23 24 accordance usual lf methodology talt typing judgements correspond lf types typing rules correspond lf constants talt typing derivations correspond lf terms validity typing derivation verified type checking central importance eort type safety metatheorems progress type preserva tion gc safety expressed twelf relational form logic programs 21 22 support twelf provides totality checker 26 24 ensures relations represent total functions therefore valid metaproofs discussed detail section 5 important note decidable checking typability aim talt unlike tal talx86 talt type assignment currystyle system values contain none type annotations carry explicitly typed churchstyle systems tal means checking typability talt programs requires type inference since talts type system polymorphic means typability checking almost certainly undecidable 30 consequently safety certificate talt program entire typing derivation rather thanas talx86a collection type annotations one reconstruct typing derivation however largely matter presentation talt typing derivation contains little information would appear type annotations conjecture overhead remains eliminated using necula rahuls technique 20 paper organized follows begin section 2 presenting basic talt language section 3 present extensions supporting disjoint sums arrays relative addressing section 4 give formalization gc safety section 5 discusses pragmatics machinechecked proofs concluding remarks follow section 6 2 basic talt begin presentation basic talt language presenting untyped fragment four parts first present structure values second present machine model third discuss instruction set fourth give operational semantics following present type system throughout section remark dierences talt tal benefit readers familiar latter readers unfamiliar tal may skip remarks adopt following notational conventions w stands size machine word measured bytes 4 ia32 j k n range nonnegative integers bit ranges 0 1 b ranges bytes ie integers modulo 256 b ranges words ie integers usual consider alphaequivalent expressions identical however section identifiers registers r considered variables alphavary variables appearing talt type constructor variables unit values u b junk ai k values v u 1 addresses n cond codes cc cf bit zf bit memories register files r states h r figure 1 untyped talt syntax 21 untyped talt values tal separated collection values two syntactic classes called heap word values 2 syntactic distinction determined could fit register talt combine single syntactic class values may vary size use types rather syntax determine may used syntax typefree talt appears figure 1 values simply sequences zero unit values exactly one byte size construct values unit values ensure byte including bytes middle atomic object may addressed make easy compute size value note merely cosmetic change eliminate word values add unit values unlike tals word values unit values never objects interest used construct values convenient abuse notation also often write values form v 1 v n representing appending several values four forms value may consider atomic literal bytes b junk values addresses w bytes length instruction encodings k metavariable k ranges kbyte instruction encodings level abstraction appropriate specify possible values k instead instead assume existence decoding function k takes instruction encodings instructions discuss bit later note need injective single instruction multiple encodings need surjective literals junk values one byte size represented directly unit value con structs however addresses usually instruction encodings size greater one byte thus latter two forms unit value represents bytes taken larger atomic values ai represents ith byte address k represents ith byte instruction encoding k appropriate range constructs considered junk values rarely need deal subcomponents addresses instructions purposes k viewed value forms using abbreviations included third class called small values truly values renamed operands later work 18 called registers r r1 rn operands destinations rdestr mdestm n conditions eq neq lt lte gt gte instructions add cmp jcc jmp malloc n mov sub code figure 2 instructions also write b encoding b bytes littleendian architecture ia32 machine model like tal talt machine model contains memory register file replaces tals stream input instructions explicit program counter also augment state collection condition codes indicating carry zero flags would dicult add convenient consider part register file contained flag fl register talt register file fixed collection n generalpurpose registers r1 rn 3 tal hand assumed infinite supply registers talt memory broken sections identified section identifiers section represents area memory known contiguous distinct sections however appear unknown order memory possibly intervening gaps thus view talt memory mapping section identifiers values since values simply sequences bytes byte memory addressed subject limitations garbage collector combining section identifier numeric oset n section produce address n consider garbage collection section 4 necessary us distinguish heap collector manages remainder memory refer portions heap code segments anticipation development make remarks view segment section resides intrinsic property section may determined identifier formalized using two predicates hseg holds resides heap segment conversely cseg heap segment traced collector readwrite code segment traced readonly newly allocated sections always appear heap segment instruction set basic talt instruction set given figure 2 exception malloc implemented runtime system rather architecture 3 ia32 n 7 since stack pointer treated specially section 23 structions familiar programmer ia32 note instructions given intelstyle destination first notation note also load store instructions tal omitted replaced mov instruction used appropriate addressing modes code sequences used talt operational semantics arise type checking rules notation operands destinations novel operand imv indicates immediate operand operand rcor indicates operand contents register r contents memory obtained using operand mcom n sub operand providing address n indicates fixed oset address read indicates size operand read typically w similarly rdestr indicates destination instruction register r mdestm n indicates destination size memory address indicated operand order make talt elegant general possible eort made limit available operands operandinstruction combinations actually supported ia32 architecture example real architecture permits arbitrary chaining indirection nesting memory operands talt sizes memory reads permitted elegant include variety unsupported possibilities note unsupported instructions simply range decoding function operational semantics operational semantics given figure 3 main judgement indicating machine state steps machine state three main auxiliary judgements discuss established using auxiliary definition given figure operational semantics entirely unsurprising resolution operands formalized judgement indicates machine state operand resolves value v propagation computed results destinations formalized judgement v h r indicates machine state destination assigned value v resulting memory register file h r finally conditions conditional jump jcc handled proposition cc true condition codes cc satisfy condition points notation merit comment note arithmetic equations semantics specify condition code result well numeric result condition code results determined usual manner carry flag cf set operation generates carry borrow formally denormalized result lies outside allowable range zero flag zf set result zero map update written h v memories similarly register files map extension memories written h v fresh 22 type system types talt appear figure 4 base types b0 type zerolength value b1 type byte literals important type constructor product space 1 2 contains values consisting two adjacent values types 1 2 since appending values associative unit namely products also associative left right unit namely b0 equivalences realized collection subtyping rules note unlike tal product space contain pointers tuples talt pointer made explicit type constructor box one factor necessary combine tals heap word values since tuples pointers tuples dierent types need distinguished syntactic class tal add o1 o2 h r fl cc jcc jcc h junk n mov sub o1 o2 operand resolution destination propagation condition satisfaction definitions u1 un def z times figure 3 operational semantics kinds k types types size b0 null value b1 bytes box pointers mbox mutable pointers code code values k universal quant k existential quant ns top nonsense type void bottom empty type recursive type r f types mem types contexts figure 4 type syntax three dierent types provided pointers box type ordinary pointers mbox type mutable pointers 0 type code pointers pointer type provides dierent privileges box covariant immutable mbox mutable invariant code pointers may jumped subtyping rule provided promoting mutable pointers covariant ones series instructions given type code executable provided register file type function space 0 contains executable code pointers 0 like boxcode except pointer must point code segment universal existential quantifiers intersection types union types recursive types standard currystyle system top type ns contains value size 1 wider top types may defined exponents ns bottom type void empty several useful abbreviations including wordsized top nsw defined figure 5 two kinds talt types kind contains types sized kind contains types whose elements size example b0 belongs t0 b1 belongs belongs various pointer types belong tw uninhabited types may vacuously belong one sized kind eg b0 b1 belongs t0 t1 void vacuously belongs ti inhabited type one sized kind register file types give type register fl wellformed register file type registers type must kind tw every register must included width int ns w figure 5 type abbreviations judgement interpretation wellformed kind k wellformed wellformed subtype 2 subtype 2 propagation value type destination results register file type code executable register file type inits rmbox discussed section 222 wellformed type wellformed type wellformed figure subtyping rules need included instead registers value irrelevant may given type nsw promotion nsw done using depth subtyping heap types give type section 221 static semantics collection judgements talt static semantics given figure 6 thirteen total judgements complete set rules appears appendix a1 three judgements type formation rules unsurprising given appendix two judgements subtyping one ordinary types one register file types latter simply applies former pointwise registers type remaining judgements typing three typing values operands destina tions two typing code second auxiliary judgement typing tuple initialization code final three judgements typing machine states toplevel components since pointers may appear anywhere type pointer depends type value ns figure 7 typing rules except instructions points typing judgement except state typing 4 includes memory type part context operands destinations code also refer registers typing judgements also include register file type context talt typing rules appear figures 7 8 discussed machine states typing rules machine states essentially tal state wellformed exists memory type register file type respect memory register file program counter may consistently typed type check program counter current code looked memory program counters address type checked memorys series bytes converted code sequence function lifts instruction decode function single instructions series instructions two aspects change future developments first add second state typing 4 state typing judgement omits memory type full machine state closed although full memory also closed memory typing judgement still includes memory type part context occasionally necessary type check memory weakened assumptions rule typing intermediate states tuple initialization section 222 second decode function generalized account relative addressing section 33 values value typing rules selfexplanatory rules pointers merit dis cussion pointer oset n may given type section points elements 1 size n ie skipped oset pointers heap segment may given stronger type mbox 2 provided subtype supertype 1 2 ensures 2 written back heap object object still type heaps type unchanged value typing rules tell far entire story flexibility talt type system provided subtyping rules subtyping provides introduction facility existen tial union recursive types elimination facility universal intersection recursive types associativity identity rules products distributivity rules intersection union types void fifty subtyping rules listed appendix a1 interest brevity discuss individual rules arise operands destinations since operand may drawn register operand typing judgement includes register files type context similarly since destination may register propagation value destination change register file type hence destination typing judgement includes register file types typing rules memory operands destinations novel using associativity identity subtyping rules products 5 one casts pointers type form mbox operands type 1 3 types left right residual values sizes checked using kinds 1 must kind tn match oset 2 must kind tm match operand size note unlike register destinations memory destinations forbidden change datas type allowing changes would unsound due possibility aliasing instructions much type system moved rules operands destinations typing rules instructions given figure 8 largely expected final two rules merit comment first subtyping rule code states type checks assumptions also type checks stronger assumptions second rule elimination rule existential types register contains value existential type allows value unpacked place tal instruction unpack obtained combining mov instruction rule 222 allocation initialization complicated talt typing rule malloc newly allocated tuple begins filled junk initialized fieldbyfield tuple initialized type must change reflect new components means initialization incompatible usual rule memory writes tal provided elegant way handle using initialization flags newly allocated tuple essentially stamped ultimate type initialization must move toward ultimate type 10 addressed aliasing problem aliases could 5 although mbox invariant respect symmetric subtyping associativity identity products applied beneath mbox add jcc jmp mov figure 8 instruction typing rules except allocation weaker views tuple incompatible ones moreover since tal conflates mechanisms pointers tuples tal track initialization tuple fieldbyfield basis thus tal permits interleaving initialization computation unfortunately fieldbyfield initialization flags incompatible talt talts decoupling pointers tuples moreover flexibility aorded initialization flags appears rarely used practice therefore expedient alternative talt requires newly allocated object fully initialized computation takes place uninterrupted initialization easy maintain invariant aliases new object exist powerful account initialization could likely given using alias types 28 explored extension rules implementing mechanism appear figure 9 first rule provides object allocated pointer placed register r type checking moves special mode rs type updated r cannot used purpose latter enforced giving type nsw series initializing moves final rule used make r ordinary pointer shift back ordinary type checking mode additional ugly rule type checking machine states midst initialization appears appendix a1 expresses invariants initialization type preservation property established mov mdestm rcor n inits rmbox inits rmbox figure 9 allocationinitialization typing rules 23 stacks talt supports stacks using type mechanism essentially identical stackbased tal 18 although variety special instructions folded talts operanddestination mechanism full details appear appendix reasons brevity omit discussion stacks body paper beyond remarks since talt already notions null object concatenation objects memory need introduce special types nil stackbased tal however need special kind since stacks type must determine size talt types always eg b0b1 require kind types whose size determined though possibly unknown variables kind td kind called td rarely useful aside stacks practical purposes serves kind stack types 24 multiple entry points one facility provided talt may immediately obvious ability jump middle block code impossible tal operationally clear one jump valid address less obvious jumps welltyped suppose simplicity v code v morecode v morecode executable register file type suppose v code wish assign type 0 n type 0 possible giving type ns n makes possible structure talt code desired forward backward jumps without needing insert arbitrary breaks typing purposes importantly since executable address given type manner talt support true call instruction return address obtained program counter details call instruction appear appendix figure 10 integer ranges extensions 31 disjoint sums standard implementation disjoint sum type say int pointer tuple whose leading field tag identifying arm sum talx86 idiom supported directly special type disjoint sums talt decompose primitive components first add notion singleton type written set b containing integer b easily construct type faithfully characterizes encoding element type either pointer int following zero tag pointer intint following one tag figure gives typing rules pertinent subtyping rules set also upper lower subrange types set set useful shortly rules sucient however although type accurately expressed members disjoint sum immediately useful problem absence elimination rule union types may load tag word instructions cmpjcc neqb unsat unsat void 7 figure 11 union elimination oset 0 disjoint union since distributing box distributing promotion set int boxint int int int comparing tag zero may determine dynamically arm disjoint union object belongs however rules discussed far way take advantage information static typing way access variant constituents disjoint union make possible eliminate union types add new instruction cmpjcc operationally identical twoinstruction sequence cmp evaluation rule formalized appendix a2 special pseudoinstruction typing rule r used comparison example r type comparison mcow rcor 0 im0 using condition eq idea rule eliminate rs union type providing static proof r cannot type 2 branch taken r cannot type 1 branch skipped follows r given type 1 branch 2 nonbranch consider cmpjcc typing rule given figure 11 clauses 1 2 ensure comparison permissible indicate value compared number b event branch taken must type b sat b unsat clause 3 identifies union type interest 1 2 follows r either type 1 type retypes first operand first hypothetical circumstance thus r 1 however branch skipped must also type b unsat clause 7 proves cannot simultaneously true therefore branch skipped may conclude r type 2 clause 10 similar argument shows branch taken may conclude r type 1 clause 9 example suppose r type wish jump tag zero using cmpjcc mcow rcor 0 im0 eq first six clauses easily established using argument clause 1 set 0 set 1 remains show easy obtain first using distributivity contradiction subtyping rules set b void second observe set 1 set 0 result follows latter contradiction subtyping rule thus may continue type checking refined type r branch general case nary sums may wish caseanalyze sum using binary search execute log 2 n comparisons rather n 1 done using rule choosing inequality comparison rather equality set rule necessary use associativity union types cast nary sum form single union type one arm incompatible branching branching 32 arrays developments far talt already supports arraylike type form n nelement array however type shortcoming arrays length must known statically want something like n n first add facility quantify array length adding new form type constructor representing numbers thus far referred type constructors talts type constructors actual types must rename syntactic class types type constructors tycons short use metavariable c type constructors general continue use metavariable tycons kind use metavariable x tycons kind num terminology established add new kind num new tycon b num occasionally find convenient allow word b integer modulo 2 8w used place ordinary nonnegative integer case b interpreted canonical representative also generalize integer subrange types defined tycons kind num including variables generalize various rules dealing subranges accordingly finally add type xelement arrays x developments summarized figure 12 give type array unknown length num set mbox kinds k num tycons c x set x set x set x operands destinations imdestm figure 12 arrays since addressing modes provided far provide fixed osets tuples must also provide operand destination construct reads writes dynamically specified osets arrays purpose provide indexed memory operand form imcom similar destination form imdestm oset calculation constructs n k base address size remain thus points array element size k imco extracts oset n element array typing rules imco imdest given figure 12 operational rules given appendix a2 pseudoinstruction mallocarr provided allocate initialize arrays due space considerations discuss full details appear appendix note imco imdest include arraybounds checks typing derivation responsible showing index within allowable range typical case array bound check necessary one could add another cmpjcc rule refine integers subranges turns existing cmpjcc suces addition trichotomy rule 6 ia32 addressing modes provided primitives 8 architectures values k would need synthesized rearranging may obtain seems likely sophisticated treatment array bounds checks possible using something like xi harpers dtal 31 track dependencies various integer values explored extension time mechanizing proofs seems likely burdensome 33 relative addressing given talt machine model pcrelative addressing dicult add operationally simply add new operand form pcreln operand resolution rules type system however matters trickier relative addressing creates situation code therefore values general may certain type resides particular location least viewed naively situation undesirable two reasons first making typing rules aware locations values reside would require widescale changes type system would lessen elegance second resulting type system would unlike conventional type systems values type depend written preserve type system current form introduce technical device call delocal ization employ function deloc convert relative addresses absolute ones example deloca mcom code always type checked delocalized form typing rule need provided relative operands consequently typing rules instruction preserved without change burden delocalization assumed code typing rule values converted code sequences type checking recall rule figure 8 old first modify decode function va account delocalization second since typing rule know memory v lies permitted assume address may assume register file type records assumption type new type codea read code may executed register file type provided resides address obligation discharged typing rule code pointers admits properly delocalized pointers code pointers new note code block delocalized address resides address cannot given code pointer type change must made type system toplevel state typing rule must modified obvious manner account delocalization principal safety results talt usual progress type preservation theorem 41 progress theorem 42 type preservation progress proof induction typing derivation type preservation proof case analysis evaluation derivation outer induction typing derivation handle register file subsumption existential unpacking rules additionally since talt operational semantics account garbage collection must prove additional result showing garbage collection disrupt typability like talx86 talt designed use boehmdemersweiser conservative garbage collector 4 therefore need maintain tagging invariants order assist collector distinguishing pointers integers however one gc safety condition must maintained collector function properly 3 every live heap object must reachable chain pointers root set pointer permitted reach object pointing anywhere objects beginning end 7 root set collection values register file stack condition maintained consequence live objects may garbage collected therefore purposes define live object one whose presence required state welltyped main gc result proof garbage collecting unreachable objects cannot break typability state order satisfy gc safety condition impose following two invariants welltyped talt code 7 interior pointers permitted boehm chases specification 3 permitted collectors implementation dom cseg figure 13 modified rules gc safety 1 code segment contains nonaccidental pointers heap segment 2 immediate operands contain nonaccidental pointers heap segment invariant 1 necessary code segment part collectors root set invariant 2 stricly speaking necessary burdensome either operand part instruction code segment invariant 2 follows invariant 1 instruction useless anyway invariant imposed dramatically simplifies development since means need formalize look pointers code values invariants achieved replacing typing rules immediate operands memories rules figure 13 strip heap sections memory type typing code sections immediate operands formalize gc safety theorem need definition unreachability definition 43 suppose set heap section identifiers hreachable v v written form v 1 n v 2 n h section unreachable memory whole every section reach either untraced ie code segment unreachable definition 44 suppose set heap section identifiers unreachable h every domh either cseg hreachable h definition 45 suppose set heap section identifiers unreachable h r unreachable h every r hreachable rr hreachable rsp note definition unreachability deterministic unreachable small empty set definition crafted manner cannot predict objects actually collected conservative collector instead prove result unreachable sets thereby covering whatever collector turns theorem 46 gc safety suppose unreachable h r suppose h r proof induction typing derivation 5 machinechecked proofs results paper formalized machinechecked proofs twelf system 23 24 first step formalization encode talt syntax type system operational semantics lf signature 13 wherein judgements become types derivations become terms process standard belabor language formalized state prove principal metatheorems progress type preservation gc safety metatheorem statement encoded relation derivations 21 22 example principal metatheorem statements become progress mode progress d1 d2 preservation machineok type mode preservation d1 d2 d3 collect collect machineok type mode collect ok d1 d2 d3 instance progress theorem relation machineok derivations stepsto derivations forth mode declaration following statement indicates input output arguments relation 25 cases last argument mode sole output argument proof metatheorem encoded logic program whose type relational encoding theorem program principle given derivations input arguments unification variables output arguments executed obtain resulting derivations logic program represents valid metaproof execution always runs successful conclusion twelf totality checker verifies logic program fact total assistance programmer identifying induction variables consists checking three facts 1 mode checking output arguments input arguments subcalls fully determined 2 termination checking induction variables decrease recursive calls 3 totality checking every case analysis cases covered details reader referred pfenning schurmann 24 schurmann 26 specification talt lf consists 2081 lines twelf code complete proof theorems 41 42 46 consists 10137 lines twelf code including comments breakdown proof code interested reader given table 1 full proof takes approximately three minutes check twelf 13r3 pentium 3 128 megs ram proof components lines purpose 210 properties canonical forms 252 properties conditions properties memory lookupupdateextension instruction decode lemmas 372 properties register file lookupupdate 399 properties values 407 equality lemmas 429 properties natural number arithmetic 515 validity wellbehavedness derivations 537 canonical forms lemma 548 lemmas regarding type formation progress 713 weakening strengthening memory types operanddestination lemmas 925 type preservation 1245 properties binary arithmetic table 1 safety proof breakdown 6 conclusion talt provides elegant expressive fully formalized type system assembly language machinecheckable safety theorems section 5 provide complete safety argument talt programs terms safety policy expressed operational semantics assembly language level complete foundational tal system work must combined proof talt operational semantics maps correctly concrete architecture talt designed latter stage proof implementation typefree simulation argument talt also designed easily adaptable architectures general architectural constants bigendian vs littleendian number registers size machine word parameters language easily changed new instructions also easily added fact given generality talt operanddestination mechanism many new instructions may already present means primary burden specializing talt architecture accounting idiosyncrasies eg ia32s treatment floating point delay slots following jumps many risc architectures one issue addressed talt issue processor exceptions faults eg division zero stack overflow various floatingpoint exceptions prohibitively expensive prevent dynamically dicult prevent statically fortunately purposes safely ignored assuming occurrence exception aborts program program longer running certainly safe issue stack overflow little bit involved must ensure stack overflows cause stack overflow exception following standard practice preceding 8 stack memory least one typically many unmapped memory pages push instruction overflows stack therefore hit unmapped page cause exception salloc instruction increases stacks size arbitrary amount bit trickier could skip unmapped pages land accessible memory prevent limiting salloc one page time forcing touch top stack push ensures overflowing salloc hit unmapped page assist development talt programs also designed explicitly typed variant talt called xtalt enjoys decidable type checking xtalt adds type annotations sections replaces talts subtyping explicit coercions implementing assembler typechecks xtalt programs generates corresponding talt derivations compresses using necula rahuls technique 20 also development popcorn 17 xtalt compiler tools combined dunfields standard ml popcorn compiler 11 based rml 29 mlton 6 provide complete certifying compiler standard ml talt direct standard ml talt compiler also underway r semantic model types machine instructions proofcarrying code simple garbagecollector safety proposal garbagecollectorsafe c compilation garbage collection uncooperative environment first international workshop grid comput ing trustless grid computing concert certifying compiler java type structure lowlevel programming langauges personal communication syntactic approach foundational proofcarrying code framework defining logics second international workshop grid computing java virtual machine specification realistic typed assembly language system f typed assembly language logic programming lf logical framework implementing metatheory deductive sys tems system description twelf metalogic framework deductive systems twelf users guide mode termination checking higherorder logic programs automating meta theory deductive systems alias types ml ada stronglytyped language interoperability via source translation typability type checking system f equivalent undecidable dependently typed assembly language tr garbage collection uncooperative environment logic programming lf logical framework framework defining logics simple garbagecollectorsafety system f typed assembly language semantic model types machine instructions proofcarrying code certifying compiler java oraclebased checking untrusted software java virtual machine specification grid computing mode termination checking higherorder logic programs flowdirected closure conversion typed languages alias types syntactic approach foundational proofcarrying code type structure lowlevel programming languages stackbased typed assembly language implementing metatheory deductive systems system description ctr joseph c vanderwaart karl crary automated certified conformance responsiveness policies proceedings 2005 acm sigplan international workshop types languages design implementation p7990 january 1010 2005 long beach california usa michael f ringenburg dan grossman types describing coordinated data structures proceedings 2005 acm sigplan international workshop types languages design implementation p2536 january 1010 2005 long beach california usa adam chlipala modular development certified program verifiers proof assistant acm sigplan notices v41 n9 september 2006 hongxu cai zhong shao alexander vaynberg certified selfmodifying code acm sigplan notices v42 n6 june 2007 brigitte pientka verifying termination reduction properties higherorder logic programs journal automated reasoning v34 n2 p179207 december 2005 feng zhaozhong ni zhong shao yu guo open framework foundational proofcarrying code proceedings 2007 acm sigplan international workshop types languages design implementation january 1616 2007 nice nice france boryuh evan chang adam chlipala george c necula robert r schneck typebased verification sssembly language compiler debugging proceedings 2005 acm sigplan international workshop types languages design implementation p91102 january 1010 2005 long beach california usa feng zhong shao modular verification concurrent assembly code dynamic thread creation termination acm sigplan notices v40 n9 september 2005 andrew w appel paulandr mellis christopher richards jrme vouillon modal model modern major general type system acm sigplan notices v42 n1 january 2007 boryuh evan chang adam chlipala george c necula robert r schneck open verifier framework foundational verifiers proceedings 2005 acm sigplan international workshop types languages design implementation p112 january 1010 2005 long beach california usa juan chen dinghao wu andrew w appel hai fang provably sound tal backend optimization acm sigplan notices v38 n5 may zhaozhong ni zhong shao certified assembly programming embedded code pointers acm sigplan notices v41 n1 p320333 january 2006 dan grossman quantified types imperative language acm transactions programming languages systems toplas v28 n3 p429475 may 2006
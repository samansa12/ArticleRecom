regular languages testable constant number queries continue study combinatorial property testing initiated goldreich goldwasser ron j acm 45 1998 pp 653750 subject paper testing regular languages main result follows regular language lin 01 integer n exists randomized algorithm always accepts word w length n win l rejects high probability w modified least epsilon n positions create word l algorithm queries tildeo1epsilon bits w query complexity shown optimal factor polylogarithmic 1epsilon also discuss testability complex languages show particular query complexity required testing contextfree languages cannot bounded function epsilon problem testing regular languages viewed part general approach seeking probe testability properties defined logical means b introduction property testing deals question deciding whether given input x satises prescribed property p far input satisfying let p property ie nonempty family binary words word w length n called far satisfying p word w 0 length diers w n places satises p test p randomized algorithm given quantity n ability make queries value desired bit input word w length n distinguishes probability least 23 case w 2 p preliminary version paper appeared proceedings 40 th symposium foundation computer science department mathematics raymond beverly sackler faculty exact sciences tel aviv university tel aviv 69978 israel att labsresearch florham park nj 07932 usa email nogamathtauacil research supported usa israeli bsf grant grant israel science foundation hermann minkowski minerva center geometry tel aviv university z department mathematics raymond beverly sackler faculty exact sciences tel aviv university tel aviv 69978 israel email krivelevmathtauacil part research performed author dimacs center rutgers university piscataway nj 08854 usa att labsresearch florham park nj 07932 usa research supported part dimacs postdoctoral fellowship x department computer science university haifa haifa israel email ilancshaifaacil part research performed author visiting labs research florham park nj 07932 usa school mathematics institute advanced study olden lane princeton nj 08540 usa email szegedymathiasedu part research performed author att labsresearch florham park nj 07932 usa case w far satisfying p finally say property p c testable every 0 exists test p whose total number queries bounded c property testing dened goldreich et al 7 inspired 13 emerges naturally context pac learning program checking 6 3 10 13 probabilistically checkable proofs 2 approximation algorithms 7 7 authors mainly consider graph properties bipartiteness show among things quite surprising fact testing bipartiteness done randomly testing polynomial 1 number edges graph answering question constant probability failure also raise question obtaining general results every 0 test property using queries ie c function independent n constant probability failure call properties type testable far answers quite sparse interesting examples given 7 several additional ones obtained applying regularity lemma show subsequent paper 1 paper address testability formal languages see 8 general reference language property usually viewed sequence boolean functions f main result states regular languages testable query complexity o1 also show complexity optimal factor polylogarithmic 1 positive result cannot extended contextfree languages example simple contextfree language testable since regular languages characterized using second order monadic logic thus obtain large set logically dened objects testable 1 provide testable graph properties described logical means well results indicate strong interrelation testability logic although result regular languages viewed separate result logical bearing opinion logic provide right context testability problems may lead discovery classes testable properties rest paper organized follows section 2 present proof main result showing every regular language testable section 3 show upper bound o1 query complexity testing regular languages obtained theorem 1 tight polylogarithmic factor section 4 devoted discussion testability contextfree languages show particular exist nontestable contextfree languages also discuss testability dyck languages nal section 5 contains concluding remarks outlines new research directions testing regular languages section prove main result paper namely regular languages 1 testable result asymptotic assume n big enough respect 1 respect constant depends xed language working logarithms binary unless stated explicitly otherwise start recalling standard denition regular language based nite automata denition convenient algorithmic purposes denition 21 deterministic nite automaton dfa f0 1g states given function set f q one states q 1 called initial state states belonging set f called accepting states called transition function extend transition function f0 1g recursively follows let denote empty word thus starts state q processes string u ends state q u say accepts word u q rejects u means q 1 finally language accepted denoted lm set u 2 f0 1g accepted use following denition regular languages denition 22 language regular exists nite automaton accepts therefore assume section regular language l given automaton word w length n denes sequence states q following natural way q 1 j n sequence describes automaton moves reading w later paper occasionally refer sequence traversal path w nite automaton denes directed graph gm v g period gg directed graph g greatest common divisor cycle lengths g g acyclic set use following lemma directed graphs lemma 23 let e nonempty strongly connected directed graph nite period gg exist partition v exceed 3jv j 2 1 every 0 1 every length every directed path u v g j mod 2 every 0 1 every every integer r mod g exists directed path u v g length r proof prove part 1 x arbitrary vertex z 2 v 0 g 1 let v set vertices reachable v directed necessarily simple path length g note since closed directed walk g disjoint union cycles length walk divisible g implies sets v pairwise disjoint indeed assume false suppose w lies v v j 6 j g strongly connected path p 1 w z denition path p 2 length mod g z w well path p 3 length mod g z w number edges either 3 divisible g impossible therefore sets v form indeed partition v union directed path z u directed path u v forms path z v path must length j mod g assertion part 1 follows next prove part 2 consider set positive integers fa g whose greatest common divisor g well known smallest number every integer divisible g linear combination nonnegative integer coecients numbers moreover known see 9 5 smaller square maximal number fix closed directed walk g visits vertices whose length jv j 2 easily obtained numbering vertices g arbitrarily concatenating directed paths v v i1 0 k 1 indices taken modulo k associate set cycle lengths walk set positive integers fa g following closed walk traversing directed cycle many times desired conclude every integer divisible g exceeds 2jv j 2 length closed walk passing vertices graph given vertex integer r 3jv j mod g x shortest path p u v note length l satises l j mod g l jv j jv j 2 adding p closed walk length r l v obtain required path completing proof 2 call constant lemma reachability constant g denote mg sequel assume divisible g lm f0 1g testing algorithm reject input without reading therefore assume nontrivial case lm f0 1g n 6 introduce key denition sequel denition 24 given word w 2 f0 1g n subword run w 0 w starting position called feasible language lm exists state q 2 q q reachable q 1 g exactly steps path length n jw g state q w 0 least one accepting states otherwise w 0 called course nding infeasible run w proves w 62 l aim show given word w length n far word length n l many short runs w infeasible thus choice small number random runs w almost surely contains infeasible run first treat following basic case denition 25 call automaton essentially strongly connected 1 unique accepting state q acc 2 set states automaton q partitioned two parts c subgraph gm induced c strongly connected edges gm go c edges go c note may empty lemma 26 assume language contains words length n essentially strongly connected c partition states denition 25 let reachability constant gc assume also n 64m log4m word w length exists integer 1 log4m number infeasible runs w length 2 i1 least 2 4 n proof intention construct sequence r j j1 disjoint infeasible runs minimal sense prexes feasible subword given word w show concatenate subwords form word language far w far essentially depend number runs constructed turn show distw l n lower bound number infeasible runs reasons become obvious later also want runs interval natural way construct sequence repeat following procedure starting 1 shortest infeasible run starting wm 1 ending run stop assume constructed ending wc j 1 next construct r j taking minimal infeasible run starting wc ending wn 1 run stop assume constructed way runs r 1 r h note run subword w runs pairwise disjoint concatenation order forms continuous subword w also note denition run r j minimal infeasible prex r obtained discarding last bit r j feasible turn implies r 0 j obtained r j ipping last bit feasible addition denition 24 means r 0 state q j reachable q 1 c next inductively construct word w 2 l distw w hm 2m 2 assuming distw l n imply lower bound h general idea glue together r 0 h feasible yet close subword w except last bit concern glue pieces together whole word feasible require extra change bits per run plus additional 2m bits end word maintain induction construct feasible starting position 1 ends position c j base case let c word length feasible starting position 1 assume already dened word w position 1 ending position c j 1 let q p j q j reachable q 1 path length c j 1 according lemma 23 change last bits w j 1 get word u j q 1 dene w j concatenation u j r 0 let w h nal word dened way ending place c h reason stopped r h either infeasible run starting c h 1 case changing last bits w h concatenating remaining sux w starts position c h exactly case adding r 0 yields required w possible reason stopping growing r h minimal infeasible run start c h ends position n 1 let r run let r 0 run obtained ipping last bit r case r 0 feasible position c h 1 hence feasible word u r 0 prex u length q h construct w w h u exactly constructed w form w h sux w previous case denition w w 2 l following inductive construction w follows 1 get w h w concatenate r 0 either subword w rst case previously discussed subword w one bit changed second case following changing bits end w h possibly additional bits end u therefore distw w hm 2 claimed recalling distw l n conclude h n 2 last inequality assumptions n 64m log4m already shows distw l n n many disjoint infeasible runs w however need stronger dependence stated lemma achieve following way let log4m 1 denote number runs fr j g h whose length falls interval 2 p h n4m n4m therefore exists index n4am consider infeasible runs r j jr run contains infeasible subrun infeasible infeasible run length 2 contained least runs length 2 i1 except maybe rst two last two runs two smallest js two largest js r j disjoint infeasible run length contains three r j length least 2 1 thus get total least runs length 2 i1 assumption parameters number log4m claimed 2 aim reduce general case described case given dfa graph cg graph components g whose vertices correspond maximalby inclusion strongly connected components g whose directed edges connect components g connected edge g note vertices cg may represent single vertices g self loops belong strongly connected subgraph g least two vertices components non empty paths inside called truly connected reserve k number vertices cg set may assume vertices g reachable initial state q 1 cg acyclic graph exists directed path component c 1 containing q 1 every component runs truly connected components g corresponding vertices cg assume sequel following relation satised parameters condition 2k 64m log 8mk log1 1 clearly xed k l small enough n large enough condition holds next step describe word w 2 lm length n move along automaton word w belongs l traverses g starting q 1 ending one accepting states accordingly w traverses cg starting c 1 ending component containing accepting state reason call path cg admissible starts c 1 ends component accepting state given admissible path cg sequence pairs vertices g states called admissible sequence portals satises following restrictions 1 every 1 j 2 3 accepting state 4 every 2 j one p 2 idea behind denition admissible portals simple given admissible path admissible sequence p portals denes word w 2 l moves one strongly connected component next one starting initial state q 1 ending accepting state rst last states traversed c j given admissible path corresponding admissible sequence p portals say increasing sequence integers forms admissible partition respect p following holds 1 2 every 1 j exists path p 1 j p 2 length n j1 3 meaning partition j1 follows w 2 l w traverses accordance value n j indicates w arrives component c rst time n j bits convenience also set n 1 thus 1 j word w stays c j interval n possible principle given admissible path corresponding admissible sequence portals p corresponding admissible partition could happen path set portals p correspond word length n triplet admissible path p corresponding admissible sequence portals corresponding admissible partition called admissible triplet clear denition admissible triplet word w 2 l traverses g accordance scenario suggested one admissible triplets therefore order get convinced w 62 l enough check w admissible triplet fix admissible triplet dene language l j contains words traverse p 1 j p 2 done formally dening automaton j follows set states j obtained adding new state f j initial state j unique accepting state p 1 respectively 2 f0 1g q set j namely j transitions within c remain transitions going components go f j loop thus j essentially strongly connected denition 25 g l j language accepted j given xed admissible triplet word w length subwords setting note jw namely w path according partition substring w j corresponds portion traversal path w lies within component c lemma 27 let admissible triplet let w word length n satisfying distw l n dene languages l words w described exists index j 1 j distw k proof assume case let j1 partition recall k every word length n j1 n j 1 empty word also 1 j 1 choose j 2 f0 1g p 2 j1 construction word w belongs l distw w contradictionnow present key idea proof ideally would like test whether input word w length n ts admissible triplet positive case ie w 2 lm traversal path w denes naturally admissible triplet w obviously negative case ie distw l n lemma 27 implies every admissible triplet p least one subwords w j far corresponding language l j lemma 26 w j contains many short infeasible runs thus sampling small number random runs catch one high probability however problem total number admissible triplets clearly depends n makes task applying directly union bound probability catching infeasible run impossible circumvent diculty following way place evenly bounded number depending parameters transition intervals bounded length postulate transition components cg happen inside transition intervals show w 2 l modied slightly meet restriction whereas distw l n choice admissible triplet w far tting number admissible triplets consideration bounded function apply union bound estimate probability failure recall runs truly connected components g corresponding vertices cg let log1 place transition intervals s1 evenly n length transition interval jt algorithm input word w length 1 1 log8km choose r random runs w length 2 i1 2 admissible triplet j1 2 j one following form automata j 1 j described discard chosen runs end begin place p jp n j j n128km log1 namely runs one ends closer n128km log1 remaining run r r falls n j n j1 check whether feasible automaton j starting b n rst coordinate r w namely place r starts relative n j place w enters j 3 admissible triplet checked runs turned feasible output yes otherwise ie case admissible triplets least one infeasible run found output lemma 28 distw l n algorithm outputs probability least 34 w 2 l algorithm always outputs yes proof proof contains two independent parts rst consider case input w distw l n algorithm answer high probability part treats case w 2 l algorithm answer yes let us rst assume distw l n number admissible triplets partition points fall union transition intervals estimated rst choose admissible path cg number admissible paths 2 k subset vertices cg denes one path spanning choose portals total number chosen portals 2k therefore jv j 2k possible choices portals xed sjt j choices n j 2 j k satisfying condition expression 1 2k thus need check 1 2k admissible triplets let admissible triplet satisfying restriction formulated step 2 algorithm write triplet denes automata languages l described lemma 27 1 j one n2k lemma 26 exists 1 log8km contains least 2 4 n2km log8km runs length 2 i1 may touch last bits interval n 1 may touch rst bits interval hence least 2 6 nkm log1 2 touch neither rst last n128km log1 bits interval obviously random sample contains one infeasible runs provides certicate fact w admissible triplet random sample r runs length 2 i1 misses infeasible runs probability 2k thus union bound conclude case random sample contain witness feasible triplet probability 14 completes proof case distw l n address case w 2 l need show case algorithm answers yes enough show w 2 l exists admissible triplet passes successfully test algorithm traversal w naturally denes triplet follows components cg ordered according order traversal w rst resp last state c visited w set rst time w enters traversing however partition necessarily meet requirement stated step 2 algorithm true traversal w transitions c j c j1 might occur outside transition intervals show desired triplet obtained actual triplet modifying third component modied triplet would correspond dierent word w quite close w makes transitions inside postulated transition intervals addition take care query made bits w 0 diers w hence algorithm actually consistent fact reason discarding runs close n j step 2 algorithm intuitively done follows assume n j transition interval either make traversal longer end p 2 transition interval shorten traversal c enter transition interval depending closest transition interval formally done follows dene new partition choose transition interval closest n j c truly connected component choose n 0 j leftmost coordinate satisfying following restrictions n 0 singleton without loops set n 0 n 0 exists finally set note obtained triplet truly connected exists path p 1 j p 2 length n j1 n j 1 also exists path length n 0 j 1 implies admissibility 0 hence admissibility let r run w inside n 0 j1 n128km log1 let b rst coordinate since placed transition intervals ft g evenly n jn 0 therefore r falls also completely inside n remark point purpose discarding marginal runs step 2 algorithm achieve one remaining runs fall completely within n 0 j1 also within see immediately guarantees r feasible corresponding automaton j without deletion positive probability one sampled runs r may start place w c end place w c j thus making impossible attribute r one particular automaton j therefore positive probability algorithm would fail positive case discarding marginal runs allows us get onesided error algorithm w 2 l exists state q 2 c q r 2 c also q reachable p 1 initial state c steps b rst coordinate r according choice n 0 j period c lemma 23 q reachable p 1 steps shows r feasible j starting b n 0 1 thus w 2 l algorithm always outputs yes 2 finally number bits w queried algorithm log8km x log8km x thus proven following theorem theorem 1 every regular language l every integer n every small enough 0 exists onesided error testing algorithm l f0 1g n whose query complexity c log 3 1 constant c 0 depends l nal note dependence complexity parameters place proof considered xed algorithm tailored xed given language however calculation kept dependence query complexity parameters explicit one take mind though estimates hold condition holds particular require third item 1 another note running time algorithm rather query complexity dominating term step 1 rst two subsets step 2 algorithm query complexity last substeps run checked j check involves checking whether word u word v suitable lengths urv 2 l checking whether u v done directly lemma 23 case length u v longer checking words one shorter 3 lower bound regular languages many testability questions quite natural expect lower bound order 1 query complexity testing usually proven taking positive example size n perturbing randomly chosen n places create negative instance hard distinguish positive one regular languages exception respect shown next proposition fairly simple proof proposition 1 let l regular language alphabet f0 1g dened 1g n test l f0 1g n query complexity least 1 3 proof proof based following reformulation renowned principle yao 14 saying exists probability distribution union positive negative examples deterministic testing algorithm query complexity correct probability less 23 input randomly chosen according distribution lower bound query complexity randomized testing algorithm dene distribution set positive negative instances length n follows word gets probability 12 next partition index set 1 n size n 1 give probability 12t vector created 1 n ipping bits 1 0 note disty negative instances apply mentioned principle yao let deterministic testing algorithm query complexity incorrect word 1 n already incorrect probability least 12 otherwise accept input tested bits equal 1 therefore accepts well least inputs shows gives incorrect answer probability least d2t 13 implying t3 2 main idea proof proposition used get lower bound query complexity testing nontrivial regular language natural denition nontrivial proven next proposition somewhat paradoxical feature proof main positive result theorem 1 proof used get negative result language l let l denition 31 language l nontrivial exists constant 0 0 1 innitely many values n set l n nonempty exists word w 2 f0 1g n distw l n 0 n proposition 2 let l nontrivial regular language suciently small 0 testing algorithm l requires queries proof proof essentially generalization proof proposition 1 thus present somewhat abridged form let n large enough assume l n 6 w 2 f0 1g n distw l n 0 n may clearly assume constant 0 small needed purposes main result theorem 1 proof imply probability least 23 random choice set runs built described step 1 testing algorithm theorem 1 total length algorithm reject w noticed testing algorithm one sided error ie always accepts word l thus choose random set runs cause reject w probability 23 coincide word u 2 l n otherwise would reject u random set runs random set intervals ng length dened step 1 testing algorithm total length bounded two random sets intersect probability n therefore choose n subsets random expect 2 n pairs intersect 23 members reject w implies exists family disjoint sets runs member word l n coincides w set fix 0 let 0 small enough compared 0 partition family cardinality n constant c depends 0 thus independent let u word l n 1 word w obtained u changing bits u corresponding w follows indeed transform w word l n least one bit changed every member proof proposition 1 dene probability distribution union positive negative examples word u gets probability 12 one words w probability 12t simple argument essentially identical proof proposition 1 shows deterministic algorithm needs query least 3 bits input word successful probability least 23 dened probability distribution applying yaos principle get desired result 2 4 testability contextfree languages essentially completed analysis testability regular languages quite natural try make one step address testability much complex class contextfree languages see eg 8 background information turns general situation changes drastically compared case regular languages show exist quite simple contextfree languages testable turn attention one particular family contextfree languages socalled dyck languages prove rst language family testable time polynomial 1 languages family already nontestable relevant denitions proofs follow 41 contextfree languages nontestable already mentioned contextfree languages testable proven following proposition theorem 2 testing algorithm contextfree language reversal word w requires n queries order error 13 proof let n divisible 6 dene distribution union positive negative inputs following way negative instance chosen uniformly random among negative instances ie words w 2 f0 1g n distance least n l refer distribution n positive instances generated according distribution p dened follows pick uniformly random integer k interval n6 select positive example uniformly among words vv r uu r k finally distribution inputs dened follows probability 12 choose positive input according p probability 12 choose negative input according n note positive instance actually pair k w word w may generated using dierent ks use mentioned yaos principle let deterministic testing algorithm l show maximum number queries n expected error respect least 1 algorithm view binary decision tree node represents query certain place two outgoing edges labeled 0 1 represent possible answers leaf represents end possible computation labeled positive negative according decision algorithm tracing path root node associate node pair q ng set queries input word f vector answers received algorithm may obviously assume full binary tree height thus 2 leaves jq leaf use following notation subset q ng function f f qg f qg set negative resp positive instances length n consistent pair q f also probability distribution set binary strings length n subset dene pr w2e pr w set leaves labeled positive let 0 set leaves labeled negative total error algorithm distribution pr theorem follows following two claims 41 every subset q ng cardinality pr e q f 42 every subset q ng cardinality n every function f pr based claims 41 42 estimate error algorithm pr theorem follows 2 present proofs claims 41 42 proof claim 41 notice rst l 2 n2 n2 words length n rst choose word length n2 cut two parts v u thus getting word number words length n distance less n l jl f0 1g n j log1n get follows denition pr e q f proof claim 42 follows denition distribution word w 2 lf0 1g n pr recall f set words l consistent f set queries q hence pr observe pairs places q two choices k pair symmetric respect k n2 k implies n6 2 choices k set q contain pair symmetric respect k n2k k therefore pr concluding remark subsection would like note next subsection theorem give another proof fact contextfree languages testable showing nontestability dyck language 2 however preferred give theorem 2 well due following reasons first language discussed theorem 2 simpler natural dyck language 2 secondly lower bound theorem 2 better theorem 4 proofs two theorems many common points reader may view theorem 2 warmup theorem 4 42 testability dyck languages would extremely nice determine exactly contextfree languages testable present seem far fullling task however able solve question completely one family contextfree languages called dyck languages integer n 1 dyck language order n denoted n language alphabet 2n symbols grouped n ordered pairs language n dened following productions 2 3 denotes empty word though words n binary according denition easily encode grammar describing using 0s 1s thus may still assume framework languages binary alphabet interpret n language n distinct pairs brackets word w belongs n forms balanced bracket expression basic well known language family 1 one pair brackets dyck languages play important role theory contextfree languages see eg 4 relevant discussion therefore task exploring testability interesting rst goal subsection show language 1 testable let us introduce suitable notation first sake simplicity denote brackets assume n large enough even number obviously odd n 1 f0 1g nothing test case let w binary word length n 1 n denote xw number 0s rst positions w also yw stands number 1 0 rst positions w following claims 43 word w belongs 1 following two conditions hold xw proof follows easily denition 1 example induction length w omit detailed proof 2 proof observe rst claim 43 word w 1 partition letters pairwise disjoint pairs left letter pair zero right letter one consider bipartite graph whose two classes vertices set indices set indices respectively connected assumption defect form halls theorem graph contains matching size least yw n 1 assumption b yw n n2 2 2 therefore least n2 2 2 1 disjoint pairs letters w pair zero left one right let us pair remaining elements w arbitrarily pairs one consist either two 0s two 1s changing needed left entry pair 0 right entry 1 obtain word 1 total number changes performed 2 completing proof 2 1 n one yw xw distw 1 s2 b proof follows immediately claim 43 2 conclude three claims word w far 1 coordinate deviates signicantly necessary sucient conditions provided claim 44 observation used analysis algorithm testing 1 proposed c 0 suciently large constant whose value chosen later assume even integer follows omit oor ceiling signs simplify presentation algorithm input word w length 1 choose sample bits following way bit w independently probability choose contains yes without querying bit else 2 dists 1 f0 1g 0 lemma 46 algorithm outputs correct answer probability least 23 proof already mentioned set proof contains two independent parts rst prove algorithm correct probability second part prove algorithm bounded error words w distw 1 n consider rst positive case w 2 1 set assume simplicity well nt integers 1 j let x j number 0s sampled interval 1 njt let also j denote number 1s sampled interval x j j binomial random variables parameters xw njt p yw njt p respectively w 2 1 get claim 43 xw njt yw njt implying ex j ey j applying standard bounds tails binomial distribution obtain note ez j npt using similar argumentation get w 2 1 claim 43 xw hence finally following estimate distribution sample size jsj choosing c large enough recalling denition derive 14 probability least 23 following events hold simultaneously 1 2 3 x np 4 jsj np assume four conditions satised claim dists 1 indeed rst two conditions guarantee 1 jsj ys xs 22npt 23 last two conditions provide xs jsj ys therefore claim 44 algorithm accept w probability least 23 required ends rst part proof let us consider negative case assume distw 1 f0 1g n n claim 44 least one following two conditions holds exists index 1 n yw xw n2 b xw n yw n n2 former case let x number 0s 1s respectively sampled interval 1 let also k number elements 1 chosen binomially distributed parameters xw p yw p respectively follows denition ey ex np2 choosing constant c suciently large recalling denitions p see probability 16 ys follows claim 45 xw n yw n n2 obtain using similar arguments probability made 16 choice c xs jsj ys jsj 2 follows claim 45 dists 1 thus cases obtain algorithm accepts w probability 16 addition algorithm may accept w cases rst item algorithm however equation 4 may bounded 16 choosing c rst part hence algorithm rejects w probability least 23 completes proof lemma 46 2 lemma 46 following result testability dyck language 1 theorem 3 every integer n every small enough 0 exists testing algorithm query complexity c log1 2 absolute constant c 0 reader possibly noticed one signicant dierence algorithm section 2 testing regular languages algorithm testing 1 algorithm testing regular languages onesided error algorithm section twosided error coincidence show onesided error algorithm testing membership 1 whose number queries bounded function indeed assume onesided error algorithm testing 1 consider execution input word easy see distu 1 n therefore must reject u probability least 23 fix sequence coin tosses makes reject u denote q corresponding set queried bits u claim jq1 n2nj n2 n exists word w length n 1 2 q prove claim may clearly assume jq 1 n2 follows take rst n indices 1 n2 set last n indices 1 n2 sucient condition membership 1 given claim 43 indeed point j 1 n2 n number 0s rst j bits w least large number 1s also j n2 therefore w 2 1 assumed onesided error algorithm always accept every must jq 1 n2 queries linear n number bits proven following statement proposition 3 onesided error test membership 1 queries n bits words length n next goal prove dyck languages namely k k 2 nontestable present detailed proof statement 2 clearly implies result k 3 sake clarity exposition replace symbols denition 2 respectively 2 dened following contextfree empty word mind mentioned bracket interpretation dyck languages sometimes refer 0 2 left brackets 1 3 right brackets note use encoding 2 language f0 1g rather alphabet size 4 clearly nontestability 2 dened imply nontestability binary encoding 2 obtained xed binary encoding f0 1 2 3g theorem 4 language 2 testable proof let n large enough integer divisible 8 denote l using yaos principle assign probability distribution inputs length n show deterministic algorithm probing bits outputs incorrect answer probability 05 o1 positive negative words composed three parts rst sequence matching 01 brackets rst kind followed sequence 02 left brackets sequence 13 right brackets positive instances generated according distribution p follows choose k uniformly random range given k word length n length n 2k generated choose vi random 0 2 set vn 2k1 negative instances chosen follows process similar positive case except restriction vn 2k 1 namely choose k random range given k word length n length n 2k generated choose vi random 0 2 choose vn 2k 1 random 1 3 let us denote n distribution stage note words generated may distance less n l n fact words l n generated hence condition n event word distance least n l n probability distribution inputs length n dened choosing probability 12 positive instance generated probability 12 negative instance chosen according described process 47 probability instance generated according n nclose word l n exponentially small n proof fix k let word length n generated n xed k three parts w rst part matching 01 length 2k second part random sequence 02 length n 2kand third part random sequence 13 length n 2k let us denote three disjoint sets indices w bound number words w length n form 2kwhich distance n l n first choose value w n 2 gives 2 n 2kpossibilities choose n bits w changed get word l n n choices set bits 4 n possibilities point part w still set value n 3 allowed use right brackets 1 3 word obtained belong l n easy see one way complete current word word l n using right brackets hence number words altogether 2 n 2k total number words w form 0 word gets probability distribution n therefore probability word chosen according n nclose l n estimated n4 n2n n small enough 0 promised 2 xed set places let k chosen uniformly random range n8 n4 contains pair j symmetric respect n 2k2 probability 8 n proof distinct pair unique k symmetric respect point hence probability bounded 8 return proof theorem 4 let algorithm testing l n queries queries may assume nonadaptive namely queries xed set places size every adaptive made non adaptive querying ahead 2 possible queries dened two possible branchings adaptive query look queries possible set answers f input event w consistent f let nosym event contains symmetric pair respect n 2k2 also let f 0 denote f algorithm answers let f 1 f answers yes finally denote w positive w negative events random w positive instance negative instance respectively total error algorithm however given contains symmetric pairs xed f probf w w negative essentially equal probf w w positive probabilities would exactly equal negative w would generated according n claim 47 asserts n exponentially close real distribution negative instances hence probabilities 05probf w jnosym o1 plugging sum using claim 48 get error probability bounded probnosym f 05 o1probf w jnosym 1 8 concluding remarks main technical achievement paper proof testability regular languages possible continuation research describe classes testable languages formulate sucient conditions contextfree language testable recall theorem 2 shown contextfree languages testable one natural ways describe large classes testable combinatorial properties putting restrictions logical formulas dene particular restrict arity participating relations number quantier alternations order logical expression rst order second order etc result present paper example approach since regular languages exactly expressed second order monadic logic unary predicate embedded linear order another example found sequel paper 1 addresses testability graph properties dened sentences rst order logic binary predicates complements class graph properties shown testable goldreich et al 7 analogous results predicates higher arities would desirable obtain technical diculties arise arity greater two long term goal propose systematic study testability logically dened classes since many dierent types logical frameworks known nd one suited study challenge virtually single problems looked far perspective captured general logically dened class members testability properties dierent avenue try develop general combinatorial techniques proving lower bounds query complexity testing arbitrary properties possibly nding analogs block sensitivity 12 fourier analysis 11 approaches decision tree complexity present candidates combinatorial conditions would necessary sucient testability acknowledgment would like thank oded goldreich helpful comments also grateful anonymous referees careful reading r proof veri proof conjecture erd property testing connections learning approximation introduction automata theory bound solution linear diophantine problem new directions testing degree boolean functions real polynomials robust characterization polynomials applications program testing probabilistic computation tr ctr michal parnas dana ron ronitt rubinfeld testing membership parenthesis languages random structures algorithms v22 n1 p98138 january beate bollig large lower bound query complexity simple boolean function information processing letters v95 n4 p423428 31 august 2005 beate bollig ingo wegener functions readonce branching programs quadratic size necessarily testable information processing letters v87 n1 p2529 july eldar fischer strength comparisons property testing information computation v189 n1 p107116 25 february 2004 eldar fischer eric lehman ilan newman sofya raskhodnikova ronitt rubinfeld alex samorodnitsky monotonicity testing general poset domains proceedings thiryfourth annual acm symposium theory computing may 1921 2002 montreal quebec canada eli bensasson prahladh harsha sofya raskhodnikova 3cnf properties hard test proceedings thirtyfifth annual acm symposium theory computing june 0911 2003 san diego ca usa alon testing subgraphs large graphs random structures algorithms v21 n34 p359370 october 2002 eldar fischer ilan newman ji sgall functions readtwice constant width branching programs necessarily testable random structures algorithms v24 n2 p175193 march 2004 alon asaf shapira every monotone graph property testable proceedings thirtyseventh annual acm symposium theory computing may 2224 2005 baltimore md usa asaf shapira combinatorial characterization testable graph properties regularity proceedings thirtyeighth annual acm symposium theory computing may 2123 2006 seattle wa usa alon asaf shapira testing subgraphs directed graphs proceedings thirtyfifth annual acm symposium theory computing june 0911 2003 san diego ca usa alon asaf shapira characterization easily testable induced subgraphs proceedings fifteenth annual acmsiam symposium discrete algorithms january 1114 2004 new orleans louisiana
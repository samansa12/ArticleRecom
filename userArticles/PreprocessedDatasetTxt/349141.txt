threadaware debugger open interface threads become accepted standardized model expressing concurrency exploiting parallelism sharedmemory model debugging threads still poorly supported paper identifies challenges debugging threads offers solutions contributions paper threefold first open interface debugging extension thread implementations proposed second extensions threadaware debugging identified implemented within gnu debugger provide additional features beyond scope existing debuggers third active debugging framework proposed includes languageindependent protocol communicate debugger application via relational queries ensuring enhancements debugger independent actual thread implementations partial complete implementations interface debugging added thread implementations work unison enhanced debugger without modifications debugger sample implementations interface debugging shown adequacy userlevel threads kernel threads mixed thread implementations providing extended debugging functionality improved efficiency portability time b introduction threads become accepted abstraction concurrency using sharedmemory programming paradigm provide means exploit parallelism sharedmemory multiprocessor environment today many thread implementations adhere posix threads pthreads standard 21 denes common application interface api exhibit functionality threads pthreads standard describes semantics terms observable behavior api excludes constraints implementation choices hence pthreads implementations range userlevel libraries 14 17 via mixedmode threads 16 20 8 kernellevel implementations 2 22 1 11 software development threaded programs facilitated adhering pthreads api level program design implementation testing debugging stage however lacks support threaded appli cations motivation special testing debugging tools given number properties distinguish multithreaded programs singlethreaded ones 1 control ow threads may interleave even execute parallel 2 threads may suspend resume execution voluntar ily due preemption result events signals 3 synchronization threads denes partial order program execution debugging process takes least 50 development eort together testing aected threaded programs several ways 7 following issues illuminate common problems conventional breakpoint debugging suce capture single ow control program programmer accustomed follow control ow one thread two consecutive breakpoints within thread hit threads may executing breakpoints furthermore breakpoint subroutine called dierent threads may hit sequence dierent threads time state threads synchronization objects visible debugging due lack debugger formation however state information would vital allow inferences execution stage program progress relative partial order synchronization thread scheduling cannot controlled debug ger may however desirable forcibly suspend resume execution selected threads identify problems application reducing interference ensuring reaction threads respectively thus threadaware debugger provide following features address issues facilitate debugging threads threadspecic breakpoints stop application certain thread reaches breakpoint status inquiries threads synchronization objects show progress execution current state objects scheduling control provides means forcibly suspend resume threads scheduling breakpoints halt application upon context switch serve means track interleaving execution threads work described paper also aims providing exible platform debugger variety thread implementations support threadaware debugging instead customizing debugger thread imple mentation common framework controlling threads provided communicates threads ap plication thread implementation hand provides standard interface debugging serve requests debugger approach several advantages portability ensured open interface debugging threads one side functional extensions debugger side former requires thread implementations support interface providing least part functionality assume particular api thread implemen tations eg posix compliance optional latter independent actual thread implementation remains unchanged regardless extend support open interface source language application extensibility guaranteed communication interface debugger threaded applica tion interface denes query language actual messages allow addition new functionality new messages future without changes communication interface either side flexibility provided partial support instead full functionality interface debugging threads debugger remains functional provides less information less control threads part interface debugging threads exists allows partial implementations debug interface certain information available accessible eg kernel threads prohibit ac cesscontrol threads optional invocation allows application run without thread debugging support executable may used debugging needed thread debug support dynamically loaded addon library upon activation debugger technical issues features presented detail description design implementation threadaware debugger interface debugging threads paper structured follows section 2 gives overview design section 3 describes open interface debugging threads whose implementation depend thread implementation section 4 introduces thread debug interface common implementations section 5 presents communication structure debugger application section 6 summarizes extensions debugger section 7 describes implemen tation section 8 lists extended commands threadaware debugging section 9 discusses related work finally presents conclusions 2 design overview components framework threadaware debugging comprise two executable components two inter faces executable components application one side debugger side since application assumed multithreaded also utilizes thread implementation debugger includes enhancements threadaware debugging communication application interfaces consist thread debug interface tdi thread extensions debugging ted tdi includes query language interpreter provides communication interface debugger application ted comprises open interface debugging threads thin layer actual thread implementation separation tdi ted design choice aiming separating generic parts framework tdi nongeneric parts depend actual thread implementation ted without distinction interfaces tdi threadaware debugger would need modied time support new thread implementation added figure 1a depicts case tdi includes interface components thread implementation interface components would required extract internal information thread implementation transform normalized representation even threads api restricted posix threads depicted components data structures eg pthread would dier one implementation next requiring interface components mediator turn forces rebuild 2 n tdi coding decoding pthreads implementation n pthreads implementation 1 pthreads implementation 2 posix threads api threads implementation threads implementation threads implementation 1 2 ntedimpl 2 tedimpl n tedimpl tdi generic debugger ted tedaccess debugger nongeneric design b generic design figure 1 design options encapsulation tdi time support new thread implementation added figure 1b shows better encapsulation chosen im plementation tdi uses generic interface ted component ted provides access internals thread implementation ie ted implementationdependent part since ted provides thin layer reduces amount implementationdependent code considerable compared figure 1a tdi implementation dependent ted miss ing ted also provides opportunities integrate nonstandard thread implementations since abstraction thread api occurs early nongeneric approach requires adherence certain thread interface tdi level encapsulation tdi ted also provides means active debugging active debugging application enhanced special routines may provide collect information state perform manipulations executing application approach facilitates speeds debugging process passive debugging probes application instead extensions debugging application side debugger enhanced contain knowledge thread implementation table 1 compares active passive debugging generally debuggers extract information application using procedural approach probing data even data may later processed within debugger dierent paradigm active debugging allows preprocessing application side communicate data following arbitrary paradigm eg using declarative paradigm given paper encapsulation tdi ted hides implementation details threads enhance portability discussed addition tdi maintains database applications state queries database performed uniform extensible query language furthermore requests state distinct objects debugger clustered optimized remove redundan cies result declarative query interface performs better procedural interface information request would require separate action debugger postmortem debugging ie debugging core les prematurely terminated execution application provides support debugging threads passive case active debugging work postmortem debugging since program longer executable hence ted functionality cannot utilized 3 thread extension debugging objective ted layer provide uniform access implementationdependent thread structures basic primitives manipulate sets within tdi realize uniform method access information information either extracted directly thread implementation api supports direct access extracted extension thread implementation debugging example thread within application state similar process may running ready blocked termi nated 1 threads api however may provide access internal state thread nonstandard function 1 implementation actually distinguishes cause blocking thread may blocked mutex condition variable timer object due suspension unspecied reason issue active debugging passive debugging details thread implementation known de bugger must known debugger changeadd new thread impl changes debugger debugger must enhanced extract info application declarative approac procedural approac query overhead lower redun dancies higher redundant requests postmortem thread debugging possible possible table 1 active vs passive debugging access state thread added case provide required access state translated standard encoding dened ted uniform thread implementations ted provides access functions attributes common signature simplify unify access internal data structure functions reading sr writing sw domains domtda domain objects addresses da allow arbitrary values associated objects later inquiries 2 objects active passive entities threads imple mentation threads mutex objects condition variables objects common entity accessed using set operations either mapped onto threads api onto functions serve debugging extensions api access internal structures example set threads within application may accessible threads api commonly exists internal data structure access functions utilized ted mutex objects hand typically linked set mutex objects maintained ted level purpose callouts thread implementation ted layer upon object creation provide means register objects common set within ted callouts part modications thread implementation ensure debugging support ted also supports relations objects created revoked certain events occur upon occurrence event callback thread implementation updates relation let dt dm dcv domains threads mutexes condition variables respectively following relations may hold see figure 2 1 ownedbyfthreadiddt mutexiddm g 2 blockedon fthreadiddt mutexiddm g 3 waitfor fthreadiddt condvariddcv g 4 signaledbyfcondvariddcv mutexiddm g relations 1 3 cardinality 1 n ie thread may multiple mutexes multiple threads may blocked mutex may wait condition vari able relation 4 cardinality one mutex may associated condition variable threads blocked time cardinalities supported well eg mit threads n model allows threads blocked condition variable even used dierent mutexes suspending notice n cardinalities would require 2 implementation tdo substituted tda since objects uniquely identied addresses simplies mapping even address selfn 1 blockedon signaledby waitfor ownedby address self priority state user function thread condtion variable address self mutex figure 2 booch class diagram object classes object classes since scalar attributes currently support ted domain extensions ted would required open interface debugging threads encompasses access functions sets iterate members access functions attributes member table 2 depicts iterators attribute functions operational de scription interface function registered tdi uses build database applications state explained next section domain values returned iterators functions da nfnullg respectively 3 thread implementation supports subset functionality simply register function invalid requests return null persistent objects discussed next section 4 thread debug interface tdi objective tdi component abstraction thread implementation one side debugger side tdi keeps database ap plications state approach supports paradigm active debugging database maintained tdi updated application changes state wrt multithreading objects ted may register set operations inform tdi updates applications execution notice approach unique active debugging since passive debugging allow applicationside execution auxiliary operations tdi exports following functions registration purpose int registerobject relt rel objreft objref int deregisterobject relt rel objreft objref int isregistered relt rel objreft objref signature operations includes relation object type thread mutex condition variable thread application supports registra 3 following exceptions id rstate domain z fnullg state domain fundef0 running ready blocked blocked c blocked blocked blocked exiting g dierent blocking states refer cause blocking mutex condition variable timer suspension forced iterator description getfirstthread getnextthread get thread set getfirstmutex getnextmutex get mutex set getfirstcond getnextcond get condition variable set attribute description threads id processpersistent threadid addr address thread structure prio priority state execution state rstate implementationdependent state entry address threads function address functions argument newpc next program counter sp stack pointer mbo blocked mutex cvwf blocked condition variable pid id process executing thread mutexes id processpersistent id addr address mutex structure owner mutex owner thread id condition variables id processpersistent id addr address cond var structure cmutex associated mutex table 2 open interface debugging threads erators attributes tion process invoke corresponding functions eg locking unlocking destroying mutex ted functionality described open interface debugging threads also registered tdi allows tdi generically invoke ted operations resolve database queries registration occurs via following interface int setiterfunc relt relobjreft getfirst int setattrfunc relt rel attrt attr attrdomaint getfunc objreft obj attrdomaint setfunc objreft obj exchange ted tdi range debugging support generalized letting tdi inform ted upon activation number functions expected registered registration request tdi includes list attribute functions iterators registration procedures objects ted may register subset functions depending range support initial exchange assumes known layout data types registered serves portability involved software components tdi handles communication debugger way debugger receives consistent view multithreaded objects application discussed section 7 abstraction provides means support persistent identiers seen table 2 persistent identier unique identier assigned object life time provision circumvents problems rooted within thread implementations recycle object identi ers eg pthreads api denes common interface including signature operations types thread object certain type meaning value transparent ie value may refer thread object long exists terminates value may recycled refer thread b passive debugging ap proach threads b cannot distinguished explicitly would users responsibility detect termination infer another thread identier truly refers b active debugging tdi receives notice creation termination thread registration procedure allows tdi assign values identify objects use values communicate debugger user exposed debugger provides persistent identiers allows distinction threads b active debugging actual queries database issued uniform extensible query language queries dened according specication relational algebra query preceded mode either refers ted query userdened extension operational framework queries selections projections limiting set objects question dening requested attributes respectively query includes set selections relation values projections relation assignments queries resolved list values corresponding projections query error message results set answers reduced ensure duplicates contained within set furthermore requests state distinct objects clustered one query optimized remove redundancies result declarative query interface performs better procedural interface request would require separate function call debugger example given section 7 5 communication structure breakpoint debugging generally supported service operating system service eg system call ptrace unix provides access trace process depicted figure 3 debugging process peek poke one word application process time may also continue execution application performance debugger often constrained granularity data accesses quantied section 7 approach active debugging utilized large amounts data may exchanged debugger application rendering ptrace approach less ef cient responses tdi query issued debugger may contain large amounts data depending number active multithreaded objects applica tion although queries often much shorter symmetric approach chosen queries issued debugger well responses tdi transmitted using interprocess communication ipc call ipcchannel buffered debugger target process call call subsequent handler calls ipcwritetedrequest request phase response phase return result 1 call return call return call return call return result n return call return return handling request process target replicated exit ipcwritetedrequest result 1 result 2 result n response phase request phase call return call return call return return call return call return call return call return call call return target process ipc channel debugger buffered mutual exclusive execution b parallel execution figure 4 communication debugger application another problem posed fact application process stopped debugger active vice versa debugger make progress queries handled tdi part applica tion problem solved letting debugger issue call handler function within application ptrace call continuation activates server side tdi receives request resolves query initiates response response may contain large amount data cannot transfered one buer since buer length generally constrained ipc mechanism debugger could issue repeated ptrace calls receive one packet time would result large number context switches debugger application process side eect using ptrace see figure 4a instead application process forks child upon long responses readwrite data call return call return call return time blocked stopped active application operating system debugger trap signal continue wait return call figure 3 breakpoint debugging ptrace see figure 4b child receives responsibility ipc buers terminating debugger receive ipc packets parallel 4 6 debugger extensions debugger extended two respects first ipc interface tdi added second new user commands control debugging process included resolution handed tdi ipc extensions bundled one module tdi client bound debugger build process tdi client handles client side ipc communica tion debugger may invoke send receive functions tdi client send query receive response cases string sending query application continued ptrace call within tdiserver main function application side tdi tdi server evaluates query hands parser query language may update state database using ted interface response formatted returned using ipc debugger act upon result second extension debugger denes number new user commands actions additional functionality detailed section 8 7 implementation implementation comprises changes debugger threads implementation gnu debugger gdb 418 chosen purpose since sources available widely used actively maintained 19 chosen thread implementations range kernel threads linux threads 11 mixed threads solaris 16 userlevel threads fsu mit pthreads 14 17 one challenges active debugging posed interaction activation debugging operations 4 even uniprocessor child process debugger may run concurrently require context switches packet anymore within application regular execution application tdi server may separate thread kernel threads server may simply invoked context active thread userlevel threads approach may result scheduling actions due 1 skew consumed execution time tdi 2 event notication 3 calls library functions use synchronization roundrobin scheduling active additional execution time consumed tdi server may cause context switch current thread switch occurs tdi server nishes results obtained debugging may inconsistent one part results may originate context switch another part switch subject modied thread state since application threads active meanwhile problem occur upon timer expiration may also caused signals context switches may also caused synchronization particular tdi server calls library function whose entry protected mutex mutex may already locked thread application resulting context switch tdi server application thread even worse deadlock may occur application thread thread executes tdi server first problem calling library functions contain synchronization addressed providing tdispecic replacements heap allocation string manipulation functions used tdi server contain potentially blocking library calls second problem signal handling tdi activation shall discussed one solution would mask signals application limited time masking could accomplished application causes race signal may arrive tdi tries mask signals tdi would loose control threads may scheduled race avoided debugger forced masking signals application operating systems provide interface current process another process instead operating system interface thread implementation enhanced provide ag set collects signals later handling depicted figure 5 debugger uses ptrace call set ag application 1 incoming signals collected handling postponed tdi activation tdi activities complete debugger reads collected signals 2 clears ag collected signals sends signal application 3 5 implementation tdi server contains communication subsystem query parser query evaluator 5 alternative reissuing signals would add pending signals thread implementation force check pending signals resuming ap plication would advantage signal contexts preserved future work may include provision communication structure implemented via shared memory ipc processes performance evaluated comparing ipc variant using page size 8kb ptrace implementation using linux 2036 150mhz pentium fsu pthreads figure 6 shows response time ptrace times higher performance ipc results underline advantages ipc approach tdi communication query parser generated lexical syntactical specications generators flex bison respectively parser reports errors illegal queries transforms legal ones tuple representation fed query evaluator evaluator may optimize query invoke ted functions resolve query compile response examples query may follows threadidentrystatestate threadidprio10state prio1020 cvwf 0x10 2 query 1 requests identier state function threads running blocked mutex query 2 requests information except function threads whose priority plus 10 less 20 blocked condition variable second conjunct pthreaddebugtdiignoredsignals scheduling1timer feedback pthreaddebugtdisigignore record debugger posix threads killpid sigalrm ptracepoke ptracepeek figure 5 signal handling active debugging25751251750 250 500 750 1000 1250 1500 response time instantiated threads tdi figure response times ipc vs ptrace query 2 also sets priority selected thread 10 response debugger may follows debugger interprets three tuples iden tier function address state translates addresses states symbolic names output tdi server combined application dynamically linking application tdi server relocatable library advantage application compiled testing debugging linked dynamic linker library using ldl tdi invoked even linked application executed outside debugger debugger invoked checks threads application contain symbol indicate debugging support threads ag found set debugger results dynamic binding invocation tdi server library initialization phase debugger sends pthread tdi register message tdi server tdi presents ted set functions expects ted responds registration attribute iteration functions afterwards tdi may resolve queries referencing thread objects ted functions threadspecic breakpoint debugging also requires changes debugger gdb routine proceed calling normal stop wait inferior resume control trap handling breakpoints command resume execution activates application debugger waits inferior process application hit trap instruction trap hit debugger resumes control cleans traces applications code normal stop threadspecic breakpoints modify sequence checking upon resumption debugger wait breakpoint reached corresponded requested thread thread identiers match normal stop called otherwise breakpoint reset similar cleanup performed normal stop resume called cleanup depicted figure 7 application traps inserted trap instruction replaced original instruction application ensure correct semantics b replaced trap transfer control debugger resuming execution 2 trap replaced b replaced trap make sure application halts breakpoint next time around execution step 2 may however cause scheduling action signal received prevented disabling signals step 2 using facilities discussed finally thread identier active thread determined breakpoint userlevel threads suces search single running thread using tdi query kernel threads multiple threads may running multiprocessor system call wait returns information process caused trap mixed threads lowlevel scheduling entity identied ensured parallel execution trap dierent threads one application results serial notication debugger operating system level example solaris maps posix threads onto lightweight processes lwps whose status information would checked upon encountering trap requires lwp state posix thread deter mined example proc le system single step commands ptstep ptnext see next section use similar technique count steps executed current thread attaching detaching threads also similar eect includes threadspecic breakpoints program counter target thread breakpoint next context switch realized setting conditional breakpoints program counter threads except one trapped breakpoint hit conditional breakpoints set deleted forcing change scheduling pattern results tdi query sets thread attributes invokes ted function aect scheduler thread implementation forced suspension also requires debugger signal application ensures scheduler invoked dispatch next thread eligible run also achieved adding scheduler signal set collected signals signal masking discussed 8 threadaware debugging sections describes commands added modied make gdb thread aware provide extended debugging support multithreaded applications notice gdb already provides limited debugging support selected thread implementations new commands debugging threads chosen coexist existing functionality example info threads may already list threads solaris mach linuxthreads new command info pthreads lists threads application supporting tdited facilities includes extensive information state thread object may blocked priorities etc commands available time pc pc inst b inst c pc code segment inst c code segment inst a3 breakpoint hit resume trap resume execution ready code segment inst c inst b trap code segment inst inst c trap trap reset reset figure 7 resetting breakpoint info pthreads lists set threads terminated yet including attributes threads depicted table 2 info pmutex lists set initialized mutexes attributes table 2 info pcond lists set initialized condition variables attributes table 2 break pthread thread id sets threadspecic breakpoint thread idat loca tion ptattach thread id stops thread idthe next time scheduled rst possible location transfers control debugger issued subsequent breakpoint commands break next step threadspecic means breakpoints apply attached thread active threads stop breakpoints ptdetach reverses ptattach makes breakpoints applicable threads ptstack thread id prints call stack thread id continue cs continues execution breakpoint hit context switch occurs ever comes rst latter case identier new thread printed ptnextptnextiptstepptstepi n issues n next step instructions current thread ignores instructions executed concurrently running threads facilities go beyond traditional debugging support threads following sense cause blocking threads blocking object identied may allow user identify deadlocks circular dependencies synchronization objects threads de picted 6 provides user call stack threads ie user follow progress concurrent execu tions threadspecic breakpoint debugging simplies users task tracing execution selected threads interactions threads detected notication upon context switches finally scheduling actions forced user allow selected activation suspension disable force thread interactions test impacts possibly track problems interactions also assessed overhead active debugging support tdi ted application side overhead may incurred ted two splash2 benchmarks 24 measured processes emulated fsu pthreads pentium ii 350 mhz linux 2214 depicted figure 6 fft performed calculations 2 20 data 6 may seem automatic deadlock detection could easily incorporated true sense state threads may change absence signals signal semantics pthreads provide stable state since signals may interrupt synchronization request skip synchronization call signal handler reason automatic deadlock detection implemented barnes table 3 performance overhead active debug ging points numbers fft exclude initialization barnes used standard parameters except 5 leaves numbers reported represent computation time experiments number processes threads varied 2 128 eect measurements overhead represents portion second measurements due active debugging overhead depends characteristics appli cation eg uses less synchronization barnes explains lower overhead former debugger side overhead tdi queries noticeable user ie response time tdi queries equals debugger interaction however large database gradually built thousands threads mutexes etc response time queries may aected since entries may probed experience problem practice hence relational queries seem suitable active debugging 9 related work mcdowell helmbold present overview problems solutions debugging concurrent programs 13 ceswell black 5 describe debugger mach threads threadspecic breakpoints forced scheduling ac tions approach limited kernel threads uses nonstandard ptrace interface portable approach described paper ponamgi et al 15 continue work debugger adding event handling detect deadlocks livelocks multiple entry critical sections similar support could added work level tdi subject constraints described ie certain thread standards may allow deadlock detection due signal handling smartgdb uses nongeneric design figure 1a thread implementation debugger modied changes thread implementation may turn require changes debugger gdb 418 19 requires even modications smartgdb thread implementation smartgdb gdb 418 support subset functionality debugging threads still use slow ptrace call communication solaris utilizes proc le system eciently access internal structures application alternative communication used tdi terms eciency provides neither portability systems without proc le system allow generic encapsulation seen figure 1b localization implementationdependent extensions solaris also provides library debugging threads similar functionality ted interface lacks exibility tdi makes approach portable wismuller et al 23 describe tool set debugging parallel programs consisting debugger partop monitoring tool partop supports threadaware debugging uses eventaction paradigm executes certain action event oc curs eg thread created generalization eventaction paradigm provided path expressions path actions context debugging 3 work path expressions proposed user level debuggers support today work one hand uses similar concepts paradigm active debugging hand concepts utilized internal purposes rather user level ie means communication debugger components portable fashion high performance debugging forum hpdf specied command interface parallel debuggers 9 including threadaware debugging work specify user interface rather interface thread library may utilized debugger also implement threadaware functionality hpdf interface even go beyond requirements eg supplying additional functionality display synchronization data execute next breakpoint cownie gropp 6 propose debugger interface display messages within mpi implementations demonstrate work totalview independent work also conclude dynamic linking shared libraries represents exible way provide debugging facilities multiple runtime libraries panorama 12 parallel debugger mimd architectures relies textbased debuggers collect information visualize predened userdened representa tion panoramas portability given reliance textbased debuggers lower level work diers provide textbased debugger extension may used visualization debugger like panorama kessler 10 introduced fast breakpoints regarded variant active debugging conditional breakpoints realized replacing trap call debugging specic handler application checks condition breakpoint traps evaluates true thereby improving performance use active debugging resolve relational queries kdb 4 supports twolevel debugging user kernel threads unique design kernel thread controlled separately local debugger using ptrace interface proc le system main debugger interacts user steers local debuggers work diers require ted interface thread level snodgrass 18 utilizes relational queries monitoring extending databases keep histories traces providing temporal operator query histories relational queries involve online debuggers accessing computing states without histories rather monitoring data overall none tools use active debugging relational queries debugging threads support much functionality work presented paper combined portability time 10 conclusion paper proposes open interface debugging extension thread implementations addition extensions threadaware debugging identied implemented within gnu debugger provide additional features beyond scope existing debuggers work based paradigm active debugging includes languageindependent protocol communicate debugger application via relational queries ensure enhancements debugger independent actual thread implementations partial complete implementations interface debugging added thread implementations work unison enhanced debugger without modications debugger sample implementations interface debugging shown adequacy userlevel threads kernel threads mixed thread implementations providing extended debugging functionality improved eciency portability time availability modied debugger gdbtdi sources bi naries documentation available httpwwwinformatikhuberlindemuellertdi gnu public license 11 r generalized path expressions high level debugging mechanism kdb multithreaded debugger multithreaded applications implementing mach debugger multithreaded applications standard interface debugger access message queue information mpi testing large beyond multiprocessing command interface parallel debuggers fast breakpoints linuxthreads library retargetability extensibility parallel debugger debugging concurrent programs library implementation posix threads unix debugging multithreaded programs mpd sunos multithread architecture mit pthreads relational approach monitoring complex systems gdb manual gnu sourcelevel debugger implementing lightweight threads technical committee operating systems application environments ieee mach threads unix kernel battle control splash2 programs characteriation methodological considerations tr relational approach monitoring complex systems debugging concurrent programs fast breakpoints design implementation splash2 programs retargetability extensibility parallel debugger interactive debugging performance analysis massively parallel applications kdb debugging multithreaded programs mpd standard interface debugger access message queue information mpi generalized path expressions ctr jaydeep marathe frank mueller tushar mohan bronis r de supinski sally mckee andy yoo metric tracking inefficiencies memory hierarchy via binary rewriting proceedings international symposium code generation optimization feedbackdirected runtime optimization march 2326 2003 san francisco california
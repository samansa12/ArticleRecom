compiling conceptual graphs abstractthis paper addresses problems conceptual graph implementation subsumption classification taxonomy conceptual graphs typically stored using directed acyclic graph data structure based partial order conceptual graphswe give improved algorithm classifying conceptual graphs hierarchy prunes search space database using information gathered searchingwe show conceptual graphs hierarchy compiled instructions represent specialized cases canonical formation rules compiles subsumption conceptual graphs compresses knowledge knowledge base conceptual graphs compiled differences adjacent graphs hierarchy differences represent rules used deriving graph adjacent graphs illustrate method compresses knowledge bases experimentscompilation effected three ways removal redundant data use simple instructions ignore redundant checks performing matching sharing common processing graphs b introduction central element many natural language processing information retrieval knowledge based systems large collection information information may viewed large set sentences paper concentrates problem answering queries set sentences query sentence question whether sentence implied set sentences sentences imply query sentence may extracted answers paper discusses methods seek answers explicit sentences collection rather answers deduced one sentence collection method designed intention extending handle latter case future example query person eating pie set sentences may extract answers girl eating pie fast girl sue eating pie kitchen example illustrates typing information embedded sentences searching sentences imply something people sentences containing information subtype girls considered research g ellis supported university queensland postgraduate scholarship enrolled phd programme key centre software technology university queensland qld 4072 australia currently dept computer science royal melbourne university technology victoria 3001 australia work also supported baskin center university california santa cruz usa visit paper concerned natural language frontend system rather concentrates work internal level sentences encoded conceptual graph knowledge representation 14 knowledge base set conceptual graphs graph representing sentence queries conceptual graphs checked subsumption graphs knowledge base method outlined constructs directed acyclic graph representing partial order conceptual graphs nodes hierarchy conceptual graphs querying set graphs achieved selecting paths hierarchy using ordering information hierarchy many graphs knowledge base eliminated consideration search hierarchy content addressable memory content query determine position hierarchy solutions ordered subhierarchies immediate specializations query levinson 5 developed method chemical graphs method paper based recent work 6 levinson adapted method conceptual graphs developed hybrid indexing mechanisms garner tsui 4 added idea storing graphs differences adjacent graphs hierarchy potential save store method described takes differences idea 4 graph reconstructed differences traversing hierarchy graph compared query using general subsumption algorithm method differs number ways use different differences rather incident arcs labelled differences label node representing conceptual graph differences graph adjacent graphs rather single adjacent graph method especially suited topological search method proposed levinson 6 another difference interpretation differences differences graphs represent instructions specialized cases canonical formation rules conceptual graph theory instruction performs part matching database graph query graph canonical formation rules basis partial ordering defined conceptual graphs rather reconstructing graphs differences applied query graph using mappings adjacent graphs query graph many cases adjacent graphs already compared query differences need mapped query graph implement comparison method achieves compilation conceptual graphs three ways removal redundant data use simple instructions ignore redundant checks performing matching sharing common processing graphs section ii introduces basic conceptual graph theory section iii outlines algorithms data structures used store retrieve conceptual graphs section iv explains mean compilation conceptual graphs generalization hierarchy section v gives descriptions instructions specialized cases canonical formation rules small example database compiled query compiled database examined section vi details experiments compressing knowledge bases discusses ramifications compilation ii conceptual graphs conceptual graphs 14 system logic based charles sanders peirces existential graphs 12 conceptual graphs full power firstorder logic represent modal higherorder logic simple elegant inference rules conceptual graphs also direct translation natural language following short introduction basic formalism reader advised read 14 thorough understanding conceptual graph finite connected bipartite graph two kinds nodes concepts conceptual rela tions every conceptual relation one arcs must linked concept single concept may form conceptual graph every conceptual relation must linked concept function type maps concepts set whose elements type labels function referent maps concepts set f1 2 individual markers generic marker individual marker surrogate individual real world perceived world hypothetical world label concept c labc referentc r concept may displayed linear form example concept person simply person represents unspecified person may read person box replaces square brackets graphical form partial order type labels known type hierarchy forms lattice called type lat tice type hierarchy makes analytic statements types must true intension statement person true properties person also associated girl minimal common supertype pair type labels written maximal common subtype two primitive type labels universal type absurd type type label minimal common supertype cat dog could possibly carnivore depending hierarchy maximal common subtype pet cat petcat maximal common subtype cat dog absurd means logically impossible entity dog cat denotation type written ffi set entities instances concept type extensions union set cats dogs world nothing else intensional type labels cat dog minimal common supertype car nivore also subtypes bear weasel skunk etc type lattice represents categories thought lattice sets subsets represents collections existing things two lattices isomorphic denotation operator maps one neither onetoone onto function type also maps conceptual relations type labels relation r may written linear form ellipse replaces parenthesis graphical form two relations type must number arcs concepts conceptual relations type common conformity relation relates type labels individual markers true said conform type conformity relation obeys following conditions ffl referent concept must conform type label c concept typec referentc example concept integer 1 wellformed integer 314 ffl individual marker conforms type must also conform supertypes example number 3 conforms type prime prime3 hence also conforms supertype integer integer3 ffl individual marker conforms type must also conform maximal common subtype example since 3 conforms types odd prime odd3 prime3 3 also conforms maximal common subtype oddprime oddprime3 ffl every individual marker conforms universal type individual marker conforms absurd type ffl generic marker conforms type labels type labels operator oe maps conceptual graphs formulas first order predicate calculus conceptual graph translation generic concepts map variables individual concepts map constants alternatively conceptual graphs could also mapped modern typed logic c girl agent eat manner fast person sue agent eat object pie fig 1 two canonical graphs canonical graphs distinguish meaningful graphs represent real possible situations external world certain graphs declared canonical one source derivation new canonical graphs canonical graphs formation rules five canonical formation rules deriving conceptual graph w conceptual graphs u v 1411 copyu w exact copy u ffl restrictu c l concept c u typec may replaced subtype c generic referent may changed individual marker changes permitted referentc conforms typec change relations r graph u duplicates one may deleted u together arcs ffl joinu c concept c u identical concept u joinu c graph obtained deleting linking c arcs conceptual relations linked ffl fuseu v c let u v two disjoint conceptual graphs concept c u identical concept v fuseu v c graph obtained deleting linking c arcs conceptual relations linked illustrate formation rules fig 1 shows two canonical graphs concept relation identified ci rj respectively graph also labelled reference text graph b may read girl eating fast graph c person sue eating pie formal translations graphs informal verbalizations discussion graphs graph fig 2 shows result restricting concept c3 girl graph b fig 1 girl sue graph e result restricting type person concept c7 graph c type girl restrictions conformity relation must checked ensure girl sue true identical concepts c3 c7 girl sue e fig 2 fused together form single graph x9 fig 3 identical concepts c1 c5 eat x9 joined together produce x10 fig 3 graph x10 simplified removing one duplicate relations r2 r4 agent resulting graph f fig 4 two conceptual relations type duplicates ith arc one linked girl sue girl sue e agent eat object pie fast manner eat agent fig 2 restriction two graphs fig 1 girl sue girl sue agent eat manner fast agent eat object pie agent eat manner fast pie object agent fig 3 join two graphs fig 2 concept ith arc graph f may read girl sue eating pie fast simplification rule corresponds rule logic rx rx equivalent rx formation rules kind graph grammar canonical graphs besides defining syntax also enforce certain semantic constraints formation rules make guarantee truth falsity however formation rules refutation rules assert graph false person eating pie use formation rules show false sue eating pie graph derived false graph must turn false formation rules falsity preserving canon contains information necessary deriving set canonical graphs four components type hierarchy broken concept hierarchy c relation hierarchy r set individual markers conformity relation relates labels markers f girl sue agent eat manner fast pie object fig 4 simplification fig 3 place location act entity act object event act physicalobject animate entity give animal pie girl person attribute eat fast place kitchen food girlsue manner agent object location act act agent manner attribute animate fig 5 sample canon finite set conceptual graphs b called canonical basis type labels referents either markers canonical graphs closure b canonical formation rules fig 5 shows canon used paper b relationship canonical formation rules subsumption conceptual graphs conceptual graph u canonically derivable conceptual graph v possibly join conceptual wn u called specialization v written u v v called generalization u generalization defines partial ordering conceptual graphs called generalization hierarchy ordering reflexive transitive antisymmetric conceptual graphs u v following properties true ffl subgraph v subgraph u u v ffl subtypes u identical v except one type labels v restricted subtypes u ffl individuals u identical v except one generic concepts v restricted individual concepts type u v ffl top graph generalization conceptual graphs graphs figs 1 2 3 generalizations graph fig 4 call graphs defined far atomic conceptual graphs acgs contain logical connectives hence neither quantification default existential quantification consider definition concepts relations subsumption test acgs implemented subgraph morphism modulo subtyping individuation generalization hierarchy partial order conceptual graphs stated 14 rather partial order equivalence classes conceptual graphs consider graphs graph v proper subgraph u graph u derived v joining copy v concept eat girl sue agent eat manner fast object pie q3 d3 d1 q1 d4 q2 d2 query u fig query graph u thus u v however v derived u joining two identical concepts person simplifying duplicate agent relations thus v u hence according generalization hierarchy property generalization hierarchy also noted independently 15 u v canonical derivation u v corresponds reverse proof formula oev formula conceptual graphs u v u v oeu oe oev result two graphs given paragraph equivalent surprising considering translations sorted logic subtle point doesnt affect subsequent theory conceptual graphs practice graphs redundant branches always simplified derive smallest one equivalence class conceptual graphs assumed minimal element class conceptual graphs u v u v must exist mapping subgraph u called projection v u projection operator following properties ffl concept c v c concept v referentc ffl conceptual relation r v r conceptual relation v ith arc r linked concept c v ith arc r must linked c v example projection graph c fig 1 graph u fig 6 person girl act eat graph v represented set instances canonical formation rules used construct graph v graphs w wn test graph v subsumes graph u rule instances applied projections u w wn rule instances succeed v subsumes u use technique compile conceptual graphs data structure representing generalization hierarchy partial ordering theory atomic conceptual graphs consider store large sets conceptual graphs retrieve conceptual graphs stored animate act agent act object entity manner act attribute girl sue eat manner fast agentb manner fast girl eat agent eat object pie girl sue manner fast eat pie object eat object pie girl sue agent c c3 r2 c4 e agent person sue agent f fig 7 generalization hierarchy graphs figs iii storing retrieving conceptual graphs common data structure used store conceptual graphs hierarchy directed acyclic graph representing nontransitive links partial ordering generalization hierarchy conceptual graphs 10623 levin sons earlier work used similar data structure organizing chemical graphs 5 taxonomy klone concept descriptions 13 hierarchy generalization hierarchy data structure storing conceptual graphs nodes generalization hierarchy conceptual graphs arcs represent nontransitive ordering graphs fig 7 hierarchy given graphs previous section canonical basis example consists set graphs g arc b indicates following 1 girl sue eating fast canonically derivable girl eating fast 2 girl sue eating fast implies girl eating fast 3 girl eating fast generalization girl sue eating fast 4 girl sue eating fast specialization girl eating fast following sections examine use hierarchy searching set conceptual graphs construct hierarchy b searching conceptual graph generalization hierarchy generalization hierarchy indexes knowledge base apply conceptual graph query u knowledge base search u hierarchy hierarchy content addressable memory fig 8 illustrates search space query u hierarchy atoms primitives graphs closest objects unifiable u coatoms bottom object atoms primitives top object objects general u objects specific u objects nonunifiable u fig 8 search space graph u generalization hierarchy concept derivable graphs coatoms leaf nodes knowledge base generalization space contains generalizations u hierarchy specialization space solution space contains specializations u hierar chy immediate generalizations parents immediate specializations children u adjacent generalizations specializations u respectively fig 8 u explicitly stored hierarchy ever many cases u stored hierarchy explicitly search u proceed two directions topdown graph u bottomup coatoms u methods examine search topdown consider depthfirst search generalization space path generalization space taken lead u hierarchy consider searching query u girl sueagenteatobjectfast girl sue eating fast hierarchy fig 7 query u matches graph hierarchy search starts graph find graph search children generalization u children v set immediate specializations v children b1 b2 b3 b c e f fb1 b2 b3g fbg fb cg fcg fdg feg ffg ffg fg respectively depthfirst search could select first graph children generalization query u continuation path u basis graph b1 generalization first children set select b2 b3 could equally chosen one child b1 b also generalization select search children b generalization graph child generalization u fact isomorphic u query graph matched search terminates successfully case two solutions fd fg english answers question agent eat person eat object pie location kitchen agent eat person object food object location kitchen agent eat girl sue pie object agent eat pie girl manner fast f e c fig 9 generalization hierarchy girl sue eating fast yes f yes sue eating pie fast search necessarily start graph indexing techniques used start generalization space ultimate goal indexing techniques index directly top specialization space includes u see 8 indexing techniques c inserting conceptual graph generalization hierarchy classification insert graph u hierarchy need compute set immediate generalizations set immediate specializations u hierarchy information gives us virtual location inserting u consider inserting graph read person eating pie hierarchy fig 9 immediate generalizations case b person eating c pie eaten immediate specializations f girl sue eating pie kitchen e girl eating pie fast notice person eating food kitchen u incomparable insert u remove arcs b e c e c f add b u c u u f u e get new hierarchy fig 10 searching generalization space woods 16 describes standard two phase breadthfirst search used classification klone like terms taxonomy first phase calculates set immediate predecessors ip generalizations query breadthfirst search generalization space second phase breadthfirst searches subhierarchies immediate predecessors calculated first phase first specializations encountered hierarchies immediate successors query woods 16 summarizing research classification says sophisticated algorithms devel oped agent eat person eat object pie location kitchen agent eat person object food object location kitchen agent eat girl sue pie object agent eat pie girl manner fast agent eat person object pie e c fig 10 generalization hierarchy fig 9 inserting 6 levinson describes algorithms show deeper insights problem subsumption general expensive operation hence methods classification avoid many subsumption tests possible de sirable algorithm given inserting object hierarchy improves implementation levinsons method number graph comparisons phase procedure insertu begin ip immediate predecessorsu ip 6 fug begin immediate successorsip u insertu ip fig 11 insert u partial order consider algorithm insert fig 11 first phase computing immediate predecessors ip done function immediate predecessorsu fig 13 u already stored hierarchy u returned rather us immediate predecessors second phase avoided otherwise subhierarchies members ip searched using immediate successorsip u fig 14 sets ip found procedure insertu ip fig 12 necessary housekeeping linking u immediate predecessors immediate successors procedure also maintains levels graphs hierarchy information used traverse hierarchy topological order levinson 6 pruned search space using fact graph generalization space generalizations query u immediate predecessors also generalization space levinson sorting hierarchy size graphs traversing hierarchy order size necessary requirement procedure insertu ip begin v 2 ip w 2 remove v w present v 2 ip add v u w 2 add u w ulevel propagate levelis fig 12 insert u partial order given neighbourhood ordering kinds graphs levinson working however conceptual graphs size necessary requirement topological order level order hierarchy reflected node distance node top example fig 9 graph level 0 graphs b c level 1 graphs e level 2 graph f level 3 see topological order efficient search method depthfirst breadthfirst search terms avoiding comparing objects hierarchy consider hierarchy fig 9 remember immediate predecessors graph must compared graph immediate predecessors graph must generalizations query graph also generalization assume query u fig 10 hence generalizations u b c breadthfirst traversal hierarchy fig 9 reading right left c b e f would compare f depthfirst traversal right left would fa c e f b dg also comparing f topological traversal also reading right left c b e f would compare f since encountered beforehand noted incomparable u topological search ensures predecessors element v seen v algorithm fig 13 level information associated graph hierarchy used traverse hierarchy topological order queue used modified breadthfirst search minimum priority queue priority given elements smallest level num ber using array fifo queues enqueue dequeue priority queue constant time enqueuing weighted element u involves adding u front ith queue dequeuing involves removing first element current minimum weighted queue whenever current minimum queue j becomes empty weight index incremented traversing hierarchy level order maintains property j fifo necessarily nonempty point sets ip v isv correspond stored sets immediate predecessors v immediate successors v respectively v already stored hierar function immediate predecessorsu begin qenqueuelevel qempty begin predecessors matchv u v begin w 2 ip v ip ip w 2 isv return ip fig 13 find immediate predecessors u chy algorithm call subsumption u v guarded test predecessors matchv topological traversal guarantees vs predecessors seen v predicate predecessors matchv true vs predecessors predecessors query u depthfirst search object v compared v immediate predecessor predecessor query u breadthfirst search object v compared u one necessarily vs immediate predecessors predecessors u thus precondition checking v predecessor query u stronger topological search v predecessor add set ip remove vs immediate predecessors ip search successors v closer predecessors query e searching specialization solution space second phase woods 16 searches one subhierarchies immediate predecessors first phase one hierarchies needs traversed since specialization query must also specialization generalization query specialization found added set subhierarchy removed consideration however graph incomparable subhierarchy must traversed levinson 6 devised method avoiding many comparisons inherent traversing particular subhierarchy second phase notice woods method use information members ip levinson 6 noted second phase database graph successor query graph must intersection subhierarchies immediate predecessors first phase subsumption tests relatively expensive compared pointer traversal involved walking subhierarchy particularly useful intersection computed traversing subhierarchies incrementing counter graph graph intersection must count equal number elements ip intersection traversed breadthfirst manner used woods algorithm immediate successors fig 14 avoid multiple traversal computing intersection incrementally one constrained topological search algorithm uses insight graph intersection subhierarchies ip graph must path elements ip element set ip represented bit immediate successors elements ip paths elements determined oring bit strings immediate predecessors propagating information restrict subsumption testing graphs bits set intersection space algorithm also relies level topological traversal implemented minimum priority queue predicate ip reachablev ors bit strings vs immediate predecessors true bits set function immediate successorsip u begin v 2 ip begin w 2 isv qempty begin seenv begin ip reachablev v u begin see successorsv else w 2 isv return fig 14 find immediate successors u given immediate predecessors notice insert seen information must reinitialised would mean algorithm would perform linearly size database every case avoided using token query graph seen must token current query consider query graph u classification problem query database graphs hi erarchy solutions query would everything implied query specialization space solutions listed walking subhierarchies elements support algorithms used insert finding immediate predecessors immediate successors also used querying worst case algorithms perform better comparison query graphs database methods suited databases little ordering information total ders hierarchy chain methods suited wide shallow hierarchies data believe many domains conceptual graphs intended used property woods 16 argues typicalcase complexity logarithmic size database levinson 6 gives empirical evidence support argument levinson proved topological methods less comparison graphs previous known methods 6 levinson 6 also describes indexing scheme hybrid method method particularly useful graphs high degree symmetry also see 8 application conceptual graphs shown prune search within database generalization specialization space following section show share matching information gained subsumption testing related graphs iv compilation conceptual graphs generalization hierarchy efficiency querying database im proved previous sections saw method minimizing number database graphs compared query graph following sections look minimizing cost comparisons examine represent conceptual graphs generalization hierarchy improve individual subsumption tests woods 16 states algorithm deep insights exploited gain efficiency example clas sification advantage taken might learned course one subsumption test might redundant part another subsumption test garner tsui 4 proposed representing graphs differences adjacent graphs generalization hier archy fig 15 illustrates stored graph girl sue eating pie fast difference adjacent generalization girl eating food difference means replace referent concept c1 u sue difference c2 mannerfast means connect new binary relation manner concept c1 u new concept fast difference means replace type concept c3 u type pie difference garner tsuis method girl eat object agent fast eat manner object girl sue pie agent girl eat object agent food c3 pie food transformed fig 15 representing graphs differences generalization method outlined former method places difference adjacent graphs incident arc whereas latter places differences graph immediate generalizations node representing graph graph differences garner tsuis method nodes arcs restrictions specialization generalization graph differences treated data reconstructing graphs traversing arcs hence adding graph differences reconstructed graphs compared query using general matching algorithm method compile graphs matching instructions share common computation queries storing graphs differences fulfills aim removing redundant data database another aim method share common computation achieved storing mappings adjacent graphs conjunction differences see mappings stored explicitly com posed allows us fulfill another aim represent differences way may used instructions future conceptual graph unification machine graph may compared query using mappings generalizations query instructions perform small parts general matching operation relative mappings following details alternative garner tsuis method consider query u fig 6 generalization hierarchy fig 7 discussion notation vu represents mapping graphs let us assume subgraph morphism bu graph b fig 7 found query u search solutions query u search method outlined previous sections takes paths generalization hierarchy contain specialized generalizations query step graph choice paths b traverse path must compared u see generalization u full subsumption test avoided notice difference b concept c3 type girl restricted generic form individual sue compute match mapping du must com puted assume mapping bd stored database generalization b mapped query u bu every concept relation x x b x du otherwise find match x u violate rest match insert mapping du equal mapping bu since mapping bd identity mapping difference could represented referent du sue generalization u general possible symmetry graphs involved unique mappings graphs involved case differences must applied possible mappings many domains conceptual graphs used graphs contain unique morphisms thus differences graphs used mappings adjacent graphs bd previous ex ample current generalization b query u kept necessary store mapping adjacent graph explicitly mappings composed traversing generalization hierarchy canonical formation rules construct mapping constructing graphs copy rule sets mapping whole graph copied restrict rule affect mapping join rule computes union mappings two graphs joined maps one identical concepts simplify rule maps duplicate relation onto another conceptual graphs generalization hierarchy replaced sets applications canonical formation rules instances rules apply immediate generalizations graph represented fig illustrates method generalization hierarchy fig 7 method potential reduce cost graph comparison sharing computation already done mappings adjacent conceptual graphs also potential save space storing conceptual graphs v instructions examine use canonical formation rules differences adjacent graphs generalization hierarchy concentrate first phase topological search searching generalization space following discussion assumes graphs canonical form compared stored restrictb3 c5 eat act manner attribute restrictb1 c1 eat restrictx1 c2 fast restrictx2 c4 eat fusex5 x6 c1 c4 restrictrefb c3 sue animate act object entity restrictb2 c3 girl x3 c3 r2 c4 agent act copyb2 c8 c7 r4 restrictx4 c6 pie restrictb2 c7 person restrictx3 c8 eat c e x9 fused e c3 c7 joinx9 c1 c5 simplifyx10 r2 r4 restrictc c7 girl fusex7 x8 c5 c8 fig 16 encoding conceptual graphs generalization hierarchy canonical formation instructions first phase aim find subgraph morphisms database graphs query second phase aim find subgraph morphisms query database graphs first phase database graphs could thought reading query graph second phase database graphs write query graph constructing specialized solutions modes correspond modes reading writing prolog compiler unification instructions 1 give specialized interpretation canonical formation rules based mode operation read write examine read mode graphs reconstructed instructions however show operations construct mapping database graphs query q ffl copyu w find subgraph morphism wq w exact copy u recon structed general matcher used find wq ffl restrictu c w type uq c wq database graph w generalization query graph q q must subtype type corresponding concept u ffl restrictrefu c instruction handles restriction individual markers rather complex referents nested graphs sets q u true query must individual marker one corresponding concept database graph u joining concepts c database graphs u v respectively read mode means c must already pointing concept query graph q ffl simplifyu simplifying two duplicate relations database graph read mode means two relations must mapped relation query since query graph cannot contain duplicates minimal graph instructions separated specialized cases example input output graph new mapping constructed rather modifications particular entries mapping made fig 16 conceptual graphs replaced instructions compare representation generalization hierarchy fig 7 fig 6 contains query graph u generalization hierarchy fig 7 contains solution f let us consider happens stage topological search generalization hierarchy query u examine process middle search subgraph morphisms b c u found q1g look b cs adjacent graphs generalizations u adjacent graphs e graph represented restrictrefb c3 sue instruction translates referent bu sue generalization u du bu graph e represented restrictc c7 girl e instruction implemented type cu c7 girl girl e generalization u eu cu examine adjacent graphs e one case f graph f represented three instructions first instruction fused e c3 c7 x9 means du calculate q1g second instruction joinx9 c1 c5 x10 since third instruction f simplifyx10 r2 r4 f since q3g thus f generalization u u compare result graphs u f fig 6 fig 7 respectively fig 17 shows alternative compilation based canonical derivations applied single parent joining simple basis relations approach follows new formalization conceptual graph theory mugnier chein 11 approach similarities garner tsuis method representation differences 4 vi experiments compilation methods still design phase examine usefulness methods conceptual graph databases wrote programs animate f x3 c3 r2 r3 c6 e c act manner attribute agent act act object entity restrictx3 c7 girl restrictb2 c3 person sue restrictx5 c4 eat fusex6 b3 c4 c5 c5 c8 restrictx7 c8 pie restrictc c3 girl fused b3 c5 c5 c8 restrictx4 c8 pie restrictb c7 sue fusex2 b2 c1 c4 c4 c7 restrictb1 c1 eat restrictx1 c2 fast fig 17 linear derivations graphs hierarchy fig 7 animate act agent act object entity manner act attribute manner fast girl eat agent eat object pie c3 girl sue girl sue eat pie object c c3 r2 c4 agent person sue f e fig 18 generalization hierarchy fig7 compressed using differences largest parent animate act agent act object entity manner act attribute manner fast girl eat agent eat object pie girl sue c3 girl sue c c3 r2 c4 agent person sue e f fig 19 generalization hierarchy fig7 compressed using differences parents original file compressed largest parent parents parents parents compressed parents database basis18245220854918644189369374412901247493477971882616823 1222111923a basis fig 20 results compressing chess files piece piece piece piece piece piece piece piece piece piece piece piece fig 21 schemas morph chess seed database compressed conceptual graph databases representing graph u differences u us largest parent ii us parents method shall call largest parent method best case garner tsuis method method ii corresponds compilation method shown fig 16 call parents method main problem parents method join parents may need stored tests store joins files tested fig 20 morph adaptive chess playing system 9 file b seed database 3104 patterns form shown schemas fig 21 piece could whitepawn black arc concepts represents support attack depending colour piece file b contains 1778 chess patterns learnt morph similar fig 22 files basis b basis include 42 basis graphs addition graphs files b respectively column database fig 20 lists names files column original file lists size ascii file containing conceptual graphs conceptual graph linear notation 14 column lempel ziv com pressed column gives size files compressed using unix compression utility column largest whiterookrank0 file0 whitepawnrank1 file1 fig 22 conceptual graph chess pattern parent shows size file compressed using largest parent method representing conceptual graphs column parents shows size file compressed using parents method representing conceptual graphs column parents without parents stores differences parents method leaves list parents differences refer column lempel ziv compressed parents shows size file generated parents method compression using unix compression utility main columns compare largest parent parents parents method results smaller files even though parents referred cost referring parents difference par ents parents without parents columns ex ample database listing parents cost 30534 bytes cases parents method resulted smaller files files using largest parent method parents method resulted compression ratio 2561 3841 four knowledge bases tested potentially similar reduction could also achieved information retrieval times vii summary compilation conceptual graphs achieved storing derivations immediate generalizations directed acyclic graph representing generalization hierarchy partial order conceptual graphs graph inserted generalization hierarchy computing immediate neighbourhood hierarchy attaching newly inserted graph graphs neigh bourhood neighbourhood computed two phase topological search canonical formation rules distinguish conceptual graphs semantic network formalisms enforce semantic constraints canonical graphs algorithms process must developed conceptual graphs compiled instructions special cases formation rules instructions operate immediate generalizations construct mapping immediate generalizations graph hence query graph search common computation involved matching database graphs query graph shared mappings potential store saved storing dif ferences compression knowledge using differences illustrated sample databases compilation effected three ways removal redundant data use simple instructions ignore redundant checks performing matching sharing common processing graphs future work examine methods handling complex conceptual graphs use domains chem istry levinson 7 recently developed new tuple skeletonbased compression technique called uds uds based new compact representation conceptual graphs make storage retrieval efficient uds extended processing hierarchical search shared early work suggests storing possible mappings matrix form parents children database combining mappings parents query children using matrix multiplication get first approximations specific matches queries may adequately propagate binding information gathered search within conceptual graph database acknowledgements thank supervisors peter robinson robert levin son thank fritz lehmann guy mineau john staples comments earlier drafts paper fritz lehmann inspired revise earlier version paper r compiling conceptual graphs sorting conceptual graphs selforganizing dictionary conceptual structures pattern associativity retrieval semantic networks uds universal data structure multilevel hierarchical trieval adaptive pattern oriented chess induction conceptual graphs finding common generalizations compatible projections characterization algorithmic recognition canonical conceptual graphs existential graphs charles classification klone knowledge representation system conceptual structures information processing mind machine knowledge graphs versus conceptual graphs understanding subsumption taxonomy framework progress tr ctr ahmad kayed robert colomb extracting ontological concepts tendering conceptual structures data knowledge engineering v40 n1 p7189 january 2002 vilas wuwongse ekawit nantajeewarawat declarative programs implicit implications ieee transactions knowledge data engineering v14 n4 p836849 july 2002 gian piero zarri ontologies reasoning techniques legal intelligent information retrieval systems artificial intelligence law v15 n3 p251279 september 2007 ahmad kayed robert colomb using bww model evaluate building ontologies cgs formalism information systems v30 n5 p379398 july 2005
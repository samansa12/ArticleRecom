new lower bound list update problem partial cost model optimal competitive ratio randomized online list update algorithm known least 15 16 remaining gap yet closed present new lower bound 150084 partial cost model construction based game trees incomplete information seem generally useful competitive analysis online algorithms 2001 elsevier science bv b introduction list update problem classical online problem area selforganizing data structures 4 requests items unsorted linear list must served maintaining list access costs remain small assume partial cost model accessing ith item list incurs cost units simpler analyze original full cost model 14 cost item requested may moved free charge closer front list called exchange two consecutive items list incurs cost one called paid exchange online algorithm must serve sequence oe requests one item time without knowledge future requests optimum offline algorithm knows entire sequence oe advance serve minimum cost oe online algorithm serves oe cost oe called ccompetitive suitable constant b request sequences oe competitive ratio c inequality standard yardstick measuring performance online algorithm wellknown move tofront rule mtf example moves item front list requested 2competitive 14 15 also best possible competitiveness deterministic online algorithm list update problem 10 1 institute theoretical computer science eth zurich 8092 zurich switzerland email ambuehlinfethzch gaertnerinfethzch mathematics department london school economics london wc2a 2ae great britain email stengelmathslseacuk support heisenberg grant deutsche forschungsgemeinschaft hospitality eth zurich research gratefully acknowledged randomized algorithms perform better average 9 algorithm called ccompetitive theta oe expectation taken randomized choices online algorithm fur thermore call algorithm strictly ccompetitive 2 holds best randomized list update algorithm known date 16competitive algorithm comb 2 serves request sequence probability 45 using algorithm bit 14 alternately moves requested item front leaves place probability 15 comb treats request sequence using deterministic timestamp algorithm 1 requested item x moved front first item list requested since last request x randomization useful oblivious adversary 5 generates request sequences without observing randomized choices online algorithm adversary observe choices generate requests algorithm deter ministic best 2competitive therefore consider interesting situation oblivious adversary lower bounds competitive ratio proved using yaos theorem 18 probability distribution request sequences resulting expected competitive ratio deterministic online algorithm higher every deterministic randomized online algorithm competitive ratio higher 8 teia 16 described simple distribution request sequences adapted partial cost model shows lower bound 15 optimal competitive ratio list update problem therefore 15 16 true value yet unknown lists four items possible construct online list update algorithm 15competitive 3 therefore optimal paper show lower bound greater 15 list least five items prove bound standard assumption algorithms may use paid exchanges one also prove lower bound 15 variant list update problem free exchanges allowed purpose modify extend method certain ways mentioned end paper construction uses game tree alternately adversary generates request online algorithm serves adversary informed action online algorithm game tree imperfect information 12 consider finite tree requests ratio online versus optimal offline cost payoff adversary defines zerosum game solve linear pro gramming game tree sufficiently deep restricted suitable subset requests tree large order stay solvable game value 150084 shows strictly ccompetitive online algorithm fulfills c 150084 order derive new lower bound competitive ratio c according 1 nonzero constant b one generate arbitrarily long request sequences achieved composing game trees repetitively show drawback assumption partial instead full cost model latter model request ith item list incurs cost known lower bound 15 gamma 5n5 list n items result teia 16 yields lower bound competitive ratio much 15 list short fact algorithm comb 2 15competitive n 9 prove lower bound 15 full cost model would extend construction longer lists unfortunately straightforward extension cannot compensate reduction competitive ratio 5n term proportional 1n considering full instead partial cost model case remains open nevertheless think result partial cost model still interesting since model canonical one looks analysis still close original problem formulation 2 pairwise analysis partial orders analysis list update algorithm greatly simplified observing separately relative movement pair items list let oe sequence requests consider deterministic algorithm processes oe two items x list let xy oe number times requested behind x list vice versa easy show 6 9 2 xy oe l set items list way xy oe represents cost online algorithm projected unordered pair fx yg items let oe xy request sequence oe items x deleted many list update algorithms like mtf bit timestamp projective sense time relative order two items x list depends projected request sequence oe xy initial order x denote xy x precedes general list items square brackets denote current order list maintained algorithm optimal offline algorithm projected cost xy oe clearly least high cost serving oe xy optimally twoelement list consisting x latter cost easy determine since example always optimal move item front first two successive requests fact item must moved front first three successive requests hand usually optimal move item requested hence two items x x precedes online algorithm serving request either leave behind x move front x either way mistake depending whether requested x based observation teia 16 constructed lower bound 15 competitive ratio requests generated runs repeated indefinitely start run list currently maintained offline algorithm particular list traversed front back requesting item equal probability either three times item requested three times moved front first request otherwise left place optimal offline treatment results new offline list determines next run following table 3 lists resulting costs possible actions online algorithm projected items x table wait refers online algorithm moves requested item second request succession moved online costs even higher mtf moves item front first request 3 item x assumed precede lists maintained offline online algorithm four request sequences probability 14 four possible combinations wait mtf column denotes online cost denotes number inversions online list requests served inversion transposition two items relative position offline list xy oe xy x wait x mtf x wait x mtf without inversions mtf algorithm example would incur cost optimal offline cost however inversion increases online cost full unit next run xy order offline algorithm yx order x list used online algorithm following table shows online costs algorithm starts inversion denoted 1 inversion yx oe xy x wait x mtf x wait x mtf tables 3 4 list possible online actions except perform even worse leaving triply requested item place example note matter online algorithm conditions action presence inversions let distribution request sequences generated described method teia expected online costs together change number inversions fulfill inequality follows 3 4 considering projected sequences telescoping sum inversion counts one run next run equal previous run cancels inequality 5 shows number inversions serve potential function 7 variation deltai gamma potential function bounded 5 implies online algorithm 15competitive distribution request sequences extend teias method lower bound construction using partial orders one construct 15competitive list update algorithm lists four items 3 partial order initially equal linear order items list request partial order modified follows xky means x incomparable partial order request z 62 fx yg x request affects requested item relation remaining items front items x except x held changed xky initial order list request sequence determine resulting partial order one generate arbitrary partial order way 3 partial order defines position item x online algorithm maintain distribution lists expected cost accessing item x equal px algorithm 15competitive 3 one show x probability one behind items x precedes probability 12 items xky incomparable elements reflect possibility mistake transposing items probability 12 lists four items one maintain distribution using two lists partial order represented intersection two lists list updated moving requested item suitably front using free exchanges algorithm works choosing one lists beginning probability 12 actual list serving maintain partial order aid separately stored second list partial order approach natural projection pairs online algorithm use free exchanges lower bound 15 must exploit failure algorithm already possible lists five items despite fact fiveelement partial orders twodimensional representable intersection two linear orders namely let items integers let initial list 12345 consider request sequences first request 4 partial order states 4k1 4k2 4k3 4 5 otherwise 5 using free exchange 4 moved forward precede probability 12 achieved uniquely uniform distribution two lists 12345 41235 well following holds even though distributions two lists allowed next request 2 induces 2 4 2 must moved front 4 list 41235 2 already passes 1 yields unique uniform distribution 12345 24135 next request 5 entails 5 incomparable items handled deterministically exactly two ways random choice two ways either 5 moved front 24135 yielding two lists 12345 52413 equal probability 5 moved front 12345 yielding two lists 51234 24135 equal probability two lists 12345 52413 algorithm must disagree partial order request 4 oe 1 since 4 must precede 1 5 lists 4 moved front lists incorrectly passes 2 2k4 hold similarly two lists 51234 24135 request 3 oe 2 moves 3 front 5 4 lists passes 1 violating 1k3 thus either oe 1 oe 2 6 causes posetbased algorithm fail otherwise achieves competitive ratio 15 sequences used certain probabilities lower bound construction 3 game trees imperfect information competitive analysis phrased zerosum game two players adversary online algorithm online player order deal finite games assume finite set request sequences oe given bounded length example represent pure strategies adversary mixed random ization online player finite number n possible ways deterministically serving request sequences deterministic online algorithms also chosen randomly suitable probabilities context finitely many request sequences arbitrary constant b 2 reasonable look strict competitiveness randomized online algorithm strictly ccompetitive oe j oe cost incurred jth online algorithm oe optimal offline cost serving oe disregard trivial sequences oe consist requests first item list case 7 equivalent j oe oe terms j oeoff oe 8 1 j n oe 2 treated payoff adversary zerosum game matrix rows oe columns j correspondingly lower bound strict competitive ratio expected competitive ratio 8 resulting distribution request sequences distribution mixed strategy adversary probabilities q oe oe online strategies j oe minimax theorem zerosum games 18 asserts mixed strategies players reals c 8 9 hold c value game optimal strict competitive ratio chosen finite approximation list update problem note depends admitted length request sequences due complicated implicit definition large size game matrix know bounds c 8 9 hold irrespective length request sequences c number request sequences exponential length sequences online player even larger number strategies since players actions conditional observed requests best described game tree nonterminal node tree player makes move corresponding outgoing edge game starts root tree adversary chooses first request online player moves actions corresponding possible reorderings list request n actions corresponding possible reorderings later see need considered players continue move alternatingly last request reaction online player leaf tree defines sequence oe online cost oe depending online actions leading leaf payoff oeoff oe adversary restricted information adversary game tree modeled information sets 12 information set set nodes adversary move preceded previous moves adversary hence nodes set differ preceding moves online player adversary cannot observe action adversary assigned information set rather individual node definition action every node set hand online player fully informed past requests information sets singletons figure 1 shows initial part game tree list three items first second request adversary first online response restricted free exchanges 123 123 213 123 213 312 ffl theta theta theta theta theta theta ffl theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta ffl theta theta theta theta theta theta ffl theta theta theta theta theta theta adv adv adv adv figure 1 game tree information sets pure strategy game tree assigns move every information set player except unreachable due earlier choice player online player information sets like figure 1 combination moves defines different strategy induces exponential growth number strategies size tree strategic approach using game matrix 8 becomes therefore computationally intractable even game tree still moderate size instead used recent method 17 11 allows solve game tree sequence form game matrix corresponding linear program size game tree using game trees first approach finding randomized strategy adversary following consider list five items minimumnumber competitive ratio 15 possible fix maximum length request sequences generate game tree requests length leaf payoff adversary quotient online offline cost serving sequence convert game tree linear program compute optimal strategies lp solver used cplex however straightforward method lead strict competitiveness 15 two reasons first mistakes algorithm like last column 3 manifest later actual costs little hope improved lower bound using short request sequences secondly even short sequences considered online player n responses every move adversary game tree grows fast lp becomes computationally infeasible already small values first problem overcome adding number inversions online list denoted 3 4 payoff leaf yields strict competitive ratio greater 15 rather short sequences inversions converted actual costs attaching gadget leaf game tree generates requests similar teias lower bound construction next section describes details second problem extremely rapid growth game tree avoided follows first limit possible moves online player allowing paid exchanges special form socalled subset transfers 13 subset transfer chooses items front requested item x puts order directly behind x eg 12345x67 13x24567 afterwards adversarys strategy computed weak online player tested deterministic strategies online player done quickly dynamic programming lower bound still holds strong online player may use arbitrary paid exchanges cannot profit additional power 4 game tree gadgets compose game tree two types trees gadgets first gadget called flup finite list update problem small irregular structure second gadget called ic inversion converter regularly structured gadgets come randomized strategy adversary computed linear programming flup instance ic appended leaf flup resulting tree specified strategy adversary defines oneplayer decision problem online player expected strict competitive ratio least 15 150084 simplest version flup found larger versions flup give higher lower bounds gadgets assume particular state offline list parameter determines adversary strategy furthermore root flup beginning entire game assumed online offline list state say 12345 adversary strategy flup generates request sequences 4 425 4253 4254 positive probability sequences 6 prefix thereof responses online player one request sequences flup tree terminates leaf particular status online list offline list latter also chosen adversary independently online list request sequence 4 offline list 41235 offline algorithm moved 4 front flup game terminates request sequence 425 adversary makes additional internal choice unobserved online player offline lists 51234 52134 first case offline player brought 5 front left 4 2 place second 2 also moved front similar choices performed offline lists request sequences 4253 4254 requests offline list probability mtf specific probabilities choices adversary flup shown 10 last three columns denote cost offline algorithm example two online algorithms mtf wait wait moves item front second request flup tree starts 4 first request followed possible responses online player next adversary exits probability 3961184 without request leaf offline list 41235 complementary probability requests item 2 followed online move leaf flup tree root ic gadget generates requests similar runs teias construction see depending offline list number inversions online list relative offline list denoted 10 purpose ic gadget convert inversions actual costs request sequence generated ic gadget treated offline cost v thereby online algorithm makes mistakes relative offline algorithm additional online cost ic 15v let online cost incurred inside flup flup represented game tree ic gadget leaf replaced payoff adversary using payoffs probabilities 10 computed linear programming one show online strategy represented flup tree expected strict competitive ratio least 15 1 150084 two optimal online strategies mtf wait values used 11 also shown 10 wait moves item 4 front end request sequence 4254 welldefined behavior ic gadget allows replace single payoff 11 furthermore online player knows flup gadget left ic gadget entered since ic starts request first item offline list like 4 list 41235 first row 10 context make certain assumption internal choice adversary different offline lists namely start ic gadgets offline lists 12345 13524 follow request sequence 4253 first request 1 online player cannot yet tell ic gadget entered strictly speaking two gadgets bridged appropriate information sets online player however assume instead internal choice adversary two lists revealed online player beginning ic implicit replacing ic single payoff allowed since merely weakens position adversary online strategy without extra information also used online player informed adversarys internal choice online payoff cannot worse offline list assigned leaf flup gadget part optimal offline treatment computed similar 13 entire request sequence however list may even part suboptimal offline treatment suffices showing lower bound since merely increases denominator 9 offline costs 10 realized paid exchanges offline algorithm example requests 4253 served cost 10 yielding offline list 23451 initial paid exchanges move 1 end list free exchanges achieved moving every requested item front 1 would result higher costs remainder section describe ic gadget purpose convert inversions end flup game real costs maintaining lower bound least 15 time inversions destroyed online list offline list order serving ic ic extends construction teia 16 described section 2 let k sequence requests first k items current offline list ascending order requesting item probability 12 either three times assume offline algorithm treats k moving item requested three times front first request leaving item place optimal triply requested items reverse order first items new offline list followed remaining items order n run used teias construction list n items random request sequence generated written w n wfold repetition n w goes infinity note offline list hence order requests changes one run n next 2 example repetition two identical sequences optimal offline treatment k costs units difference construction teias use prefix elements offline list show already proved see 5 see 12 also k n use projection pairs consider case two items none two items occur k sides 12 zero definition projection pairs ignores items projected one item occurs k first one offline list requested k online algorithm incurs cost least one inversion shows 12 5 12 extended concatenations sequences k let ic randomly generated sequence defined preceding considerations fulfills ei 13 inversions left serving ic inversions would indeed converted actual costs otherwise suppose serving ic inversion two items x say x front final offline list definition ic item x requested least three times last request online player could saved cost unit moving x front list second request x summarize sequence ic produces additional online cost unit every inversion holds online offline list end ic however assume without loss generality lists state ic namely online player could well served ic intended leaving inversions invested saved cost units creating inversions beginning next flup gadget costs taken account thus indeed 13 holds ei inversions become actual costs stated 11 offline costs since online offline list identical end ic new flup game started generates request sequences arbitrary length way obtain lower bound 15 competitive ratio c 2 additive constant b construction value lower bound depend whether online player may use paid exchanges adversarys strategy use paid exchanges seems online player cannot gain additional power paid exchanges raises conjecture restricting players free exchanges list update problem might still optimal competitive ratio 15 however false randomized adversary strategy offline algorithm uses free exchanges cannot served better competitive ratio 1515048 length sequences used corresponding flup game result difficult obtain first sequences used game found brute force dynamic game tree search alphabeta pruning approximate game approximate game online player restricted small set random moves similar poset algorithm secondly argument order elements online list leaving ic gadget longer holds resolved elaboration method details beyond scope paper extending result full cost model requires systematic treatment lists arbitrary length n easy ic gadget obviously difficult flup gadget hope clarify connection flup sequences 6 beat partial order approach make progress direction r improved randomized online algorithms list update prob lem combined bit timestamp algorithm list update problem list update posets survey selforganizing data structures power randomization online algorithms amortized analyses selforganizing sequential search heuristics online computation competitive analysis optimal online algorithm metrical task systems two results list update problem fast algorithms finding randomized strategies game trees extensive games problem information optimum offline algorithms list update problem randomized competitive algorithms list update problem amortized efficiency list update paging rules lower bound randomized list update algorithms efficient computation behavior strategies probabilistic computations towards unified measure com plexity tr amortized efficiency list update paging rules amortized analyses selforganizing sequential search heuristics power randomization online algorithms two results list update problem optimal online algorithm metrical task system lower bound randomized list update algorithms fast algorithms finding randomized strategies game trees combined bit timestamp algorithm list update problem online computation competitive analysis improved randomized online algorithms list update problem selforganizing data structures
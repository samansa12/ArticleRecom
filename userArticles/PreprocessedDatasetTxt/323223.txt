analytical modeling setassociative cache behavior abstractcache behavior complex inherently unstable yet critical factor affecting program performance method evaluating cache performance required give quantitative predictions missratio information guide optimization cache use traditional cache simulation gives accurate predictions missratio little direct optimization also simulation time usually far greater program execution time several analytical models developed concentrate mainly directmapped caches often specific types algorithm give qualitative predictions work novel analytical models cache phenomena presented applicable numerical codes consisting mostly array operations looping constructs setassociative caches considered extensive hierarchy cache reuse interference effects including numerous forms temporal spatial locality models effect given combined predict overall missratio advantage models also indicate sources cache interference accuracy models validated example program fragments predicted missratios compared simulations shown typically within 15 percent evaluation time models shown independent problem size generally several orders magnitude faster simulation b introduction cache performance one critical factors affecting performance software memory latency continuing increase respect processor clock speeds utilizing cache full potential essential yet cache behavior extremely difficult analyze reflecting unstable nature small program modifications lead disproportionate changes cache miss ratio 2 12 method evaluating cache performance required give quantitative predictions miss ratio information guide optimization cache use johndcswarwickacuk traditionally cache performance evaluation mostly used simulation emulating cache effect every memory access software although results accurate time needed obtain prohibitive typically many times greater total execution time program simulated 13 another possibility measure number cache misses curred using performance monitoring features modern microprocessors also give accurate results reasonable time introduces restriction cache architectures actual hardware available evaluated try overcome problems several analytical models cache behavior developed one technique extract parameters address trace combine parameters defining cache derive model cache behavior 1 method able accurately predict general trends behavior lacks fine detail needed model instability noted analytical models combined heuristics also used guide optimizing compilers choice source code transformations 14 4 10 models developed however usually unsuitable general performance evaluation since often aim qualitative rather quantitative predictions another area analytical models employed studying cache performance particular types algorithm especially analysis blocked algorithms 9 3 5 attempts made creating general purpose models accurate expressive success 12 6 7 cases limited describing directmapped caches work present novel analytical techniques predicting cache performance large class loop nest ings general case setassociative caches ie directmapped case associativity one forms cache reuse interference considered leading accurate yet rapidly evaluated models benefits others demonstrated examination several example code fragments work wide range possible applications aiding software development fly performance prediction management also plan integrate model existing system analyzing performance parallel systems 11 paper organized follows next section outlines problem addressed classification cache phenomena modeled section 3 describes detail effect array references cache represented representation efficiently computed sections 4 5 6 different types cache reuse considered terms representation developed section 3 finally section 7 presents experimental data showing models compare simulation followed discussion results conclusions sections 8 9 enddo enddo enddo figure 1 general form considered loop constructs 2 overview methodology 21 concepts models presented work consider cache behavior array references accessed regular looping constructs general form loop nesting shown figure 1 loops numbered 1 n outertoinnermost respectively assumed normalized count upward zero steps one number iterations performed loop level k labeled n k variable used index arrays loop labeled j k array references considered form x name array number dimensions array ff k fi k fl k constants 1 array references rearranged form linear expression giving address element accessed particular combination values general form constants base address array fi k values combine form b values derived loop multipliers ff k dimensions array without loss generality assume array indices fortran style values terms array elements concept iteration space also important loop bounds represent full ndimensional iteration space array reference examined limiting range certain loops iteration space also restricted example allowing j 1 value 0 single iteration outermost loop specified modeling cache behavior restriction iterations natural way consider problems however work need restrict upper bound loops loop k handled binding temporary value n k given two array references r 1 r 2 linear forms identical said translation means access patterns references identical offset jb 1 b 2 j elements address space references translation one another said translation group 22 evaluation strategy function cache provide data reuse enable memory regions recently accessed subsequently accessed much smaller latency two basic forms reuse exist self dependence reuse array reference repeatedly accesses elements array group dependence reuse elements repeatedly accessed recently used different array reference considering array reference r reuse dependence r defined reference reuse arises self dependence conversely r 6 r group dependence since possible two references access data elements identifying dependences r defined reference smallest reuse distance r related number loop iterations occurring r accessing element r reusing unlike well known system classifying cache misses three cs model compulsory capacity conflict misses 8 method presented paper uses two part model compulsory misses defined capacity conflict misses considered single categoryinterference missessince underlying cause reusable data ejected cache predict number cache misses suffered array reference interference divided several types dependent source self interference occurs reference obstructs reuse internal cross interference occurs due references translation group external cross interference caused references different translation groups sections 5 6 describe effects modeled self group dependences respectively distinction also made temporal spatial components references miss ratio spatial miss ratio defined average number cache misses needed load single cache line data three types interference contribute ratio modeled section 4 spatial miss ratio applied predicted number temporal misses give total number cache misses reference repeating procedure references loop nesting gives prediction entire code fragment modeling cache footprints common requirement modeling interference identify effect cache accessing references single translation group specified psfrag replacements cla cache representation psfrag replacements line data b example figure 2 examples cache layout set overlap iteration space effect cache known used predict effect reuse references examined resulting number cache misses predicted cache size c l elements line associativity considered rectangular grid cla cache lines wide lines deep shown figure 2a vertical column represents single set cache containing lines mapping function determines set memory element stored usual mapping function paper examines simply x mod cla x address element question line set actually used depends replacement strategy employed paper leastrecentlyused strategy considered replacing line set last accessed earliest given view cache effect translation group cache also visualized cla sets certain number lines contain data accessed translation group number thought overlap set labeled figure 2b shows example small 4way setassociative cache 4 data elements loaded cache darkly shaded value set shown underneath identify interference cache footprints compared footprints data reused either setbyset statistically whole method detecting interference simple occurs wherever combined overlap footprints greater level associativity model represents cache footprint sequence regions region constant value overlap well two parameters define region first element region ie value zero ca 1 number elements region considering example footprint figure 2b clear defined following sequence regions start size rest section paper show footprints form calculated efficiently individual translation groups psfrag replacements oe k1 oe k1 cache sets time array footprint region cache data figure 3 example mapping array footprint regions cache 31 finding cache footprint single reference accurate method mapping regular data footprint directmapped cache previously presented detail 7 12 consider problem briefly extending method given 7 descended 12 setassociative caches given array reference wish find cache footprint data accesses particular iteration space form defined values structure array elements defined reference array dimensions iteration space majority array references encountered array footprint expressed using four parameters address first element oe number elements contiguous region distance start two regions oe finally number regions n identifying four parameters array footprint describe mapped cache give cache footprint reference question cache footprint defined parameters similar describing array footprint interval regions oe number regions n position first 1 region oe two parameters define structure data elements region level overlap defined section 3 number elements region divided overlap considering figure 2 thought average height width region footprint find parameters defining cache footprint use recursive method dividing cache regular areas level recursion k areas size oe k mapped single area size oe k1 illustrated figure 3 part cache recurrence relation defines sequence oe k values representing array footprint regions map cache sequence truncated level either n regions map cache without overlapping overlapping occurs regions detect 1 first region one nearest cache set zero first region sequence n sequence may cross cache boundary overlap either end area size oe k1 value oe k introduced smallest distance two regions area oe k overlapping occurs level k level cache divided oe 0 oe s1 areas size oe s1 certain number footprint regions size distance oe previous r areas contain n areas containing n simplest case ie array footprint didnt wrap around end cache overlapping general case 1 distance area total number areas c position first region also found overlap single area found dividing total number elements distance start first region end last average level overlap found combining overlap types area n oe distance start first region end last 2 find single area size gaps regions subtracted distance start first region end last region finding values types area combined function f x gives value area containing x regions oe previous 32 combining individual cache footprints using techniques presented previous section cache footprint reference defined iteration space identified gives information necessary predict reference interacts footprints references thus allowing interference detected generally however two references loop nesting therefore interference reference originate one source 2 note x well modeling interference reference loop nesting also important interference single element counted simply comparing cache footprint every reference loop footprint reference examined meet requirement noted section 21 possibly classify array references loop nesting translation groups members group exactly access pattern difference patterns offset one another address space allows references translation group combined single cache footprintit metafootprint used identify interference problem stated follows given q references translation necessary find cumulative cache footprint refer ences assuming array footprint references defined parameters values oe q combined cache footprint defined sequence regions defined triples oe position region size elements level overlap shown 1 321 finding onedimensional footprint examining calculations section 31 shows parameter cache footprint depending oe oe position first region defined mod ca follows therefore references r share cache footprint individual values oe oe property easy visualize form cylinder rectangular representation cache figure 2a first last sets adjacent one another surface area cylinder represents cache project cache footprint onto cylinder starts first element cache ie rotating footprint oe positions 3 around circumference cylinder actual cache footprint simplifies problem finding combined cache footprint instead computing q footprints merging necessary compute one footprint consider rotated copies generating position every footprint region definition oe given start end points region cache footprint reference enumerated region starting positions reference r defined series theta position end region theta 3 rather oe mod ca since circumference cylinder ca one possible method merging q footprints would enumerate start end positions reference sort smallest first order fortunately much efficient method rotated footprint cross boundary cache position ca position zero allows start end positions region generated numerical order generating points cache boundary followed points cache boundary first starting points region footprint reference con sidered first region counting zero start position ca start oe list starting positions 6 split two recombined list positions ascending order theta theta assuming operator concatenates two lists similar method used generate end points region footprint reference r first end point cache position ca oe list end points numerical order theta theta merging q footprints given q lists region start positions q lists end positions defined previous section straightforward construct new list regions two regions overlap end product process sequence triples form oe two values oe define position size region v bitvector v region subset reference individual footprint seen consequence v since level overlapping region directly related references accessed region merging process straightforward since lists region boundaries known ascending numerical order working value v main tained initially set reflect references whose footprints wrap around end start cache elements left 2q lists list smallest first element found element deleted footprint region created previously found point current point current value v assuming list refers reference r k list start points v k set one otherwise set zero 322 finding cumulative overlap region merging references footprints previous section structure translation groups cache footprint almost complete instead representation required form oe problem calculate given vector v average level overlap references cache footprint already calculated 5 using logic section 321 references translation group must value natural method finding simply multiply number bits v set ie number references region considering caches work seen method guaranteed work two references access array two references access array possibility could intersection two sets array elements accessed intersection occurs elements stored cache twice predicted take 2 overlap two references combined feature means amount sharing two references must examined define ratio ranging zero elements common one elements accessed references ratio sharingr x ry two references r x ry calculated array footprint translation groupthe parameters oe n oe defined section 31 calculating sharingr x ry definition sharingr x ry consists two expressions degree sharing two array footprints considered two contiguous regions degree sharing individual regions inside footprints distinction two concepts shown figure 4 two references r x ry first single regions sequence regions considering footprints two single regions figure 4a seen distance two regions joe j subtracting value total extent region n oe gives total number shared ele ments hence ratio shared elements n oe joe level sharing two regions footprint figure 4b found similar manner distance two possibly overlapping regions joe overlapping could occur either direction smallest possible distance overlapping regions ffi defined sharing otherwise ffi elements shared two regions ratio defining level sharing two regions ffi multiplying two sharing ratios footprints whole two regions gives overall ratio shared elements two psfrag replacements r x ry footprints single regions psfrag replacements r x ry b footprints multiple regions figure 4 array footprint sharing footprints ie finding region sharingr x ry function defined 7 allows combined level overlap two references found example rxry level overlap occurring r x ry access region cache rx ry overlaps individual references rx ry overlap shared r x ry second line equation follows since references translation merged way intersection directly related many elements two references share average across entire cache find average level overlap across references fr necessary extend union operator shown include arbitrary number references considering 8 evident similarity finding combined overlap number elements union sets 8 analogous general form expression number elements union stands summation ielement combinations expression analogous r1 deltadeltadeltar n exactly way 9 analogous 8 therefore still necessary define average overlap intersection arbitrary number references tworeference intersection shown 8 extended arbitrary number references symbol stands product twoelement combinations r r j possible find average overlap cache footprint region containing references defined vector v computing 10 references included region ie set fr 323 notes optimizing calculation method shown previous paragraphs obviously highly combinatorial nature bit vector v contains n ones number multiplications required grows rapidly making computing slow relatively small values n example one main reasons using analytical methods increased speed clearly unde sirable fortunately two straightforward modifications push combinatorial barrier back distance firstly value completely evaluated boundary footprint region considering identity shows adaptively calculated previous regions value single reference enters leaves union approximately halves number multiplications required secondly since one constraints model array may overlap arrays sharing data elements references accessing different arrays means subset vector v need examined computing v reference r accesses array accessed array reference whose state changed region boundary depending upon distribution array references arrays modification decrease complexity calculation orders magnitude modeling spatial interference noted section 2 temporal spatial cache effects array reference modeled separately spatial reuse occurs one element cache line accessed data ejected cache reference r innermost loop spatial reuse may occur labeled l l spatial miss ratio reference labeled defined multiplying predicted number temporal misses suffered reference predicts actual number cache misses occurring ratio encapsulates spatial effects reference found combining four specific miss ratios compulsory miss ratio c self interference miss ratio internal cross interference miss ratio finally external cross interference value c particular reference follows directly array footprint reference defined loops ratio number cache lines footprint region number referenced elements within region studying level interference affecting spatial reuse dependence necessary examine happens iteration loop l figure 5 illustrates self interference left hand side figure shows square matrix accessed array reference y2j right shown maps cache time complete iteration loop j 1 assuming 4way associative cache elements may interfere y6 0 reusing data loaded cache y4 shaded three types spatial interference considered following sections 41 calculating spatial self interference shown figure 5 reference modeled obstruct spatial reuse happens number data elements accessed single iteration loop l map particular set cache greater level associativity analyze mapping process recurrence shown 2 used slightly different array footprint parameters distance footprint region oe defined distance elements accessed successive iterations loop l see figure 5 size psfrag replacements time ca elements reused elements may interfere figure 5 example spatial reuse y2j 1 footprint region defined size cache line l ensure interference lines detected section 31 result mapping process cache divided oe 0 oe s1 areas size oe s1 certain number footprint regions distance oe previous r areas contain areas containing n section 31 examining two types area separately calculating value combining two values possible predict overall level self interference function f x gives probability element area size oe s1 containing x elements suffer spatial interference immediately possible identify two special cases 1 oe elements area occupy cache set number elements x greater level associativity interference occurs thus 2 one element per set overflow neighboring areas reuse must total general case solution straightforward main complication possibility distance first last element area ie xoe greater size area therefore elements wraparound end area possibly interfering start handle hybrid analyticalsimulation technique used x elements area l different positions cache line might occur position analyzed whether reuse occur leading overall probability reuse element repeating x 1 elements combining individual probabilities gives value f x element possible list positions cache elements surrounding stride oe 0 stride reference distance elements accessed successive iterations spatial reuse loop l essence problem follows pointsy deduce number points occur cache linesized region z points wrap around zero position oe s1 generalized form series defined general series number points within interval z including wrap around effect given oe upsilon oe upsilon min z thus find total number elements within particular cacheline sized interval expression evaluated beforey aftery total number elements particular interval z value number elements particular line greater level associativity self interference occurs averaging l1 possible positions start line containing interval probability reuse found repeating process x 1 elements area overall probability hence calculated 42 internal spatial cross interference well caused reference spatial interference may also arise due references translation group number data elements mapping particular cache set single iteration loop l greater level associativity interference occur phenomena often referred pingpong interference may affect performance massively since possible spatial reuse reference prevented considering reference r pingpong interference detected calculating cache footprint references translation group single iteration spatial reuse loop ie let n considering regions less l elements position first element accessed r ie oe r mod ca ping pong interference occurs assuming closest footprint region oe r mod ca positions away closest region r ffi positions away miss ratio due internal interference defined follows 43 external spatial interference considering interference references translation group interference translation groupsexternal interferencemust modeled group examined turn overall miss ratio due external sum groups individual external interference ratio reference r spatial reuse loop l probability pr accessing random data element find element set containing data spatially reused r defined ca nr sr number size regions reference rs cache footprint loop l respectively see section 31 restricting iteration space single iteration loop l ie let n 1 cache footprint translation group r member examined counting number elements footprints could cause spatial interference r multiplying pr prediction number misses made average level overlap translation group containing r r footprint translation group represented sequence oe individual footprint region possibly interfere r r occur number cache misses set greater actual number elements set leads definition following function giving miss overlap mapping function multiplied size region cache footprint translation group gives total number elements accessed group might cause cache miss 4 multiplying value pr dividing total number iterations made loop l gives external miss ratio single translation group g pr miss symbol stands summation across translation groups cache footprint regions oe groups g r 62 g overall value e found 5 cache behavior self dependence noted section 2 self dependence occurs array reference accesses particular data elements happens one loop variables used reference example array reference use j 2 therefore iterations loop 2 access exactly set elements namely fa0 g innermost loop reuse occurs defined loop l g theory time loop l entered first iteration would load referenced elements cache subsequent iterations reuse first iteration loop l must load elements gives number compulsory misses spatial miss ratio multiplied number times loop l entered multiplied number unique elements referenced cache capacity limitedit may possible hold elements referenced loop l cache factor dependent whether size cache greater number elements spatial reuse accessed elements may map cache way prevent reuse although using cache high associativity prevent 4 referenced array significantly smaller number sets cache footprint regions actually overlap array considered interference certain cases number elements accessed increases problem may return 51 self interference self interference reference modeled mapping array footprint elements accessed single iteration loop l cache removing elements fall sets overlap greater level associativity subtracting number elements left original number elements gives number cache misses per iteration use mapping process shown section 31 one important modification function f x replaced f r x way calculated changed reflect whereas f x gave number sets could interfere area containing x regions f r x gives number reused ie given f r x number reusable elements footprint follows ns therefore total number cache misses due self interference number times loop l entered multipled number cache misses iteration excluding handled compulsory miss calculation shown 13 definition function f r x uses similar method shown section 41 calculating spatial self interference structure cache section examined described section 31 area size oe s1 containing x regions size interval oe previous first region located beginning area regions wrap around end area ie position area region k actually koe mod oe s1 area structure function f r x must calculate number positions level overlap less equal level associativity ie interference occurs single position z area level overlap ie number regions crossing point given number regions beginning point minus number regions ending include wrapping effect expression summed possible wrap arounds region appears ie oe upsilon min oe z possible definition f r x would test every position area ie count number times overlapz fortunately efficient method since x footprint regions value overlapz change maximum 2x times start end region using similar method finding onedimensional footprint translation group see section 321 2x positions enumerated ascending order atomic regions define examined finally definition 5 includes positions area reuse cannot occur since still relevant calculating interference however looking reuse footprint necessary average overlap positions footprint reuse occur calculated computing value f r x 52 internal cross interference examining level self interference self dependent reference cache footprint data subject self interference known characterized parameters oe n still uncertain whether regions cache reused since data accessed array references loop nesting may map cache sets possibly preventing reuse interference references translation group considered first cache footprint references identified using techniques shown section 3 compared region region footprint data subject self interference interference occur wherever two footprints overlap combined level overlap greater level associativity assuming two footprint regions overlap size positions number misses occurring iteration loop l size theta miss summation expression sections cache two footprint regions overlap gives total number cache misses iteration reuse loop multiplying l gives total number misses increase accuracy next stagepredicting level external interferencethe values ns number reusable positions average overlap adjusted take account internal interference number reusable positions considering internal interference ns 0 combined size regions interference doesnt occur adjusted overlap 0 average value across regions 53 external interference final source temporal interference self dependence considered external cross interference interference arising references translation groups reference examined unlike modeling internal cross interference possible simply compare two cache footprints references possibly reusable data footprint interfering translation group exactly translation footprints moving cache different ways hence incom parable instead statistical method used based dimensions two footprintsthe total size average overlap similarly modeling external interference spatial dependences see section 43 external translation group considered turn number footprint positions could possibly cause interference found summation cache footprint group find average number cache misses quantity multiplied size reusable footprint divided number possible positions external theta miss ca gives number misses iteration loop l caused particular translation group summing expression external groups multiplying total number iterations loop l gives actual number cache misses due external interference 6 modeling group dependences group dependence occurs array reference reuses data recently accessed another reference translation group reference r reference dependent upon denoted r section 22 described dependences identified definition spatial miss ratio given section 4 must altered slightly model group dependences must also include spatial group reuse occurring r cache line r certain number times per every l elements accessed constant distance two references b r br less size cache line number times r must load element per cache line therefore actual spatial miss ratio defined number compulsory misses defined number elements accessed r r multiplied spatial miss ratio since defined 7 gives ratio elements shared r x ry compulsory sharing r r reference r innermost loop group reuse occurs defined l ff number dimensions array accessed identify cross interference group dependence necessary examine period r accessing arbitrary element r reusing defined iterations loop l g k innermost dimension array fi k constants two references differ consider example case l 2 r accesses element aj 2 2 two iterations loop 1 pass r accesses element interference occurs element ejected cache two iterations 61 internal interference internal cross interference found examining cache footprint translation group r first ffi g iterations loop l g ie iteration space region footprint contains data accessed r probability interference calculated maximum probability across whole footprint actual probability internal interference footprint region average overlap probability defined ie interference definitely occur definitely doesnt occur gradient two certainties number cache misses defined number elements could theoretically reused multiplied maximum value p spatial miss ratio int lg sharing r r 62 external interference maximum value p less 1 therefore internal interference total external cross interference must also considered iteration space defined ffi g iterations loop l g time cache footprints translation groups r member examined group number cache misses caused found counting number positions footprint interference may occur applying probabilistic method used predicting external interference self dependence see section 53 assuming cache footprint translation group containing r average overlap 0 regions containing data accessed r calculated finding internal interference footprint region overlap may possibly cause interference actual number misses per translation group defined ext theta miss 1a theta ca 1 maxp 7 example results demonstrate validity benefits techniques described section presents experimental results obtained using implementation model code fragments expressed simple language allows details arrays accessed loop structures array references specified three examples typical nested computations shown chosen contrasting characteristics ensure parts cache model exercised manipulates matrices double precision values arranged single contiguous block memory 1 matrixmultiply consisting three nested loops containing four array references total reference allows temporal reuse occur within one loops one reference may subject considerable spatial interference fortran code shown figure 6a 2 stencil operation 10 kernel shows group dependence reuse doesnt always access memory sequentially see figure 6b 3 two dimensional jacobi loop 2 originally part application computes permeability porous media using finite difference method kernel exhibits large amounts group dependence reuse contains significantly array references others matrices ivx ivy contain 32bit integers see figure 6c example kernel evaluated range cache parameters comparing predicted miss ratio given standard simulation techniques 5 average percentage errors shown table 1 results shown figure 7 three example kernels miss ratio absolute error plotted width height matrices also shown table 2 range times taken evaluate problem 167mhz sun ultra1 workstation single cache configuration 5 locally written cache simulator used accepts loop descriptions form analytical model uses validated comparing results hills dinero iii tracedriven simulator 8 enddo enddo enddo matrix multiply enddo enddo b stencil enddo enddo c 2d jacobi figure example kernels experimental data presented previous section shows predictions made model generally accurate majority average errors within ten percent three fifty four examples average errors less fifteen percent combined increased speed prediction believe analytical approach practical simulation examining individual kernels application one motivations work minimize time taken evaluating program fragment expected analytical model much quicker compute simulation typically several orders magnitude even smallest problem sizes number memory references grows gulf widens simulation time increasing proportionally number accesses time needed evaluate analytical model staying mostly constant jacobi example slowest evaluate analytically eighteen array references evaluate compared stencils six matrix multiplys four even combinatorial effects might feared problem also clear miss ratio plots using setassociative caches c16384 l32 a1 n predicted missratio difference simulation c16384 l32 a2 n predicted missratio difference simulation c16384 l32 a4 n predicted missratio difference simulation c32768 l16 a1 n predicted missratio difference simulation c32768 l16 a2 n predicted missratio difference simulation c32768 l16 a4 n predicted missratio difference simulation matrix multiply c16384 l32 a1 n predicted missratio difference simulation c16384 l32 a2 n predicted missratio difference simulation c16384 l32 a4 n predicted missratio difference simulation c32768 l16 a1 n predicted missratio difference simulation c32768 l16 a2 n predicted missratio difference simulation c32768 l16 a4 n predicted missratio difference simulation stencil c16384 l32 a1 n predicted missratio difference simulation c16384 l32 a2 n predicted missratio difference simulation c16384 l32 a4 n predicted missratio difference simulation c32768 l16 a1 n predicted missratio difference simulation c32768 l16 a2 n predicted missratio difference simulation c32768 l16 a4 n predicted missratio difference simulation figure 7 predicted miss ratios absolute errors configurations experiment l matrix 2 385 702 407 622 489 612 multiply 4 242 489 329 351 390 397 table 1 average percentage errors example predictions compared simulated results analytical model simulation experiment min max mean min max mean matrix mult 000093 stencil table 2 calculation times experiments seconds avoid problem cache interference even 4way associative cache still large variations miss ratio especially stencil jacobi kernels ie number array references increases using using well known techniques padding array dimensions controlling base addresses guided analytical model presented variations reduced decrease miss ratio benefit using analytical models yet mentioned extra information available using analytical models trying lower number cache misses program important know cache misses occur due structure method presented paper requirements met simply examining outputs component models example matrix multiply kernel examine miss ratio reference figure 8a miss ratio due type interference figure 8b show vast majority misses due reference yjk 90 percent interference self interference case spatial self interference due array accessed nonsequentially 9 conclusions hierarchical method classifying cache interference presented self group dependent reuse data considering temporal reference miss ratios10305070900 20 40 compulsory internal external b miss ratio type figure 8 examining matrix multiply spatial forms analytical techniques modeling category interference developed array references loop nestings shown techniques give accurate results comparable found simulation implemented predictions made much faster rate simulation importantly prediction rate shown dependent number array references program rather actual number memory accesses simulation envisaged benefits modelsaccuracy speed predictionwill allow use wide range situations including impractical traditional techniques important example use runtime optimization programs using analytical models cache behavior algorithms drive optimization process areas addressed future work include optimization strategies well extensions model also intended use techniques part general purpose performance modeling system 11 acknowledgements work funded part darpa contract n66001 97c8530 awarded performance technology initiative administered nosc r analytical cache model skewed associativity improves program performance enhances predictability tile size selection using cache organisation data layout automatic cache performance prediction parallelizing compiler influence cross interferences blocked loops case study matrixvector multi ply cache miss equa tions analytical representation cache misses predicting cache miss ratio loopnested array references aspects cache memory instruction buffer per formance cache performance optimizations blocked algorithms quantitative analysis loop nest locality overview chip 3 performance toolset parallel systems cache interference phenomena data locality optimizing algorithm tr ctr arijit ghosh tony givargis cache optimization embedded processor cores analytical approach acm transactions design automation electronic systems todaes v9 n4 p419440 october 2004 andrade b b fraguela r doallo analytical modeling codes arbitrary datadependent conditional structures journal systems architecture euromicro journal v52 n7 p394410 july 2006 e papaefstathiou design performance technology infrastructure support construction responsive software proceedings 2nd international workshop software performance p96104 september 2000 ottawa ontario canada b b fraguela r doallo j tourio e l zapata compiler tool predict memory hierarchy performance scientific codes parallel computing v30 n2 p225248 february 2004 g r nudd j kerbyson e papaefstathiou c perry j harper v wilcox pacea toolset performance prediction parallel distributed systems international journal high performance computing applications v14 n3 p228251 august 2000 chunghsing hsu ulrich kremer quantitative analysis tile size selection algorithms journal supercomputing v27 n3 p279294 march 2004 lakshminarayanan renganarayana sanjay rajopadhye geometric programming framework optimal multilevel tiling proceedings 2004 acmieee conference supercomputing p18 november 0612 2004 jingling xue xavier vera efficient accurate analytical modeling wholeprogram data cache behavior ieee transactions computers v53 n5 p547566 may 2004 basilio b fraguela ramn doallo emilio l zapata probabilistic miss equations evaluating memory hierarchy performance ieee transactions computers v52 n3 p321336 march siddhartha chatterjee erin parker philip j hanlon alvin r lebeck exact analysis cache behavior nested loops acm sigplan notices v36 n5 p286297 may 2001 hans vandierendonck koen de bosschere highly accurate efficient evaluation randomising set index functions journal systems architecture euromicro journal v48 n1315 p429452 may
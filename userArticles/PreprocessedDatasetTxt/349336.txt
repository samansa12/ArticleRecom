generational onthefly garbage collector java onthefly garbage collector stop program threads perform collection instead collector executes separate thread process parallel program onthefly collectors useful multithreaded applications running multiprocessor servers important fully utilize processors provide even response time especially systems stopping threads costly operation work report incorporation generations onthefly garbage collector incorporation nontrivial since onthefly collector avoids explicit synchronization program threads best knowledge incorporation tried implemented collector prototype java virtual machine aix measured performance 4way multiprocessor generational collectors onthefly generational collector potential reducing overall running time working set application concentrating collection efforts young objects however contrast generational collectors onthefly collectors move objects thus segregation old young objects furthermore onthefly collectors stop threads extra benefit short pauses obtained generational collection nevertheless comparing onthefly collector without generations turns generational collector performs better applications best reduction overall running time benchmarks measured 25 however benchmarks effect one overall running time increased 4 b introduction garbage collectors free space held unreachable dead objects space reused future allocations multiprocessor platforms desirable stop program perform collection single thread one processor leads long pause times poor processor utilization several ways deal problem exist two obvious ways 1 concurrent collectors running collector concurrently mutators collector runs one thread one processor program threads keep running concurrently processors program threads may stopped short time initiate andor nish collection 2 parallel collectors stopping program threads completely running collector parallel several collector threads way processors utilized collector threads ibm haifa research lab email tamarilibmcom ibm haifa research lab email kolodnerilibmcom z computer science dept technion israel institue technology work done author ibm haifa research lab email erezcstechnionacil paper discuss concurrent collector particular onthe collector stop program threads study onthe garbage collectors initiated steele dijkstra et al 27 28 8 continued series papers 9 14 3 4 20 21 culminating doligezleroygonthier dlg collector 11 10 advantage onthe collector parallel collector types concurrent collectors 1 13 24 avoids operation stopping program threads operation costly usually program threads cannot stopped point thus nonnegligible wait last many threads reaches safe point may stop drawback onthe collectors require write barrier handshakes collector mutator threads collection also typically employ negrained synchronization thus leading errorprone algorithms generational garbage collection introduced lieberman hewitt 23 rst published implementation ungar 29 generational garbage collectors rely assumption many objects die young heap partitioned two parts young generation old generation new objects allocated young generation collected frequently young objects survive several collections promoted older generation generational assumption ie objects die young indeed correct get several advantages 1 pauses collection young generation short 2 collections ecient since concentrate young part heap expect nd high percentage garbage 3 working set size smaller program repeatedly reuses young area collector traces smaller portion heap 11 work paper present design incorporating generations onthe garbage collector two issues immediately arise first shortening pause times relevant onthe collector since stop program threads second traditional generational collectors partition heap generations physical sense namely promote object young generation old generation object moved young part heap old part heap onthe garbage collectors move objects cost moving objects running concurrently program threads high thus without demers et al 6 presented generational collector move objects motivation adapt generations conservative garbage collection build work design generational collector dlg onthe garbage collector 11 10 implemented generational collector jdk 116 prototype aix compared performance implementation dlg onthe collector results show generational collector performs well applications benchmarks ran multiprocessor best reduction overall program runtime 25 however one benchmark generational collection increased overall running time 4 several properties application dictate whether generational collection may benecial overall performance first generational hypothesis must hold ie many objects indeed die young second important application modify many pointers old generation otherwise cost handling intergenerational pointers high last lifetime distribution objects fool partitioning generations tenured objects old generation actually dead matter promotion policy get increased eciency partial collections collecting old generation frees fraction objects collecting young generation may well collect whole heap since care pause times furthermore overhead paid maintaining intergenerational pointers cause increase overall running time application used benchmarks specjvm benchmarks 25 plus two benchmarks described section 82 benchmarks overall application performance improves generational collection anagram 25 improvement 213 javac 15 improvement 227 mtrt 10 improvement improvement multithreaded raytracer ranges 116 depending number application threads running concurrently application well 202 jess 4 increase overall running time two reasons deterioration lots objects old generation scanned intergenerational pointers objects get tenured die become unreachable following full collection 12 card marking hosking moss stefanovic 16 provide study write barriers generational collection among parameters investigate uence card size card marking barrier overall eciency applications measured best sizes cards 256 512 bytes worst sizes extremes 16 4096 bytes note advantage small cards indication pointers modied exact collector need scan big area nd intergenerational pointers needs card however small cards require space dirty marks reduces locality process choosing parameters collector run similar measurements various card sizes turns behavior onthe generational collector dierent best choice card sizes one extremes depending benchmark chose set card size minimum possible best benchmarks far best rest suspect primary reason results dier hosking et al 16 collector move objects provide details section 853 13 techniques used organization start state art dlg onthe collector 11 10 brie review section 2 construct generational collector similar work demers et al 6 presenting section 3 augment dlg work better generations utilizing additional color section 4 also using colortoggle trick reduce synchronization section 5 similar trick previously used 21 17 7 22 19 rst promotion policy trivial promote object survives single collection also study options promote objects several collections section 6 section 7 provide code collector lower level details appropriate implementer section 8 report experimental results measured justify choice parameters conclude section 9 2 collector build dlg collector 11 10 onthe collector stop program collection two important properties collector make ecient first employs negrained atomicity namely instruction carried without extra synchronization second require writebarrier operations using stack registers write barrier required modications references inside objects heap original papers also suggest using thread local heaps design assumes abundant use immutable objects ml use thread local heaps start short overview dlg collector thorough description correctness proof reader referred original papers 11 10 collector mark sweep collector employs standard three color marking method objects white beginning trace root objects marked gray trace continues choosing one gray object marking black marking white sons gray process continues gray objects heap meaning colors black object object traced whose immediate descendants traced well gray object object traced whose sons yet checked white object object yet traced objects remain white end trace reachable program reclaimed sweep procedure shaded gray black objects recolored white sweep fourth color blue used identify deal fact collector onthe ie traces graph live objects objects modied program adjustments standard mark sweep algorithm required collector starts collection three handshakes mutator threads handshake collector changes status mutator thread cooperates ie indicates seen change independently responding rst handshake write barrier becomes active mutators begin graying objects pointer updates second handshake required correctness behavior mutators change result responding third handshake mutator marks roots gray ie objects referenced stack mutators check whether need respond handshakes regularly normal operation never respond handshake middle update creation object collector considers handshake complete mutators responded completing three handshakes collector completes trace heap sweeps mutators gray objects modifying object slot containing pointer collector completes trace live objects amount graying depends part collection cycle suppose reference object modied point another object b rst third handshake mutator marks b gray third handshake end sweep mutator marks gray mutators also cooperate collector creating object trace objects created black whereas created white collector idle sweep objects created black sweep pointer seen yet reclaimed sweep pointer passed created white ready next collection sweep pointer directly creation spot object created gray extra care must taken possible races create sweep however simple method colortoggle allows avoiding considerations discuss section 5 generational collection without moving objects describe approach generational collection relocate objects call collection young generation partial collection collection entire heap full collection design similar demers et al 6 design stoptheworld conservative collector ever incorporate features necessary support onthe collection clearing card marks without stopping threads additional color objects created collection color toggle avoid synchronization object allocation sweep instead partitioning heap physically keeping young generation separate place partition heap logically object keep indication whether old young may one bit indication several bits giving information age simplest version one promotes objects surviving one collection begin describing simpler algorithm discuss aging mechanism section 6 demers 6 notes object becomes old surviving one collection black color may used indicate object old clearly sweep objects survived last collection black turn objects white sweep interpret black objects old generation time one collection next objects created white therefore considered young next partial collection ie collection young generation everything falls quite nicely place trace want trace old generation indeed trace black objects sweep want reclaim old objects indeed reclaim black objects live objects become black thus also becoming old next collection full collection collection old young generation turn color objects white full collections similar partial collections 31 intergenerational pointers remains discuss intergenerational pointers pointers old objects point young objects since want trace old generation collection young generation must assume old objects alive treat intergenerational pointers roots maintain list intergenerational pointers similarly generational collectors may choose card marking 26 remembered sets 23 29 see 18 overview generational collection two methods maintaining intergenerational pointers implementation used card marking reason java expect many pointer updates cost update must minimal also extra bit available object headers required ecient implementation remembered sets card marking scheme heap partitioned cards initially cards marked dirty program thread mutator marks card dirty whenever modies card slot containing pointer collector scans objects dirty cards pointers young generation may turn card mark nd pointers card card marking maintains invariant intergenerational pointers may exist dirty cards size cards determines tradeo space time usage bigger cards imply less space required keep dirty marks time required collector scan dirty card nd intergenerational pointers tried powers 2 16 4096 found two extremes provided best performance see section 853 32 collector partial collection begins marking gray young objects referenced intergenerational pointers particular collector marks gray white objects referenced pointers dirty cards time card marks cleared clearing marks okay since surviving objects promoted old generation completion collection existing intergenerational pointers become intragenerational pointers advanced aging mechanism section 6 would check determine whether card mark could cleared handling intergenerational pointers mutators told mark roots using handshake mechanism followed trace remains unchanged nongenerational collector sweep sweep modied change color black objects back white full collection begins clearing card marks without tracing dirty cards collector also recolors black objects white allowing unreachable object reclaimed full collection mutators told mark roots collector continues trace sweep 33 triggering use simple triggering mechanism trigger partial collection parameter representing size young generation determined run partial collection triggered allocating objects accumulating size exceeding predetermined size 1 trigger full collection use standard method starting concurrent collection heap almost full heap manager cannot trigger exactly time thus predetermined bound serves lower bound trigger time 4 dealing premature promotion promoting objects survive collection infant objects created start collection immediately made old objects may die young already promoted old generation collect next full collection onthe collection objects also created collection cycle thus compounding promotion problem added simple mechanism avoid promoting objects created collection old generation advanced mechanism keeps age object described section 6 done introducing new color objects created collection cycle instead creating objects white black depending stage collection dlg algorithm create objects yellow collection yellow objects traced collector sweep turns yellow objects back white without reclaiming thus collector promote old generation one subtle point discuss technical section see section 7 forces exception rule particular rst third handshakes collector mutators also mark yellow objects gray 5 using colortoggle recall collection mutators allocate objects yellow trace changes color reachable white objects black design described far sweep reclaims white objects colors blue color nonallocated chunks changes color yellow objects white thus end sweep remaining white objects instead recoloring yellow objects sweep employ color toggle mechanism similar previous work 21 17 7 2 22 19 color toggle mechanism exchanges meaning white yellow without actually changing color indicators associated objects thus live objects remain either black yellow mutators go coloring new objects yellow yellow plays role white previous collection cycle new collection begins mutators begin coloring new objects white white begins playing role yellow color previous cycle implement color toggle use two color names allocation color clear color initially allocation color white clear color yellow times objects allocated using allocation color beginning collection cycle values allocation color clear color exchanged rst cycle means allocation color becomes yellow clear color becomes white trace reachable objects clear color turned gray objects allocation color traced color change sweep objects clear color reclaimed using toggle need turn yellow objects white sweep important avoid race create sweep need know sweep pointer order determine color new object newly allocated object always assigned current allocation color remark 51 discussion adequate generational collector one may easily modify original collector run improvement toggling black white colors comparison collector without generations feel fair let generational collector enjoy improvement therefore also added modication collector use generations thus comparison make generations 6 aging mechanism algorithm described far age indication combined colors promote objects survive one collection promotion policy extremely primitive question whether parameterized promotion policy may help keep age object ie number collections survived age initialized 0 creation incremented sweep time also x predetermined parameter determining threshold promotion old generation object reaches threshold sweep procedure stops incrementing age chose x predetermined threshold dynamic policies could easily implemented using aging mechanism old objects continue colored black however trace colors reachable objects black whether young old thus modication sweep required sweep recolors reachable objects young age less threshold allocation color continues leave old objects black reclaim objects clear color pseudocode sweep procedure appears figure 5 several changes card marking mechanism also required support aging simple clearing card marks beginning collection longer works since intergenerational pointers current collection cycle may remain intergenerational pointers next cycle furthermore must also ensure intergenerational pointers recorded correctly collection cycle race may occur setting resetting card marks elaborate race technical section see section 7 beginning partial collection collector scans card table colors gray young objects referenced pointers dirty cards young object referenced given card collector clears cards mark collector toggles allocation clear colors continues handshakes trace sweep full collection collector trace intergenerational pointers instead recolors black objects allocation color toggles allocation clear colors continues handshakes trace sweep initialization done full collection see initfullcollection figure clear dirty bits reason indicate dirty cards intergenerational pointers may still relevant following partial collections implementation question keep age one option object separate table chose keep separate table room objects headers importantly note sweep partial full collections goes ages objects increase thus reasons locality better go separate table touch objects heap keep byte per age although two three bits usually enough could locate age byte card mark color however would require synchronization writing byte eg via compare swap instruction empirical checks show synchronization costly typical java application note synchronized instruction would required good fraction pointer modications 7 technical details section provide pseudocode additional technical details paper written reader may skip section still get broad view collector purpose presenting code show generational mechanism ts dlg collector thus presentation code concentrates details related generations present details mechanism keeping track objects remaining traced present details threadlocal allocation mechanism necessary avoid synchronization threads object allocation see dlg papers 11 10 details mechanisms one dierence dlg separate handshake two parts posthandshake waithandshake instead using second collector thread figure 1 shows mutator routines uenced collector write barrier update routine object allocation create routine cooperate routine mutator must call regularly eg backward branches invocations code notation heapx denotes slot object address x figure 2 shows overall collection cycle figure 3 present routines called collector refer code assume reader familiar dlg collector 11 10 use following terminology taken paper period rst handshake second denoted sync1 period second handshake third denoted sync2 rest time ie third handshake beginning next collection cycle denoted async mutator perception periods depending times cooperated handshake delicate issue generational collector proper handling card mark set reset properly avoiding races maintaining correctness partition discussion simple algorithm aging algorithm assume table designated byte card holding card mark byte use 71 simple algorithm first consider handling card marks simplest algorithm without yellow color color toggle particular algorithm section 3 using algorithm collector marks live objects black promotes thus intergenerational pointer created trace complete thus card marks cleared beginning cycle without fear losing mark due race condition mutator add yellow color section 4 collector trace objects created yellow cycle thus must keep record pointer referencing yellow object object actually interested pointers black objects perform ltering collector solve problem keeping correct card marks parents yellow objects enough make sure order operations beginning collection cycle follows scan card table clear dirty marks start creating yellow objects notice clearcards code figure 3 precedes switchallocationclearcolors code figure 3 collection cycle code figure 2 next add color toggle section 5 window time check object intergenerational pointers scan card table color toggle collector checks mutator creates new intergenerational pointer referencing yellow object b collector miss pointer current collection furthermore color toggle object b becomes white ie clear color might collected current partial collection solve make exception treatment yellow objects dlg write barrier treat white objects sync1 sync2 rst third handshakes means usually short period time whenever dlg write barrier would shade white object gray also shade yellow object gray see markgray figure 1 additional point needs veried tracing always terminates without yellow color modication live objects turn white gray gray black since number live objects nite turn black end tracing always terminates still case yellow object either stays yellow till end trace may turn gray later black performing necessary modications note need card marking sync1 sync2 thus get small gain eciency card marking required async stage notice markcard called async write barrier code figure 1 summarize card marking occurs async clearing checking card marks collector done rst handshake second handshake clearing card marks collector toggles clear allocation colors thus mutators create new objects yellow color yellow objects may shaded gray write barrier sync1 sync2 72 aging algorithm next discuss aging algorithm collector must keep careful track intergenerational pointers collector stages two concerns first choice card marks clear statusm 6async markgrayheapxi markgrayy else collector tracing markgrayheapxi markcardx else markcardx create pick x 2 free allocationcolor return x cooperate statusm 6 statusc x 2 roots markgrayx statusm statusc statusm 6 async gray figure 1 mutator routines clear full collection initfullcollection handshakesync1 mark posthandshakesync2 switchallocationclearcolors waithandshake posthandshakeasync mark global roots waithandshake trace gray object pick gray object x markblackx object x heap blue figure 2 collection cycle card c dirtyc object x c gray switchallocationclearcolors temp clearcolor clearcolor allocationcolor allocationcolor temp initfullcollection object x heap allocationcolor card c colorx 6 black pointer 2 x markgrayi black handshake waithandshake statusc waithandshake 2 mutators wait figure 3 collector routines must done care reset second time collector clears card mark mutator may set case must make sure card mark remains set pointer object associated card young object solve rst problem mutators set card mark throughout collection also sync1 sync2 see figure 4 order clear card mark collector checks rst pointer young object exists card clears mark however could still race clearing collector setting mutator particular following interleaving mutator collector actions problematic say dirty mark question associated card 1 collector thread scans card nds intergenerational pointer determines cards mark cleared 2 collector actually clears mark program thread writes intergenerational pointer sets card mark 3 collector clears card mark since check step 1 allows outcome course events intergenerational pointer located unmarked card next partial collection referenced object may skipped trace reclaimed although live solve race let collector mutator act follows collector acts three steps instead naive two steps step 1 collector resets card mark step 2 checks whether card mark cleared ie whether young objects referenced finally step 3 answer step 2 collector sets card mark back idea encoded clearcards routine figure 6 update mutator involves two steps step 1 performs actual update step 2 sets card mark order steps important cases seen update routine figure 4 claim race longer destructive suppose mutator updating slot card storing intergenerational pointer assume update object contain intergenerational pointers thus crucial get new update noticed respect recording intergenerational pointer time collector checking whether dirty bit erased erases necessary assume processors see stores particular processor order two possible cases case 1 mutator sets card mark collector clears since mutator sets mark actual update mutator must performed update collector cleared card mark since collector checks intergenerational pointers clearing card mark get update performed collector checked intergenerational pointers thus collectors check nd intergenerational pointer collector set card mark case 2 mutator sets card mark collector clears case card mark remain set required summary new intergenerational pointer created card mark properly set pointer noticed subsequent collections 8 experimental results goal compare onthe collector without generations compare eects choices parameters governing generational version eg size cards size young generation use aging etc implemented original onthe collector 2 generational onthe 2 fair comparison also introduced blackwhite color toggle original onthe collector statusm 6async markgrayheapxi markgrayy else collector tracing markgrayheapxi markcardx gray figure 4 aging version modied mutator routines clear full collection initfullcollection handshakesync1 mark posthandshakesync2 switchallocationclearcolors waithandshake posthandshakeasync mark global roots waithandshake trace gray object pick gray object x markblackx object x heap blue allocationcolor figure 5 aging version collection cycle card c dirtyc object x c pointer 2 x markgrayi markcardc initfullcollection object x heap allocationcolor figure aging version modied collector routines collector prototype aix jdk 116 jvm measurements done 4way 332mhz ibm powerpc 604e 512 mb main memory running aix 421 additional measurements uniprocessor run powerpc 192 mb main memory running aix 42 runs executed dedicated machine thus although elapsed times measured variance repeated runs small runs done initial heap size 1 mb maximum heap size mb calculation trigger full collection without generations veried working set runs main memory eects due paging 81 measuring elapsed time onthe collector delicate point onthe collector measure performance run singlethreaded application multiprocessor garbage collector runs separate processor application measure elapsed time application know much time collector consumed second processor real world server handles many processes second processor come free order get reasonable measure much cpu time application plus garbage collector actually consume ran four simultaneous copies application 4way multiprocessor ensured processors would busy time ecient garbage collector would win parallel run repeated 8 times average elapsed time computed addition measured improvement generational collection uniprocessor typical environment onthe collector interesting check whether generations help case well usually 82 benchmarks benchmarks taken specjvm benchmarks 25 descriptions benchmarks found spec web site 25 ran specjvm benchmarks command line harness tests used s100 parameter also used two additional benchmarks rst ibm internal benchmark called anagram 15 program implements anagram generator using simple recursive routine generate permutations threads impro vement 13 26 106 160 117 figure 7 percentage improvement elapsed time multithreaded ray tracer 4way multiprocessor benchmark multiprocessor uniprocessor improvement improvement anagram 250 327 figure 8 percentage improvement anagram characters input string resulting words permuted string found dictionary permuted string displayed program collectionintensive creating freeing many strings second code modication 227 mtrt 5 specjvm benchmarks 25 order make interesting multiprocessor machine program 227 mtrt variant ray tracer two threads render scene input le 340 kb size 5 227 mtrt runs matrices 200200 uses 2 concurrent threads modied run bigger matrix dimensions 300300 also parametrized number rendering threads call modication multithreaded ray tracer modied code available request specjvm licensees 83 choice parameters application dierent choice parameters governing generational collection seems yield best performance average best choice parameters turns object marking ie card marking 16 bytes per card without advanced aging mechanism best size young generation turns 4 megabytes also tried 1 2 8 megabytes young generation next section section 84 present results set parameters section 85 justify choice comparing performance algorithm aging various settings parameters 84 results figure 7 present percentage improvement multithreaded ray tracer benchmark described section 82 number application threads varies 2 10 generations perform well next figure 8 present improvement generational collection yields anagram bench mark generational collection also benecial figure 9 examine applications specjvm benchmark one may see applications generations well omit results benchmarks 200 check 222 mpegaudio since perform many garbage collections performance indierent collection method performance benchmarks either gains boost generational collection remains virtually unchanged except two benchmarks 202 jess 228 jack suer performance decrease account dierences applications measured several runtime properties applications expected application performs well generational collection many objects die young pointers old generation get frequently modied decrease performance 202 jess 228 jack originates several reasons shown measurements first lifetime objects typical generations die soon promoted unless one makes huge young generation second 202 jess 362 objects scanned partial collection scanned dirty objects old generation high cost benchmark multiprocessor uniprocessor improvement improvement compress 00 20 jess 37 25 228 jack 212 77 figure 9 percentage improvement specjvm benchmarks benchmark percent time partial gc full gc percent time gc gc gc active active wo generations wo generations compress 17 5 15 12 17 jess 133 70 2 148 51 228 jack 77 anagram 628 152 8 789 56 figure 10 use garbage collection application manipulating intergenerational pointers however note success failure generational collector uenced also factors measure example increased locality heap caused frequent collections hard measure present measured properties runtime remainder section present measurements applications properties measures taken multiprocessor running single copy application start figure 10 amount time spent garbage collection numbers indicate much change garbage collection mechanism may aect overall running time application example program spends time garbage collecting run anagram whereas programs spend small part time garbage collection 201 compress 209 db also include number collection cycles executed applications next figures 11 12 measure generational behavior benchmarks involved particular measure many objects scanned collection many scanned due intergenerational pointers percentage objects freed partial collection report percent objects young generation collected full collection report percentage allocated objects whole heap reclaimed allocated objects counted sum objects freed objects survive collection example benchmark 201 compress objects tend die young however applications almost objects die young next consider maintenance intergenerational pointers see example 202 jess 362 objects scanned partial collection dirty objects old generation high cost manipulating intergenerational pointers one reasons deterioration performance finally look many objects reclaimed partial full collections applications 228 jack 202 jess objects got tenured old generation survive long see almost objects collected full collections non generational behavior another reason generations perform well 202 jess 228 jack nongenerational collections free similar percentage objects partial collections gain eciency partial collections whereas pay overhead cost maintaining intergenerational avg old avg avg avg objects scanned objects scanned objects scanned objects scanned intergen partial full collection pointers collections collections wo generations compress 3 168 4789 4778 jess 1373 3797 25411 25446 228 jack 151 4890 14972 11241 figure generational characterization applications part 1 percentage percentage percentage percentage bytes freed objects freed objects freed objects freed partial partial full collections collections collections collections wo generations compress 1929 4043 26 23 209 db 9766 9977 222 431 jess 9802 9788 872 863 213 javac 7125 6867 447 268 228 jack 9163 9658 908 947 anagram 8622 9343 142 132 figure 12 generational characterization applications part 2 pointers next figure 13 figure 14 look cost performance partial full collections various benchmarks cost time required run collection performance number objects collected accumulated size note mark sweep algorithm cost sweep similar partial full collections tracing times get shorter thus partial collections take less time drastically less figure shows number types collection cycles benchmarks benchmarks number full collections using generational collector less number full collections using nongenerational collector finally examine number pages touched collector various collections see figure 15 measure pages touched trace sweep including tables collector uses card table naturally number pages touched partial collections smaller number pages touched full collections smallest ratio anagram benchmark number pages touched partial collections 20 number touched full collections largest ratio 213 javac benchmark number pages touched partial collections 70 number pages touched full collections positive results match similar measurements demers et al 6 85 tuning parameters section explain choice parameters compare various card sizes method aging versus simple promotion method evaluate various sizes young generation aging avg time avg time avg time active partial active full active gc ms gc ms gc ms wo generations compress 17 35 31 jess 61 116 87 228 jack anagram 52 429 346 figure 13 ellapsed time collection cycles avg avg avg avg space avg space avg space objects freed objects freed objects freed freed freed freed partial full collection partial full collection collection collection wo generations collection collection wo generations compress 112 112 111 1057472 6922551 67953331 jess 106185 166720 160458 3934524 6759448 5982237 228 jack 133671 186370 202109 3677861 6905298 5841292 anagram 12251 30088 41370 3515684 13279332 12590566 figure 14 average gain collections pages touched wo partial full generations compress 76 124 109 jess 1304 2227 2048 228 jack 1199 2052 1767 anagram 1082 4938 5054 figure 15 average pages touched gc number threads block marking 1m young generation 39 88 50 90 82 block marking 2m young generation 08 71 60 98 87 block marking 4m young generation 11 25 66 98 74 block marking 8m young generation 09 47 77 109 88 object marking 1m young generation 47 26 43 140 130 object marking 2m young generation 14 44 59 113 86 object marking 4m young generation 13 26 106 160 117 object marking 8m young generation 19 80 132 188 154 figure tuning size young generation percentage improvement generations multithreaded ray tracer block marking object marking benchmark 1m 2m 4m 8m 1m 2m 4m 8m compress 041 019 005 046 004 011 002 029 jess 2244 1297 505 155 1377 872 37 566 228 jack 1214 627 283 1484 685 345 212 223 anagram 1443 3003 3717 3873 867 1206 2467 2642 figure 17 tuning size young generation percentage improvement generations specjvm benchmarks method compare performance various tenuring thresholds results summarized several tables described 851 size young generation begin evaluating various sizes young generation compare sizes 1 2 4 8 megabytes possible alternatives size young generation present measurements two extreme cases card sizes block marking card size 4096 bytes object marking card size bytes see subsection 853 card sizes best applications results multithreaded ray tracer found figure 16 specjvm benchmarks 25 figure 17 results point single best size benchmarks average best performance obtained size 4 megabytes young generation sequel x young generation 4 megabyte except evaluating aging mechanism 852 aging mechanism results aging disappointing seen results figure 18 figure 19 vary size young generation 1 2 4 8 megabytes age threshold promotion old generation 4 6 8 10 recall object allocated age 1 age gets increased collection survives chose card size smallest possible justied analysis card sizes section 853 note use simple promotion mechanism object gets old age 2 thus possible compare overhead aging method comparing simple promotion mechanism aging old age 2 turns aging method big overhead see figure 20 shows percentage improvement actually deterioration using aging 2 ages age 4 old age 6 old benchmark 1m 2m 4m 8m 1m 2m 4m 8m jess 177 158 101 78 126 137 103 92 209 db 24 07 14 04 31 13 11 01 228 jack 114 67 18 15 126 64 25 09 anagram 108 19 200 296 112 08 183 267 figure 18 percentage improvement aging mechanism nongenerational collector specjvm benchmarks part 1 object mark aging age 8 old age 10 old benchmark 1m 2m 4m 8m 1m 2m 4m 8m compress jess 146 173 51 38 176 94 49 36 213 javac 270 131 36 174 335 162 32 155 228 jack 116 35 20 04 144 42 26 12 anagram 118 04 161 239 117 16 149 234 figure 19 percentage improvement aging mechanism nongenerational collector specjvm benchmarks part 2 benchmark 1m 2m 4m 8m 201 compress 009 018 097 016 jess 321 343 354 124 228 jack 301 288 148 040 anagram 211 910 363 334 figure 20 percentage improvement cost aging mechanism 2 ages simple promotion method instead standard method use object marking ie smallest card size may possible improve performance aging algorithm changing algorithm data structures something attempted work perhaps simple modication locating value age inside object instead keeping table ages may help improving locality reference light results chosen use aging 853 choosing size cards finally ran measurements nd best card size varied size 16 4096 including powers 2 best card size depends behavior application note since move objects heap objects young old generations segregated interesting phenomena scanning cards dirty objects concentrated heap specic location big small smaller cards shorten scan example rst 14 heap contains dirty objects take cards whose size quarter heap cards whose size 16 bytes well objects actually scan dirty cards however dirty objects spread randomly heap rening card sizes useful ner cards less objects scan thus nature application determines useful small cards considerations example smaller cards imply bigger card table card table accessed pointer modication may uence locality reference big table accessed frequently random manner decreases locality seems consideration opposite previous one heap access application randomly distributed big table bad bigger cards required heap accesses concentrated access card table concentrated even big table smaller cards ne big question consideration dominant frequency accesses note card gets dirty even touched relevant issue consideration previous paragraph however locality reference matters frequently cards touched frequency may determine considerations wins card size best application actual results given following tables table 21 specify improvement generational collection versus nongenerational collection benchmarks various card sizes used young generation 4 megabytes object marking get impression uences results also present table 22 percentage cards dirty collection table 23 area got scanned due dirty cards cases size card make signicant impact running time biggest impact seen benchmarks anagram 213 javac 202 jess impact card sizes benchmark anagram bigger card size better 213 javac smaller better 202 jess two extremes 16 4096 bytes best chose use smallest card size denoted object marking rest tests object mark 4m young generation benchmark byte byte byte byte byte byte byte byte byte compress 011 016 010 041 025 033 040 046 062 jess 425 402 664 917 724 717 696 701 665 228 jack 743 624 701 612 679 716 678 672 650 anagram 2361 1892 2404 2859 3135 3309 3341 3448 3524 figure 21 percentage improvement specjvm benchmarks various card sizes object mark 4m young generation benchmark byte byte byte byte byte byte byte byte byte jess 1581 3070 4285 5016 5343 5665 5946 5908 6118 228 jack 1766 2871 3251 3447 3519 3841 4001 4053 4411 anagram 114 078 207 122 122 125 122 123 131 figure 22 tuning parameterscard size percentage dirty cards allocated cards looking tables 22 23 see almost dirty cards scanned anagram one properties anagaram make generational collection appropriate note anagram best large card size probably due smaller card table since uence actual scanning negligible 209 db size card practically uence size area scanned collection probably due concentration dirty objects discussed object mark 4m young generation benchmark byte byte byte byte byte byte byte byte byte jess 1237 2421 3426 3888 4191 4387 4499 4626 4780 228 jack 1309 2059 2319 2450 2562 2717 2821 2983 3226 anagram 107 175 170 168 167 170 165 167 178 figure 23 tuning parameterscard size area scanned dirty cards 9 conclusion presented design incorporating generations onthe garbage collector java best knowledge combination tried ndings imply generations benecial spite two obstacles fact generations segregated space since objects moved collector fact obtaining shorter pauses collection relevant onthe collector turns benchmarks overall running time reduced 25 one benchmark generational collection increased overall running time multiprocessor 4 best performing variant generational collection variants checked one simplest promotion policy promoting object old generation surviving one collection quite big young generation 4 megabytes small size cards card marking algorithm 16 bytes per card collections less pages touched generational collector thus one especially consider using generations onthe collector applications run limited physical memory acknowledgments thank hans bohm helpful remarks thank alain azagury katherine barabash bill berg john endicott michael factor arv fisher naama kraus yossi levanoni ethan lewis eliot salant dafna sheinwald ron sivan sagi snir igor yanover helpful discussions r list processing realtime serial computer treadmill algorithms onthe garbage collection combining generational conservative garbage collection framework implementations experience concurrent garbage collector mudula2 unobtrusive garbage collection multiprocessor systems concurrent generational garbage collector multithreaded implementation ml exercise proving parallel programs correct anagram generator garbage collection algorithms automatic dynamic memory manage ment using color toggle reduce synchronization dlg collector garbage collection multiple processes exercise parallelism concurrent marksweep garbage collection without finegrain synchronization real time garbage collector based lifetimes objects garbage collection large lisp system lifetimebased garbage collector lisp systems generalpurpose computers multiprocessing compactifying garbage collection multiprocessing compactifying garbage collection generation scavenging nondisruptive high performance storage reclamation algorithm tr algorithms onthefly garbage collection combining generational conservative garbage collection framework implementations treadmill comparative performance evaluation write barrier implementation concurrent generational garbage collector multithreaded implementation ml unobtrusive garbage collection multiprocessor systems garbage collection concurrent markmyampersandampsweep garbage collection without finegrain synchronization realtime garbage collector based lifetimes objects list processing real time serial computer onthefly garbage collection exercise proving parallel programs correct multiprocessing compactifying garbage collection onthefly garbage collection onthefly garbage collection garbage collection large lisp system garbage collection task deletion distributed applicative processing systems generation scavenging lifetimebased garbage collector lisp systems general purpose computers ctr perry cheng guy e blelloch parallel realtime garbage collector acm sigplan notices v36 n5 p125136 may 2001 hezi azatchi yossi levanoni harel paz erez petrank onthefly mark sweep garbage collector based sliding views acm sigplan notices v38 n11 november david f bacon perry cheng david grove martin vechev syncopation generational realtime garbage collection metronome acm sigplan notices v40 n7 july 2005 david detlefs ross knippel william clinger matthias jacob concurrent remembered set refinement generational garbage collection proceedings 2nd java virtual machine research technology symposium p1326 august 0102 2002 katherine barabash yoav ossia erez petrank mostly concurrent garbage collection revisited acm sigplan notices v38 n11 november yoav ossia ori benyitzhak irit goft elliot k kolodner victor leikehman avi owshanko parallel incremental concurrent gc servers acm sigplan notices v37 n5 may 2002 hang pham controlling garbage collection heap growth reduce execution time java applications acm transactions programming languages systems toplas v28 n5 p908941 september 2006 karen zee martin rinard write barrier removal static analysis acm sigplan notices v37 n11 november 2002 katherine barabash niv buchbinder tamar domani elliot k kolodner yoav ossia shlomit pinter janice shepherd ron sivan victor umansky mostly accurate stack scanning proceedings javatm virtual machine research technology symposium javatm virtual machine research technology symposium p1919 april 2324 2001 monterey california david f bacon clement r attanasio han b lee v rajan stephen smith java without coffee breaks nonintrusive multiprocessor garbage collector acm sigplan notices v36 n5 p92103 may 2001 katherine barabash ori benyitzhak irit goft elliot k kolodner victor leikehman yoav ossia avi owshanko erez petrank parallel incremental mostly concurrent garbage collector servers acm transactions programming languages systems toplas v27 n6 p10971146 november 2005 martin vechev eran yahav david f bacon correctnesspreserving derivation concurrent garbage collection algorithms acm sigplan notices v41 n6 june 2006 antony l hosking portable mostlyconcurrent mostlycopying garbage collection multiprocessors proceedings 2006 international symposium memory management june 1011 2006 ottawa ontario canada
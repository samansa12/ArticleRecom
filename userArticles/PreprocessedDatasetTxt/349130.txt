improving precision inca preventing spurious cycles inequality necessary condition analyzer inca finitestate verification tool able check properties large concurrent systems inca checks property concurrent system generating system inequalities must integer solutions property violated may however integer solutions inequalities correspond execution violating property inca thus accepts possibility inconclusive result exchange greater tractability describe method eliminating one two main sources inconclusive results b introduction finitestate verication tools deduce properties nite state models computer systems used check properties freedom deadlock mutually exclusive use resource eventual response quest model represents executions system perhaps making use abstraction nitestate verication tool take account executions research partially supported national science foundation grant ccr9708184 views ndings conclusions presented authors interpreted necessarily representing ocial policies endorsements either expressed implied national science foundation us government system moreover nitestate verication tools applied stage system development appropriate model constructed tools thus represent important complement testing especially concurrent systems nondeterministic behavior lead dierent executions arising input data main obstacle nitestate verication concurrent systems state explosion problem number states concurrent system reach general exponential number concurrent processes system problem confronts analyst immediatelyeven small systems number reachable states large enough straightforward approach examines state completely infeasibleand complexity results tell us way avoid completely every method nitestate verication concurrent systems must pay price accuracy range application practicality inequality necessary conditions analyser inca nitestate verication tool used check properties systems large state spaces inca approach formulate set necessary conditions existence execution program violates property conditions inconsistent execution violate property conditions consistent analysis inconclusive since conditions necessary sucient may still case execution program violate property inca thus accepts possibility inconclusive result exchange greater tractability two main sources inconclusive results paper show one caused cycles nite state automata representing components concurrent system eliminated seems moderate cost next section describe inca approach section 3 explains technique improving incas preci sion fourth section presents preliminary data application nal section summarizes paper discusses issues related precision inca 2 inca complete discussion inca approach along careful analysis expressive power contained 8 paper use small quite contrived example sketch basic inca approach show certain cycles automata corresponding components concurrent system lead imprecision inca analysis refer readers want detail 8 21 basic approach basic inca approach regard concurrent system collection communicating nite state automata transitions states fsas correspond events execution system inca treats fsa network ow regards occurrence transition state state corresponding event e unit ow node node sequence transitions particular fsa corresponding events segment execution system thus represents ow one state fsa another check property concurrent system using inca analyst species ways execution might violate property terms sequence segments exe cution suppose analyst wants show event b never preceded event execution system violation property execution occurs b occurs inca could specied single segment running start execution occurrence b requirement occur somewhere segment could also specied sequence two segments rst running start execution occurrence second starting immediately rst ending b former specication generally ecient latter may provide additional precision cases see section 22 inca provides query language allowing analyst specify various aspects segments called intervals inca query language execution generating equations describing ow within fsa requiring ow node equal ow according specied sequence segments system execution adding equations inequalities relating certain transitions dierent fsas according semantics communication system inca produces system equations inequalities execution satises analysts specication therefore violates property checked corresponds integer solution system equations inequalities inca uses standard integer linear programming ilp methods determine whether integer solution integer solution exists execution violate property property holds executions concurrent sys tem integer solution however know property violated system equations inequalities represents necessary conditions existence execution violating property possible solution exist correspond real execution see concretely works consider ada program shown figure 1 program describes three concurrent processes tasks task t1 begins rendezvous ing task t2 entry c enters loop select statement t1 nondeterministically chooses rendezvous t2 entry t3 entry b ready communicate appropriate entries t1 ac package simple task t1 task t2 entry end t2 entry b entry c task t3 package body simple task body t1 task body t2 begin begin accept c t1c loop loop select t1a accept end loop loop end t2 select accept accept c exit task body t3 end t3 accept b loop accept figure 1 small example cepts communication t2 entry enters loop accepts rendezvous entry accepts one entry c t1 instead accepts communication t3 entry b tries forever repeatedly rendezvous t2 entry figure 2 shows fsas constructed inca pro gram states transitions numbered reference transition example represents occurrence rendezvous two tasks gure transition labeled entry corresponding rendezvous takes place suppose wish check occurrence rendezvous entry b cannot preceded rendezvous entry described earlier may specify violation segment execution running start execution occurrence rendezvous b containing rendezvous ow equations task describe possible ows initial state task one states task could end segment since segment ends rendezvous entry b represented transition numbered 2 fsa corresponding task t1 transition numbered 9 fsa corresponding task t3 know fsa t1 must state 3 fsa t3 must state 8 end segment ow equations t1 therefore describe ow starting state 1 ending state 3 ow equations t3 describe ow starting state 7 ending state 8 t2 fact rendezvous occurs segment implies fsa must state 6 end segment ow equations t2 describe ow state 5 state 6 produce ow equations let x variable measur c figure 2 fsas example ing ow along transition numbered state generate equation setting ow equal ow must however take account implicit ow 1 initial state fsa implicit ow 1 end state ow thus example equation state 1 since ow 1 state 1 initial state ow transition 1 similarly equation state 8 since ow transition 9 implicit ow 1 since ow fsa ends state 8 complete system equations inequalities must add equations ect fact two tasks participating rendezvous must agree number times occurs instance need equation saying number occurrences rendezvous entry fsa t1 fsa t2 also need inequality express requirement least one occurrence rendezvous use state full system equations inequalities used check property rendezvous entry b cannot preceded rendezvous entry shown figure 3 description actually somewhat simplied inca performs several optimizations reduce size system inequalities real system inequalities produced inca would smaller ex ample inca would observe cannot ow along transition 3 violating execution segment execution must end transition 2 would eliminate variable x3 system would also form constant propagation eliminate variables equations essentially research nitestate verication tools flow equations state equation communication equations entry equation x3 requirement inequality occurs x8 1 figure 3 system equations inequalities example viewed aimed ameliorating state explosion problem interesting systems properties approach taken inca avoids enumerating reachable states system inherently compositional sense equations inequalities generated automata corresponding individual processes rather single automaton representing full concurrent system size system equations inequalities essentially linear number processes system assuming size process bounded furthermore use properly chosen cost functions solving problems guide search solution ilp nphard problem general standard techniques solving ilp problems branchandbound methods potentially exponen tial practice however ilp problems generated concurrent systems large totally unimodular subproblems seem particularly easy solve experience suggests time solve problems grows approximately quadratically size system inequalities thus number processes system comparisons approach nitestate verica tion methods 2 3 4 5 show performance method varies considerably system property veried inca frequently performs well better tools spin smv inca approach also extended check timing properties realtime systems 1 6 prove trace equivalence certain classes systems 7 22 sources imprecision systems equations inequalities generated inca represent necessary conditions violation property veried noted earlier however represent necessary sucient conditions solution system equations inequalities may correspond actual execution two main reasons rst order events occur strictly speaking equations inequalities generated inca refer total number occurrences various events segment execution directly impose restrictions order events occur within segment fact ow equations single fsa typically imply fairly strong conditions order communication equations relating occurrence events dierent fsas impose strong restrictions order occurrence events dierent processes see consider system comprising two processes rst process begins trying communicate second process channel completing communication tries communicate second process channel b second process tries complete communications reverse order system obviously deadlock equations generated inca would say number communications channel rst process equal number second process allowing solution communication occurs slight oversimplication inca would actually detect deadlock case complicated examples several processes mechanism inca provides directly constraining order events dierent processes use additional segments execution often enough eliminate solutions correspond real executions system expensive restricts range application inca return point nal section paper second source imprecision existence cycles fsas consider ow equation state 3 shown figure 3 transition 3 selfloop state 3 ow along transition counts ow state 3 state 3 equation x2 constrain variable x3 simply cancel x3 terms similarly variables x5 x8 constrained ow equations appear variables constrained communication equation three variables otherwise unconstrained equation restrict solution set fact although system figure 1 execution prex ending rendezvous entry b contains rendezvous entry solution system equations inequalities shown figure 3 x1 x2 x5 x7 x8 x9 equal 1 x3 x4 x6 equal 0 solution requirement number rendezvous least 1 met setting unconstrained variables x5 x8 1 figure 4 shows fsas transitions ow indicated bold arcs ow fsa t1 two connected components one initial state state 3 expected one made ow cycle state 4 connected ow state 1 state 3 obvious ow fsa corresponding actual execution must connected spurious solution one correspond real execution example illustrates problem much independent interest problem however occurs c figure 4 solution disconnected cycle frequency analysis interesting sys tems instance recent analysis chiron user interface development system 2 encountered solutions disconnected cycles trying verify 2 10 properties checked cases able reformulate properties specifying additional segments verifying properties allowed us eliminate solutions choosing events represent highlevel requirement modications however represent considerable expense increased analyst eort veri cation time next section describe technique eliminating solutions one component ow fsa 3 eliminating spurious cycles 31 straightforward approach related problem well known optimization liter ature formulating traveling salesman problem integer programming problem essential ensure solution represents single tour visiting cities rather collection disconnected subtours visiting proper subset cities standard approach eliminating solutions disconnected subtours add inequalities prevent solution visiting cities subset u unless solution includes arc city u one u thus variable x ij 1 solution represents tour salesman goes directly city city j 0 otherwise standard formulation traveling salesman problem would include j inequality enforce requirement city entered left exactly eliminate possibility subtour subset u would add inequality x ij 1 2 requires salesman travel city outside u city u course need inequality like 2 every subset u size least 2 n 2 n number cities case prevent solution ow disconnected cycle c add inequality requiring ow c must ow entering c outside little complicated situation traveling salesman problem case know 1 solution must enter city exactly case want require ow one states making c unless ow along one transitions c instance want require ow transition 4 example ow transition 5 general would need quadratic inequality x4x5 x5 3 integer quadratic programming however much harder integer linear programming would like avoid introducing quadratic inequalities standard technique impose upper bound b variables ie assume transition occurs b times replace quadratic inequality 3 linear inequality integer solutions 3 x4 x5 b exactly 4 note imposing upper bound variables would mean incas analysis longer strictly conservative system inequalities solutions x less equal b know execution transition occurs b times violate property since b taken quite large 10 000 100 000 restriction unlikely serious one practice problem approaches may require many extra inequalities number subtours eliminated traveling salesman problem essentially number subsets set cities clearly exponential number cities similarly number cycles fsa essentially equal number subsets set states constructed small concurrent ada program 90 lines code fsa one task 42 states 1160290624 distinct subsets states forming least one cycle integer programming problem many inequalities infeasible better method required 32 practical method section describe method preventing spurious cycles requires fsa segment execution new variables new inequalities number states fsa number transitions basic idea essentially follows suppose solution system equations inequalities originally generated inca fsa segment execution attempt construct subgraph vertices fsa whose edges subset positive ow solution require ow vertex v solution edge terminating v must occur subgraph ii vertex v subgraph assigned depth dv way depth given node greater predecessors subgraph original solution disconnected cycles choose subgraph spanning tree edges ow take depth vertex distance root tree vertex solution disconnected cycle c however cannot construct subgraph see suppose could construct subgraph let v vertex c dv du u 2 c since ow v solution v must predecessor u subgraph since cycle c disconnected ow starting initial state fsa state u must also lie c u predecessor v subgraph dv du contradicting minimality dv c course want consider possible solutions system equations inequalities generated inca one time attempting construct subgraph separately solution instead add new variables inequalities leading augmented system equations inequalities whose integer solutions correspond exactly integer solutions original system appropriate subgraph constructed describe procedure generating augmented system case single fsa f single segment execution variable x original system corresponding transition f introduce new variable variable 1 corresponding edge subgraph 0 otherwise state v f introduce new variable dv bounds n integer least maximum length nonselfintersecting path fsa instance n taken number states f variable dv depth v generate inequalities involving new variables variable corresponds transition state u f state v generate inequalities rst inequality says must 0 x 0 corresponding edge subgraph solution positive ow along edge second inequality requires dv greater du edge u v subgraph edge subgraph ie 0 inequality reads dv du n bounds dv du make vacuous finally let inv denote number transitions state v state v f initial state generate inequality sums taken transitions state b upper bound variables noted earlier b taken quite large x j 0 inequality satised vacuously x j positive inequality forces j positive means solution ow state v edge terminating v belongs subgraph argument sketched beginning section proves following theorem showing method eliminates solutions disconnected cycles theorem 1 let p system equations inequalities generated inca check particular property given concurrent system let p 0 augmented system constructed p described solution assigns values variables p well additional variables thus obtain assignment values variables p solution p 0 projection set integer solutions p variables taking values b disconnected cycles exactly equal set projections integer solutions p 0 variables taking values b general query specify one execution segment situation bit complicated general case inca constructs owgraph follows first creates one copy fsa segment specied query copy optimized independently removing unnecessary states transitions based restrictions imposed query segment seen example section 21 inca determine query states fsa could end segment adds connect edge possible end states segment corresponding state segment 1 edges connect ow representing events one segment execution ow next segment finally initial node added connect edges certain states rst segment task nal node added incoming connect edges possible end states nal segment task owgraph actual structure inca uses generate ilp system algorithm described section actually applied subset vertices owgraph rather whole owgraph thereby eliminating spurious solutions disconnected cycle contained subset given subset w vertices owgraph one form new graph v follows create vertex v vertex w also add initial nal vertex v edge joining two vertices w create corresponding edge v edge originating outside w terminating w create corresponding edge v initial vertex corresponding vertex edge originating w terminating outside w create corresponding edge v corresponding vertex nal vertex edge v associated ilp variable variable associated corresponding edge original owgraph apply algorithm v generating new variables inequalities added inca originally produced owgraph arguments given go restricting algorithm way many practical ap plications suppose example solution contains single disconnected cycle clear cycle must lie within single segment single task owgraph edges state one segment state preceding segment edges states one task another apply cycleelimination algorithm entire owgraph might expensive terms time memory generate new variables constraints time memory needed ilp tool solve new system case makes sense apply algorithm problematic segment problematic task typically segments behave quite independently existence spurious cycles one segment related existence spurious cycles segments one might tempted conservative possible apply cycleelimination algorithm vertices involved oending cycle usually fruitless often another spurious solution found expanding cycle include vertices however matter much cycle expands still must lie entirely single segment single task therefore best strategy might apply algorithm entire problematic segment task soon one spurious cycle appears 4 preliminary experiments current version inca consists 12000 lines common lisp inca writes le describing system equations inequalities standard format mps format use commercial package called cplex read le solve system also use separate program translate ada programs native input language inca optimizations inca uses reduce number variables inequalities make introduction new variables inequalities somewhat complicated integrating method inca involve substantial programming eort initial exploration eect applying method therefore chosen proceed modifying mps le produced inca written java program reads le le describing owgraph produces new mps le representing augmented system equations inequalities compare performance cplex original system augmented system stage however cannot measure long would take inca generate augmented system equations inequalities experiments used inca version 34 harlequin lispworks 410 cplex version 651 sun enterprise 3500 two processors 2 gb memory running solaris 26 upper bound b representing maximum number times edge may traversed violating execution taken 10 000 used default options cplex except following changes mip strategy nodeselect set 2 mip strategy branch set 1 mip limits solutions set 1 rst two affect choices made branchandbound algorithm third stops search soon integer solution found ilp problem ran cplex times took average time times reported collected using time command include user system time 41 scalable version example section 2 rst experiment created scalable version simple example described section 21 given integer modied ada program figure 1 n copies task t2 alternatives outer select statement new copies task t2 calls entries t1 detail replaced task t2 n copies calling tc1 tcn body t1 replaced rst accept c line n copies replaced body text beginning rst accept ending last n copies wish verify rendezvous entry never precede rendezvous entry b inca constructs fsa t1 2n4 nodes 4n 2 3 edges picture slightly dierent one might expect added start vertex end vertex inca performs trimming fsa distinct subsets vertex set t1 cycles n inca nds spurious solution involving disconnected cycle t1 applying algorithm section 32 portion owgraph coming fsa task t1 however yields ilp problem cplex reports integer solutions thus verifying never precede b n 3 number variables incagenerated ilp system 4n 2 2n number constraints equa tions inequalities 5n 1 number variables new system number constraints time takes cplex nd spurious solution original system time takes determine inconsistency augmented system shown figure 5 times modest 10 seconds fact dwarfed time takes inca generate internal representations problem original ilp system 30 minutes seems however large n substantial increase number constraints augmented system due large number edges fsa t1 begin signicant impact time solve ilp problem13579 time conclusive result cycle elimination spurious solution without cycle elimination figure 5 cplex times scaled simple example 42 spurious cycles chiron second experiment involves chiron user interface system 9 chiron client comprises abstract data types depicted artists maintain mappings adts visual objects appearing screen runtime components provide coordination particular certain events indicating changes state adts dened adt wrapper task noties dispatcher task whenever event occurs dispatcher maintains array event records artists interested notied event artists register unregister event indicate current interest notied receiving event adt wrapper dispatcher loops artists appropriate array calls entry artist notify event chiron architecture highly concurrent even toy chiron interface represents 1000 lines ada code 2 compared performance several nitestate verication tools flavers inca smv spin checking number properties chiron interface two artists n dierent kinds events n ranging 2 70 one properties wish verify system called property 4 2 dispatcher noties artists right event example dispatcher receives event e1 adt wrapper wish show notify artist event e2 notied appropriate artists e1 formulate property inca query takes 2 segments fact able verify property using inca systems number kinds events n 5 flavers spin able verify property least scale problem inca needed decompose dispatcher task subsystem entails creating new task dispatch ei maintains array event ei dispatcher task left interface passes register unregister notication requests appropriate dispatch ei way additional concurrency introduced internal communications dispatcher subsystem hidden new system observationally equivalent original one decomposed system advantage n increases size dispatch ei fsa remains constant although number tasks increases general decomposition greatly improves performance inca property inca yields inconclusive result problem disconnected cycle task dispatch e1 second segment get around problem reformulated property using dierent events represent highlevel property depended prior verication properties relating events used original new formulations cumbersome timeconsuming property reformulated however performance inca decomposed system considerably better tools 30 inca time already roughly order magnitude better times tools inca could verify property much larger values n dierences performance tools property two versions chiron system typical observed properties implications discussed 2 using cycle elimination algorithm described able verify original property directly 2 70 case 23 nodes 63 edges problematic tasksegment n hence n algorithm adds 86 variables 148 constraints ilp system n 3 number variables original system n 58 118 84 according n congruent modulo 3 0 1 2 respectively ects way chose artists register events scaled number events number constraints augmented system similarly value n 195 281 235 case eliminating spurious cycles adds constant number variables constraints n increases cplex times n original system cplex found spurious solution result analysis inconclusive augmented system property conclusively veried given figure 6 times 5 seconds represent small portion total analysis time 70 25 minutes spike cplex time augmented system seems due occurrence certain numerical problems particular system 43 cost unnecessarily preventing spurious cycles also tried adding cycle elimination variables constraints system already yielded conclusive sult might yield insight marginal cost inca add cycle elimination default problem experiment used another property 2 in135 time events conclusive result cycle elimination spurious solution without cycle elimination figure times chiron property 4 case used property 1b says artist never unregisters event unless already registered event 2 restricted checking single artist event resulting property requires 2 segments formulation inca query using decomposed dispatcher version client code inca veried property without need cycle elim ination n 70 number variables inca generated ilp system n n 77 146 107 according n congruent modulo 3 0 1 2 respectively number constraints similarly n 69 96 81 applied cycleelimination algorithm recall separate dispatch ei n event types segments experiment discussed previous section applied algorithm one fsa one segment entailed adding new variables system n 552 833 682 adding new constraints n 897 1391 1123 times required cplex nd conclusive result case graphed figure 7 although ilp systems augmented case quite large 18087 variables 22563 constraints larger n still appears cplex determine inconsistency system short time less 4 seconds example typical real cost introducing cycle elimination inca might lie generating new ilp system solving 5 conclusions future work time events conclusive result cycle elimination conclusive result without cycle elimination figure 7 cplex times chiron property 1b nitestate verication tools always provide conclusive result problem analyze tool walks graph reachable states concurrent system never report system might deadlock fact system deadlockfree assuming course graph correctly represents reachable state space system tool must able store full set reachable states unable report results system whose reachable state space exceeds storage available tools inca deliberately overestimate collection possible executions system thus accept possibility inconclusive results spurious reports possible faults order increase range systems applied inca two main sources imprecision representation executions system rst fact semantic restrictions order occurrence events dierent concurrent processes generally represented equations inequalities used inca second source imprecision fact equations inequalities allow solutions ow fsa representing concurrent process may cycles connected initial state paper shown imprecision caused second source may eliminated specic cases inconclusive results often addressed careful reformulation property checked although may require verication additional properties justify reformulation process require substantial amounts eort part human analysts well considerable costs carry necessary verications also sometimes addressed inconclusive results manually inserting special inequalities prevent disconnected ow small number specic cycles problem generalizing approach number cycles may well exponential size concurrent system cycles requires separate inequality even feasible automate generation inequalities resulting ilp problems would far large solve numbers new variables inequalities introduced method presented paper linear number states transitions fsas representing processes concurrent system analyzed reported results preliminary experiments aimed assessing cost increased time solve systems equations inequalities applying method experiments suggest cost relatively small especially eort human analysts taken account plan carry additional experiments type integrate technique inca toolset also evaluate time needed generate additional variables inequalities also investigating approaches eliminating imprecision caused representing restrictions order events dierent processes fully representing restrictions imposed semantics programming language design notation may practical might limit applicability inca way store full set reachable states limits applicability tools based exploring graph reachable states therefore exploring methods allow analyst control degree restrictions order represented example one approach considering formulate ow communication equations way hold every stage execution end reformulated ow communication equations therefore enforce restrictions order events dierent processes also determine region ndimensional euclidean space n number variables system equations inequalities look point satisfying full system equations inequalities reached taking certain integersized steps region successfully reducing kind imprecision important applying inca approach many systems interprocess communication access shared data 6 r automated derivation time bounds uniprocessor concurrent systems empirical comparison static concurrency analysis techniques empirical evaluation three methods deadlock analysis ada tasking evaluating deadlock detection methods concurrent software practical method bounding time events concurrent realtime systems towards scalable compositional analysis using integer programming verify general safety liveness properties tr practical technique bounding time events concurrent realtime systems empirical evaluation three methods deadlock analysis ada tasking programs automated derivation time bounds uniprocessor concurrent systems towards scalable compositional analysis using integer programming verify general safety liveness properties evaluating deadlock detection methods concurrent software comparing finitestate verification techniques concurrent software
comparison static analysis evolutionary testing verification timing constraints paper contrasts two methods verify timing constraints realtime applications method static analysis predicts worstcase bestcase execution times tasks code analyzing execution paths simulating processor characteristics without ever executing program requiring programs input evolutionary testing iterative testing procedure approximates extreme execution times within several generations executing test object dynamically measuring execution times inputs guided yielding gradually tighter predictions extreme execution times examined approaches number real world examples results show static analysis evolutionary testing complementary methods together provide upper lower bounds worstcase bestcase execution times b introduction realtime systems correct system functionality depends logical correctness well temporal correctness accordingly verification temporal behavior important activity development realtime systems temporal behavior generally examined performing schedulability analysis ensure tasks execution finish within specified deadlines models schedulability analysis commonly based assumption worstcase execution time wcet known specifically models assume wcet must exceed tasks deadline bestcase execution time bcet may also used predict system utilization ensure minimum sampling intervals met techniques static analysis sa used course system design order assess execution times planned tasks precondition schedulability analysis static timing analysis constitutes analytical method determine bounds wcet bcet application sa simulates timing behavior cycle level hardware concepts caches pipelines given processor approach discussed paper uses method static cache simulation followed path analysis within timing analyzer timing estimates calculated without knowledge input without executing actual application dynamic testing one important analytical method assuring quality realtime systems serves verification well validation sys tems investigation existing test methods shows mostly concentrate testing logical correctness lack support testing temporal system behavior reason developed new approach test temporal behavior realtime systems evolutionary testing et et searches automatically test data produces extreme execution times order check timing constraints specified system vio lated search performed means evolutionary computation although sa et usually applied different phases system development procedures aim estimating shortest longest execution times sys tem makes comparison two methods interesting approaches compared paper help several examples chapter 2 offers general overview related work sa well testing third chapter describes tool employ sa afterwards chapter 4 introduces et approaches used determine minimum maximum run times different systems chapter 5 summarizes obtained results discussed chapter 6 seen combination sa et makes reliable definition extreme run times possible important statements summarized chapter 7 also includes short outlook future work 2 related work section presents overview published work timing analysis realtime systems followed discussion previous work testing methods realtime systems 21 timing analysis realtime systems bounding wcet programs difficult task due undecidability halting problem static wcet analysis subject constraints use programming language constructs underlying operating system instance upper bound number loop iterations known indirect calls used memory allocated dynamically 25 often recursive functions also allowed although exist outlines treating bounded recursion similar bounded loops 19 recent research area predicting wcet programs made number advances conventional methods static analysis extended unoptimized programs simple cisc processors optimized programs pipelined risc processors uncached architectures instruction caches 1 16 data caches 13 16 31 today mainly three fundamental models static timing analysis exist first sourcelevel oriented timing schema propagates times tree handles pipelined risc processors firstlevel split caches 23 13 second constraintbased method models architectural aspects including caches via integer linear programming 16 third approach uses dataflow analysis model cache behavior separate pipeline simula tion handled later timing analyzer via path analysis 1 11 31 first second approaches use integrated analysis caches approach uses separate analysis allows us deal multilevel memory hierarchies unified caches another approach using dataflow analysis modeling caching originally used categorizations approach different dataflow model recently approach generalized handle number dataflow solutions differing complexity accuracy 9 presence caches nonpreemptive scheduling initially assumed prevent undeterministic behavior due absence unpredictable context switch points context switches occurred arbitrary points eg preemptive system cache invalidations may occur resulting unexpected cache misses execution task resumed later hardware software approaches proposed counter problem find little use practice due loss cache performance caches partitioned 14 17 recently attempts made incorporate caching ratemonotone analysis responsetime analysis 5 15 allows wcet predictions nonpreemptive systems used analysis preemptively scheduled systems approach seems promising since information gathered static timing analysis utilized within extended framework schedulability analysis 22 testing realtime systems analytical quality assurance plays important role ensuring reliability correctness realtime systems since number shortcomings still exist within development life cycle practice dynamic testing important analytical method assuring quality realtime systems method examines runtime behavior based execution application environment embedded systems testing typically consumes 50 overall development effort budget 8 29 one complex timeconsuming activities within development realtime systems 12 comparison conventional software systems examination additional requirements like timeliness simul taneity predictability make test costly technical characteristics like development hosttarget environ ments strong connection system environment frequent use parallelism distribution faulttolerance mechanisms complicate test aim testing find existing errors system create confidence systems correct behavior executing test object selected inputs testing realtime systems logical system behavior well temporal behavior systems need examined thoroughly investigation existing test methods shows number proven test methods available examining logical correctness systems 22 10 lack support testing temporal behavior sys tems works deal testing temporal behavior realtime systems braberman et al published approach based modeling system design particular formally defined sasdrt notation translated highlevel timed petri nets 4 formal model symbolic representation temporal behavior formed time reachability tree path root tree leaves represents poten source files compiler information control flow cache simulator configurations idcache interface user analyzer timing user timing requests timing predictions virtual address information address calculator addr info relative data decls dependent machine information categorizations idcaching figure 1 framework timing predictions tial test case tree already becomes extensive small programs number test cases must restricted according different criteria results practical trial testing approach reported mandrioli et al developed interactive tool enables generation test cases realtime systems formal specifications written trio 18 language trio extends classical temporal logic deal explicitly time measures present however applicability tool restricted small systems whose properties specified simple trio formulas clarke lee 6 well dasarathy 7 describe techniques verifying timing constraints using timed process algebra finitestate machines approaches demand use formal specification techniques since use formal methods yet generally adopted industrial practice due great expenditure connected lack maturity existing tools testing approaches mentioned spread far industry particularly since suitability approaches many cases remains restricted small systems accordingly specialized methods available moment suited testing temporal behavior realtime systems reason testers usually go back conventional test procedures developed originally examination logical correctness eg systematic blackbox whitebox oriented test methods since temporal behavior complex systems hard comprehend therefore examined insufficiently traditional test methods existing test procedures must supplemented new methods concentrate determining whether system violates specified timing constraints therefore examine applicability evolutionary testing et test temporal behavior realtime systems 3 static analysis sa framework wcet prediction uses set tools depicted figure 1 optimizing compiler modified emit controlflow information data informa tion calling structure functions addition regular target code generation research compiler vpccvpo 3 performed task currently integrating gnatgcc 26 28 environment static cache simulator uses controlflow information calling structure conjunction cache configuration produce instruction data categorizations describe caching behavior instruction data reference currently use separate analyzer instruction data caches since data references require separate preprocessing via address calculator current work also includes single analyzer unified caches handling secondary caches 20 timing analyzer uses categorizations controlflow information perform path analysis program predicts bcet wcet portions program entire program depending user requests experiments described section 5 chose architecture without caches reasons also explained section 5 thus portion toolset shaded grey figure used experiments next describe interaction various tools entire framework framework retargeted changing cache configurations porting machine description ever largest retargeting overhead constitutes port compiler thus current efforts integrate gnatgcc framework greatly improve portability 31 static cache simulation static cache simulation provides means predict caching behavior instructions data references programtask see static cache simulator figure 1 addresses instruction references obtained controlflow information emitted compiler addresses data references calculated address calculator see figure 1 locating data declarations global data obtaining offsets relative addresses local data translated virtual addresses taking context process account instruction data references caching behavior dis category 1st reference consecutive ref alwayshit hit hit alwaysmiss miss miss firsthit miss hit firstmiss hit miss table 1 categorizations cache reference tinguished categories described table 1 category cache behavior first reference consecutive references distinguished consecutive references strictly due loops since distinguish function invocations call sites data caches additional category called calculated denotes total number data cache misses references within loop memory reference program may consist number loops possibly nested distributed several functions loop level instruction receives distinct categorization timing analyzer derive tight bounds execution time inspecting categorizations loop level since instruction categorizations determined interprocedural analysis entire program call graph program analyzed method static cache analysis traces origin calls within call graph distinguishing function instances since instruction categorizations function specified function instance timing analyzer interpret different caching behaviors depending calling sequence yield tighter wcet predictions static cache simulator determines categories instruction based novel view cache memories using variation iterative interprocedural dataflow analysis dfa following information results dfa ffl abstract cache state describes program lines map certain cache blocks may potentially cached within control flow ffl linear cache state contains analog information hypothetical absence loop ffl postdominator set describes program lines certain still reached within control flow dataflow information also reduced respect certain subsets particular check information available within certain loop level formal framework analysis instruction data caches described 31 dataflow information provides means derive categories example setassociative instruction caches multiple levels associativity following categories derived loop level instruction worstcase cache behavior alwayshit spatial locality within program line instruction cache absence loops conflicting instructions cache state conflicts fit remaining associativity levels firsthit instruction firsthit inner loops potentially cached even without loops even loop preheaders always executed loop conflicts fit remaining associativity levels conflicts within loop fit remaining associativity levels loop headers even disregarding loops firstmiss instruction firstmiss inner loops potentially cached conflicts fit remaining associativity levels conflicts within loop alwaysmiss conservative assumption prediction worstcase execution time none conditions apply loop header entry block loop least one predecessor block outside loop called pre header least one predecessor block inside loop 32 timing analysis timing analyzer see figure 1 calculates bcet wcet constructing timing tree traversing paths within loop level propagating timing information bottomup within tree traversal timing analyzer simulate hardware characteristics eg pipelining instruction categorizations interpreted timing analyzer take cache configuration account instead instruction categoriza tions introduced used interpret caching behavior approach splitting cache analysis via static cache simulation timing analysis makes caching aspects completely transparent timing analyzer solely based instruction categorizations timing analyzer derive wcet propagating timing predictions bottomup within timing tree timing tree represents calling structure loop structure entire program seen context static cache simulator functions distinguished calling paths function instances allows tighter prediction wcet due enhanced information calling context function instance regarded loop level one iteration represented node timing tree regular loops within program represented child nodes surrounding function instance outermost loops child nodes another loop nested timing analyzer determines bcet wcet bottomup traversal tree node possible paths sequences basic blocks within current loop level analyzed described detail wcet child node encountered along path wcet already calculated simply added wcet current path sometimes small adjustments adjustments necessary transitions firstmisses firstmisses always misses firsthits loop levels 1 loop n iterations fixpoint algorithm used determine cumulative wcet loop along sequence possibly different paths pattern longest paths established remaining iterations calculated closed formula practice loops one longest path thus first iteration needed adjust wcet child loops along path second iteration represents fixpoint time remaining iterations scope wcet analysis limited one loop level time making timing analysis efficient compared exhaustive analysis permutations paths within program see 1 11 detailed description timing analyzer analog description bcet 4 evolutionary testing et evolutionary testing new testing approach combines testing evolutionary computation first experiments application et examining temporal behavior realtime systems achieved promising results ten experiments performed et always achieved better results compared random testing respect effectiveness well efficiency extreme execution times found means evolutionary computation less equal testing effort random testing see 30 details 41 brief introduction evolutionary compu tation evolutionary algorithms represent class adaptive search techniques procedures based processes natural genetics darwins theory evolution characterized iterative procedure work parallel number potential solutions population indi viduals every individual permissible solution values variables optimization problem coded evolutionary algorithms particularly suited problems involving large numbers variables complex input mains even nonlinear poorly understood search spaces evolutionary algorithms used successfully robustness evolutionary search optimization process based three fundamental principles selection recom bination mutation concept evolutionary algorithms evolve successive generations increasingly better combinations parameters significantly effect overall performance design starting selection good individuals evolutionary algorithm achieves optimum solution random exchange information increasingly fit samples recombination introduction probability independent random change mutation adaptation evolutionary algorithm achieved selection reinsertion procedures since based fitness fitnessvalue numerical value expresses performance individual regard current op timum notion fitness essential application evolutionary algorithms degree success using may depend critically definition fitness function changes neither rapidly slowly design parameters figure 2 gives overview typical procedure evolutionary optimization reinsertion evaluation mutation recombination selection optimization criteria met initialization evaluation figure 2 process evolutionary com putation first population guesses solution problem initialized usually random individual population evaluated calculating fitness results obtained range poor good remainder algorithm iterated optimum achieved another stopping condition fulfilled pairs individuals selected population combined way produce new guess analogous way biological reproduction selection combination algorithms numerous vary survey found 24 recombination offspring undergoes mutation mutation occasional random change value alters features unpredictable consequences mutation like random walk search space used maintain diversity population keep population prematurely converging one local solu tion besides mutation creates genetic material may present current population 27 afterwards new individuals evaluated fitness replace individuals original population lower fitness values reinsertion thereby new population individuals develops consists individuals previous generation newly produced individuals stopping condition remains unfulfilled process described repeated 42 applying evolutionary computation testing temporal system behavior major objective testing find errors described section 2 realtime systems tested logical correctness standard testing techniques fact correctness realtime systems depends logical results computations also providing results right time adds extra dimension verification validation systems namely temporal correctness must checked temporal behavior realtime systems defective computations input situations exist violate specified timing constraints normally violation means outputs produced early computation takes long task tester therefore find input situations shortest longest execution times check produce temporal error search shortest longest execution times regarded optimization problem evolutionary computation seems appropriate solution evolutionary computation enables totally automated search extreme execution times using evolutionary optimization determining shortest longest execution times individual population represents test datum test object executed experiments initial population generated ran dom test data obtained systematic test principle could also used initial population thus evolutionary approach benefits testers knowledge system test every test datum execution time measured execution time determines fitness test datum one searches wcet test data long execution times obtain high fitness values conversely searching bcet individuals short execution times obtain high fitness val ues members population selected regard fitness subjected combination mutation generate new test data means selection decided test data chosen reproduction order retain diversity population avoid rapid convergence local optima fittest individuals selected also individuals low fitness values obtain chance recombination experiments stochastic universal sampling 2 used selection strategy recombination test data discrete recombination 21 applied simple exchange variable values individuals see figure 3 probability mutating individuals variables set inversely proportional number variables dimensions one individual smaller mutation probability single variable mutation rate used success multitude experiments 24 27 checked generated test data input domain test object individuals produced also evaluated executing test object afterwards new individuals united previous generation form new population according reinsertion procedures laid experiments applied reinsertion strategy generation gap 90 next generation therefore contained offspring parents since 90 popula tions individuals replaced offspring process repeats starting selection given stopping condition reached eg certain number generations reached execution time found outside parents offspring figure 3 discrete recombination four randomly defined crossover points specified timing constraints case temporal error detected times found meet timing constraints specified system test confidence temporal correctness system substantiated experiments evolutionary testing stopped predefined number generations specified according complexity test objects respect number input parameters lines code loc 5 verifying timing constraints sa vs et used sa et five experiments determine bcet wcet different systems except last two examples described section programs tested come typical realtime systems used practice test programs chosen since three cover different areas within industrial applications daimler benz company remaining two programs serve reference related work used examples generalpurpose algorithms within realtime appli cations test program also cover wide range realtime applications within graphics transportation defense numerical analysis standard algorithms course results dependent hardwaresoftware platform generally directly transferable one another since processor speed compiler used directly affect temporal behavior experiments described following carried sparcstation ipx running solaris 23 40 mhz execution times processor cycles derived sa et chose sparc ipx platform since architecture caches current stage devel opment timing analyzer sa supports either instruction cache categorizations data cache categorization working extension support categorizations time et execution times measured using performance measurement tool quan tify available rational quantify performs cyclelevel timing though object code instrumentation thus overheads operating system ruled execution times reported repeated runs identical parameters however quantify take effects caching account thus needed uncached architecture perform experiments sa approach utilized pipeline simulation timing analyzer experiments instruction execution simulated fivestage pipeline throughput one instruction per cycle cases commonly found risc architectures load store instructions caused stall two cycles access memory floating point instructions resulted stalls varying durations specified best case worst case operations timing analyzer calculates conservative estimate number cycles required execution based path analysis worst case estimate guaranteed greater equal actual wcet conversely estimate less equal actual bcet library evolutionary algorithms applied et matlabbased toolbox developed daimlerbenz laboratories hartmut pohlheim provides multitude different evolutionary operators se lection recombination mutation reinsertion 24 experiment evolutionary algorithms applied twice first find longest execution time shortest fitness set equal either execution time measured processor cycles longest path reciprocal shortest path population size varied experiments according complexity test objects pairs test data chosen random combined using different operators like discrete recombination double crossover depending representation individuals mutation probability set inversely proportional length individuals means deciding optimum path found et usually allowed continue 100 generations stopped 51 test objects first example simple computer graphics function c checks whether line covered given rectangle sides parallel axes coordinate system function two input parameters line given coordinates line end points rectangle described using position upper left corner width height amounts eight atomic input variables altogether function 107 loc contains total 37 statements 16 program branches second application comes field railroad control technology concerns safetycritical application detects discrepancies separate channels redundant system 389 loc 512 different input parameters binary variables 384 variables ranging 0 255 112 variables range 0 4095 third application concerned comes field defense electronics application extracts characteristics images picture matrix analyzed regard brightness signaltonoise ratio brightest point background established defense electronics program 879 loc 843 integer input parameters first two input parameters represent position pixel window lie within range 11200 1287 respectively remaining 841 program graphics railroad defense matrix sort method best worst best worst best worst best worst best worst sa 309 2602 389 23466 848 71350 8411378 15357471 16003 24469014 actual na na na na na na 10315619 13190619 20998 11872718 table 2 execution times cycles test programs parameters define array 29 29 pixels representing graphical input located around specified position integer describes pixel color lies range 04095 fourth sample program multiplies two integer matrices size 50 50 stores result third matrix integer parameters range 0 8095 permissible elements matrices matrix operations typical embedded image processing applications fifth test program performs sort array 500 integer numbers using bubblesort algorithm arbitrary integer values sorted sorting operations common countless applications within beyond area realtime systems 52 experiments test objects mentioned shortest best longest worst execution times determined results experiments summarized table 2 best case worst case first row depicts results static analysis last row shows measurements evolutionary testing middle row shows actual shortest longest execution times multiplication matrices bubblesort algorithm easily determined applying systematic test notice actual execution times could determined certainty absence caching due hardware complexities 31 examples actual realtime systems complex regard functionality extreme execution times cannot definitely determined systematic test applications used practice normal case computer graphics example sa calculated lower bound 309 processor cycles shortest execution time upper bound 2602 cycles longest execution time et discovered shortest time 457 cy cles longest time 2176 cycles within 24 genera tions population size set 50 generation 76 additional generations 3800 test data sets produce longer shorter execution times thus shortest execution times determined vary 32 longest 16 railroad technology example population size et increased 100 complex input interface test object 500 pa rameters starting first generation continuous improvement 100th generation could observed et suggests et would find even extreme execution times number generations creased shortest execution time found et far 508 cycles nearly 24 389 cycles computed sa longest execution time determined 22626 cy cles varies 4 one calculated sa 23466 cycles therefore worstcase execution time example already defined accurately 100 generations guaranteed maximum execution time task lies 22626 cycles cycles defense electronics program 843 input parame ters therefore population size experiment also set 100 example evolutionary algorithms used generate pictures surrounding given position number generations increased 300 large range variables large number input parameters longest execution time increased steadily new generation asymptoted towards current maximum 35226 cycles run terminated 300 generations fastest execution time found 9095 300 generations compared results achieved sa significant differences could observed estimates extreme execution times calculated sa 848 cycles 71350 cycles closer analysis possible causes deviations lead possibility certain instructions assumed take different times pipeline execution instructions question multiply divide account multiple cycles execution stage currently trying isolate effects quantify tool allow proper comparison sa next example table multiplication matrices due functional simplicity minimum maximum run time easily determined systematic testing represent special input situations longest execution time 13190619 cycles results elements matrices set largest permissible value 8095 shortest run time cycles results matrices fully initialized 0 et applied multiplication matrices single individual made 5000 parameters 25050 resulting search space far largest examples presented generation 100 individuals 500000 parameter values generated nevertheless number generations example increased 2000 searching longest execution time maximum 13007019 cycles found evolutionary algorithms found execution time lies good 1 absolute maximum longest execution time determined help sa 15357471 cycles exceeds absolute maximum 16 shortest execution time determined evolutionary algorithms 12050569 cycles means deviation 17 compared actual shortest run time deviation sa nearly similar execution time 8411378 cycles lies 18 actual value last example bubblesort algorithm determination extreme run times easy help systematic test longest execution time bubblesort results list sorted reverse amounts 11872718 cycles shortest run time results course sorted list leads execution time 20998 cycles longest execution time found et 11826117 cycles comes close actual maximum deviates less 1 upper bound 24469014 cycles longest execution time determined sa exceeds actual one 100 overestimation caused deficiency algorithm interpolates execution time loops particular two loops nested loop counter inner loop whose initial value dependent counter outer loop currently timing analyzer estimates number iterations inner loop conservatively maximum number iterations outer loop working method handle loop dependencies correctly estimate number iterations nested loops case inner loop 1n 2 iterations coarse estimate 12234507 cycles half estimated value calculated taking actual loop overhead account ie value would around 3 actual value discussions refer adjusted value shortest execution time bubblesort algorithm insufficiently evaluated evolutionary optimization 1464577 cycles although shorter run times continually found 2000 generations results far absolute minimum reason current work focuses detailed analysis bubblesort example improvement et results also main focus bound wcet since provides means verify deadlines cannot missed important property realtime systems shortest execution time determined sa 16003 cycles differs 24 absolute minimum 6 discussion measurements last section show methods static analysis et bound actual execution times sa always estimates extreme execution times way actual run times possible system never exceed et provides actually occurring execution times worst case estimates sa provide upper bound measurements et give lower bound actual time conversely sas estimates provide lower bound bestcase time ets measurements constitute upper bound half experiments actual execution times bounded within sigma3 better respect range execution times determined sa results directly applicable schedulability analysis provide high confidence range actual wcet cases variation two approaches sigma10 may still yield useful results schedulability analysis regard sigma10 threshold useful results sense larger deviations two methods may accurate enough guarantee enough processor utilization even though may safe multiplication matrices defense example larger variations detected indicates approaches need investigation improve precision overhead estimating extreme execution times differs approaches et requires execution test program many generations large number input data ie overhead dependent actual execution times test object additional delays caused timing sa requires test overhead order seconds tested programs since one simulation suffices predict extreme execution times ie overhead independent actual execution times instead overhead depends complexity combined call graph controlflow graphs entire program roughly increases quadratically program size sa automatically yields timing estimates entire application also estimates arbitrary subroutines portions control flow obtain corresponding data et test objects isolated prerequisite performing sa knowledge cyclelevel behavior target processor supplied configuration files et approach works wide range timing methods one hand hardware timers calculating wallclock time may used without knowledge actual hardware method highly portable subject interference hardware software components eg caches operating systems hand cyclelevel timing information excluding instrumentation instructions may calculated part program execution seen experiments portability method constrained portability instrumentation tool summary et approach cannot provide safe timing guarantees measures actual running system et universally applicable arbitrary architectures requires knowledge input specification sa approach yields conservative estimates safely approximate actual execution times requires knowledge loop frequencies information cyclelevel behavior actual hardware new hardware features implemented simulator limits portability sa hardware details known et approach applied hardware available yet specification hardware supplied sa approach yield results regard two methods complementary ap proaches whenever deadlines guaranteed sa used yield safe estimates wcet et may used additionally bound extreme execution times precisely furthermore et may suffice missed deadlines tolerated sporadically wcet schedulability analysis also derived sa hard realtime environments soft realtime environments may choose sa et even mean sa et general every realtime system tested logical well temporal correct ness independent methods used system de sign recommend apply et validate temporal correctness systems confidence application increased since et checks timing violations many input configurations 7 conclusion future work work introduced two methods verify timing constraints actual realtime applications namely method static analysis method evolutionary testing methods implemented evaluated number test programs respect prediction worstcase bestcase execution times results show methods complimentary sense bound actual extreme execution times opposite ends investigated programs actual execution times best worst cases could guaranteed fairly high precision within sigma10 mean results methods relative possible execution times determined static analysis less precise results obtained experiments indicating improvements approaches necessary ensure general applicability current work static analysis includes extensions handle loop dependencies integrate gnatgcc compiler current work evolutionary testing focuses development robust algorithms reduce probability getting caught local optima furthermore suitable stopping criteria terminate test defined program code available degree coverage achieved evolutionary testing observation program paths executed could interesting aspect deciding stop test promising criteria seem branch path coverage strong correlation programs control flow execution statements resulting execution times coverage reached also used assess test quality comparing evolutionary testing systematic functional testing another area want intensify research future order estimate thoroughly efficiency different testing approaches examination realtime systems temporal behavior comparison evolutionary testing portable requires extensive experimentation many program executions static analysis lower overhead simulation process requires detailed information hardware characteristics extensions simulation models new architectural features recommend worstcase execution time schedulability analysis derived static analysis hard realtime environments soft realtime environments may choose static analysis evolutionary testing furthermore suggest evolutionary testing used increase confidence temporal correctness actual running system r bounding worstcase instruction cache performance reducing bias inefficiency selection algorithm portable global optimizer linker testing timing behavior realtime software adding instruction cache effect schedulability analysis preemptive realtime systems testing realtime constraints process algebraic setting timing constraints realtime systems constructs expressing testing large applying compiler techiniques cache behavior prediction integrating timing analysis pipelining instruction caching efficient worst case timing analysis data caching analysis cacherelated preemption delay fixedpriority preemptive scheduling cache modeling realtime software beyond direct mapped instruction caches functional test case generation realtime systems static cache simulation applications timing predictions multilevel caches art software testing predicting program execution times analyzing static dynamic program paths genetic evolutionary algorithm toolbox use matlab documentation calculating maximum execution time realtime programs free software foundation automatic generation software test data using genetic algorithms testing realtime systems using genetic algorithms tr ctr sibin mohan worstcase execution time analysis security policies deeply embedded realtime systems acm sigbed review v5 n1 p12 january 2008 mark harman joachim wegener getting results searchbased approaches software engineering proceedings 26th international conference software engineering p728729 may 2328 2004 kiran seth aravindh anantaraman frank mueller eric rotenberg fast frequencyaware static timing analysis acm transactions embedded computing systems tecs v5 n1 p200224 february 2006 kaustubh patil kiran seth frank mueller compositional static instruction cache simulation acm sigplan notices v39 n7 july 2004 john regehr random testing interruptdriven software proceedings 5th acm international conference embedded software september 1822 2005 jersey city nj usa ajay dudani frank mueller yifan zhu energyconserving feedback edf scheduling embedded systems realtime constraints acm sigplan notices v37 n7 july 2002 aravindh anantaraman kiran seth kaustubh patil eric rotenberg frank mueller virtual simple architecture visa exceeding complexity limit safe realtime systems acm sigarch computer architecture news v31 n2 may yifan zhu frank mueller feedback edf scheduling realtime tasks exploiting dynamic voltage scaling realtime systems v31 n13 p3363 december 2005 andr baresel david binkley mark harman bogdan korel evolutionary testing presence loopassigned flags testability transformation approach acm sigsoft software engineering notes v29 n4 july 2004 dennis brylow jens palsberg deadline analysis interruptdriven software ieee transactions software engineering v30 n10 p634655 october 2004
strong normalizability nondeterministic catchthrow calculi catchthrow mechanism common lisp provides simple control mechanism nonlocal exits study typed calculi nakano sato formalize catchthrow mechanism calculi correspond classical logic curryhoward isomorphism one characteristic points nondeterministic reduction rules calculi represent various computational meaning classical proofs paper mainly concerned strong normalizability calculi namely prove strong normalizability calculi open problem first formulate nondeterministic variant parigots calculus show strongly normalizing translate catchthrow calculi variant since translation preserves typing reduction obtain strong normalization catchthrow calculi also briefly consider secondorder extension catchthrow calculi copyright 2002 elsevier science bv b introduction catch throw mechanism provides means implement nonlocal exits following simple example written common lisp 19 shows use catch throw mechanism defun multiply x catch zero multiply2 x defun multiply2 x null x 1 car x car x multiply2 cdr x rst function multiply sets catchpoint tag zero immediately calls second function second one multiply2 performs actual computation recursion given list integers calculates multiplication members list 0 found list result must 0 without computing returns 0 throwexpression catchthrow mechanism useful one wants escape nested function calls time especially runtime errors nakano 1114 proposed calculi inference rules give logical interpretations catchthrow constructs lisp calculi dier actual catchthrow constructs common lisp following two ways 1 changed scope rule catchconstruct dynamic one lexical one example expression throw zero 0 lexically scope corresponding catchexpression indicates catchexpression dynamic scope common lisp 1 nakanos calculi tags variables rather constants correspondence throw catch represented ordinary variable binding mechanism scope binders lexical 2 introduced tagabstraction tagapplication mechanisms exist common lisp 2 motivation recover expressivity lost changing scope rule catchconstruct let us see example written nakanos style defun multiply x catch zero multiply2 x zero defun multiply2 x u null x 1 car x throw u car x multiply2 cdr x u modied program catchconstruct lexical scope scope tag zero multiply2 x zero throw object another function multiply2 function abstracted tag variable u using function multiply2 must provide tag zero second parameter nakano also introduced new type constructor called otherwise tag abstraction mechanism term type u tagvariable type b abstraction u type b characteristic points nakanos formulation 1 l ct restriction side condition implicationintroduction rule excludes terms corresponds classical proofs actually l ct corresponds intuitionistic calculus curryhoward isomorphism 2 l ct allows many reductions possible hence nondeterministic con uent two features may look strange since classical logic said essentially noncon uent intuitionistic logic con uent 3 consider classical version l ct obtained removing restriction natural calculus suitable extracting algorithmic meaning classical proofs call l k ct classical version l ct 1 similarly exception mechanism standard ml dynamic scope 2 exception mechanism standard ml abstractionapplication 3 refer girard 6 parigot 15 discussion con uence classical logic years later nakano second author sato proposed another formulation catchthrow mechanism 17 motivation eliminate type tag abstraction otherwise l ct since equivalent disjunction unifying throwexpression tagabstraction mechanism obtained simpler calculus nj ct also showed l ct interpreted nj ct nj ct essentially restriction implicationintroduction rule hence corresponds intuitionistic logic also dened nk ct throwing away restriction showed corresponds classical logic summary proposed four calculi catchthrow mechanism author intuitionistic logic classical logic nakano l ct l k ct sato nj ct nk ct paper investigate strong normalizability sn four calculi particular l k ct nk ct sn l ct proved nakano 14 proof based complex modeltheoretic arguments previous works proved sn nj ct 8 sn large fragment l k ct 9 sn full fragments classical calculi l k ct nk ct open problem paper solves problem armative way rst formulate nondeterministic variant parigots calculus adding several reduction rules prove strong normalizability using reducibility method translate catchthrow calculi variant since translation preserves typing well reduction obtain proof strong normalizability four calculi nally brie discuss secondorder extension 2 catchthrow calculi 21 nakanos formulation nakano proposed several calculi catchthrow mechanism among l ct given 14 strongest one paper also study l k ct extension l ct although nakano present l k ct published papers latter obtained l ct simply throwing away restriction implication introduction rule therefore regard l k ct one nakanos calculi following shall dene l k ct mention dierence l k ct l ct assume nitely many atomic types use k metavariable atomic including falsity denition 21 type denition types function space product sum curryhoward isomorphism may identify logical connectives implication conjunction disjunction connective introduced give type tag abstraction usual abbreviate assume type innitely many individual variables x type innitely many tag variables u type use x z individual variables u v w tag variables regard u u b dierent tag variables 6 b implies may sometimes use variablename dierent entities dierent types preterms l ct l k ct dened follows denition 22 preterm among preterms constructs catch throw tapp introduced nakano represent catch throw mechanism refer following table correspondence similar constructs common lisp standard ml ct common lisp standard ml noted introduction tags common lisp exception names standard ml represented tagvariables rather constants preterm ut tagabstraction mechanism like abstraction xt preterm tappt u tagapplication mechanism 4 like functional application applyt u sometimes omit types variables also write applya b ab individual variable bound construct caseconstruct tag variable bound catchconstruct construct identify two terms equivalent renaming bound individualtag variables fvt ftvt denote set free individual variables set free tag variables respectively type inference rules given natural deduction style listed table 1 inference rules used derive judgment form nite set form fx g nite set form g sets understand variable appears context individual variables context tag variables l ct implicationintroduction rule marked restriction free tag variables b l k ct restriction intuitionistic calculus l ct preterm x b welltyped x essentially occur scope throwconstruct b one nakanos main results restriction neatly corresponds intuitionistic propositional calculus curryhoward isomorphism actual actually nakano use word tapp rather simply wrote tu tappt u paper use dierent function symbols dierent termconstruction clarify syntax table type inference rules l ct l k ct restriction complex due existence caseconstruct paper give precise denition essential occurrence refer 11 14 details among inference rules rst ten standard rules throw catch ect intended semantics namely aborts current context term type regardless type b type catchu also type possibly thrown terms term u b tagabstraction assigned new type b conversely type b applying tag variable u b generates term type example type inference follows corresponds double negation ag one type inference gure l k ct l ct formation x throwu x abstracted variable x occurs free throwu nakanos restriction let b c metavariables terms derived inference rules say term type contexts onestep reduction rules l ct l k ct given table 2 table onestep reduction rules l ct l k ct 6 x x 2 fv denition c represents context hole dened usual also substitution abx avu dened usual instance following reductions tappvthrowv instead onestep reduction like catchu athrowu bx 1 b catchthrow mechanism splits two steps follows since restrict evaluation strategy reduction l k ct nondeterministic moreover con uent instance following reduction sequences put catchu dene b zero step reduction b one step reduction usual theorem 21 nakano subject reduction property holds l ct l k ct 22 satos formulation 17 sato proposed another formulation catchthrow mechanism primary motivation get rid logical connective l k ct yet obtain system powerful l k ct logical point view redundant since equivalent disjunction sato successfully eliminated calculus unifying two binders tag variables catch shall give denition nk ct following nj ct obtained nk ct restricting introduction rule way l ct l k ct types l ct deleted preterms dened follows denition 23 preterm individual variables bound caseconstructs tag variables bound constructs construct replaces catch l ct construct replaces throw l ct tapplyconstruct replaces tapp l ct type inference rules new constructs given table 3 table type inference rules nj ct nk ct inference rule construct throw l ct term u may constructed even type diers b meaning u b computation ends normally returns 0 returns inj 1 0 term b thrown computation returns inj 2 b hence u b type b type tapplyconstruct may dicult understand inverse operation tag abstraction tapplyu b reduces av b u b type inference rules constructs calculus restriction implication introduction rule called nj ct one without restriction nk ct former corresponds intuitionistic logic latter classical logic onestep reduction rules new constructs given follows u 62 ftva last reduction may look strange useful writing concise proofs 17 necessary simulate reduction tappva u 1 auv l ct l k ct theorem 22 sato subject reduction property holds nj ct nk ct 23 nondeterminism classical logic four calculi catchthrow mechanism nondeterministic reduction rules con uent think defect 1 far strong normalizability concerned good many reduction rules possible corollary strong normalizability strongest calculus obtain strong normalizability subcalculus 2 classical logic said inherently nondeterministic order express possible computations classical proofs calculus nondeterministic later choose one answer xing evaluation strategy murthy gave examples show classical proofs may contain multiple computational meanings 10 second author showed 18 murthys example expressed nk ct style calculus 3 nondeterministic variant parigots section give nondeterministic variant parigots target translation catchthrow calculi parigots calculus 16 secondorder propositional calculus classical logic naturaldeduction system whose sequents multiple consequents calculus quite nice formulation classical logic time computationally interesting since various control structures represented construct whose typing given follows important reduction rule construct called structural reduction afc cbg term obtained substituting cb every subterm form c free refer 16 denition calculus simulate simplied version catchthrow mechanism l k ct construct follows catchu uua throwu vua v appear ua however catchthrow calculi consider con uent moreover one term reduces dierent variables x saw previous section since calculus con uent calculus direct simulation catchthrow calculi possible possible solution add reductions instance callbyvalue version structural reduction symmetric structural reduction however known system structural reduction symmetric structural reduction strongly normalizing 5 instead naively adding reduction rules slightly modify calculus add nondeterministic reductions namely classify uses three cases 1 uua 2 uva u 62 ftvva 3 uva u 6 v u 2 ftva need 1 2 simulate catchconstruct throwconstruct respec tively need extend reduction rules 2 reduction rules 1 remain need 3 simulate catchthrow calculi term construction excluded another modication calculus longer distinction individual variables tag variables named term ua represented ordinary application ua modication directly abstract variables correspond names key simulate tagabstractiontag application mechanism l k ct representation essentially due de groote 3 formalized exception mechanism ml fujita 4 recently studied similar calculus exception mechanism notational convenience write ua term uua abortva term uva also extend reduction rules abortconstruct nondeterministic features call resulting system nd 31 nondeterministic calculus nd types nd dened follows denition 31 type recently fujita5 indicated system shown strongly normalizing translating barbanera berardis symmetric calculus restrict system rstorder however need secondorder version paper since nd secondorder type redundant logical point view however include primitive type since want interpret dierently 8xx type variable x bound type abstraction 8x identify two types identical modulo renaming bound type variables abbreviate preterms follows note adopt currystyle implicit typing nd calculus 6 hence attach types variables consider reduction rules denition 32 preterm contrary original one sort variables variable x may used ordinary variable also name tagvariable sense also distinction ordinary terms named terms variables bound constructs identify two terms diers bound variables preterm abortt new nd explained judgment nd form nite set form g type inference rules derive judgments shown table table type inference rules nd 8introduction rule marked x may occur freely derived using rules say typable term type sometimes written reduction rules derived calculus added several rules abort makes nd nondeterministic since shall use substitution 6 16 parigot also denes churchstyle system table onestep reduction rules nd form xuxbu many times abbreviated b u using notation always assume x fresh variable also abbreviate composition substitutions often write b sequence hb 1 b n hence successive application ab 1 b n abbreviated b successive substitution last case assume b 1 b n contain u free also use simultaneous substitution b 1 x um mutually distinct c contain u use notation b b following lemma proved easily lemma 31 let substitution b 1 x um b b 32 strong normalizability nd subsection prove strong normalizability sn nd proof slight modication parigots original proof sn nevertheless give proof completeness let set preterms nd sn set strongly normalizing preterms nd note restrict nd subsets typable terms following 16 maximum length reduction sequences starting 2 sn undened 62 sn f let f set nite sequences elements f namely particular f contains empty sequence hi let f g subsets subset introduce following notations special case g denition 33 reducibility candidate reducibility candidate subset inductively dened follows 1 sn reducibility candidate 2 f g reducibility candidates f g 3 ff g i2i family reducibility candidates nonempty set reducibility candidate note index set may innite set reducibility candidates denoted rc lemma 32 f 2 rc following four clauses hold 1 f sn 2 variables contained f 3 2 sn aborta 2 f 4 exists set sn clause 3 added parigots original proof means aborta strongly normalizing term contained reducibility candidate main dierence proof parigots case term form caborta may reduce aborta always consider aborta reduct however term contained reducibility candidate strongly normalizing lemma therefore always handle term easily proof prove four clauses simultaneously induction f 2 rc case f sn clause 4 proved taking fhig clauses trivial case f g induction hypothesis abbreviated ih x proves clause 1 ih g sn exists set 0 sn taking g g proves clause 4 let x variable 2 sn b since reducts form xb 0 n abortdbk1 b 0 proving clause 2 also abortab proving clause 3 case f easily proved ih also ih sn g proves clause 4 ut clause 4 lemma put f largest namely preterm neutral either variable form bc lemma 33 f 2 rc following two clauses hold 1 2 f 1 0 0 2 f 2 neutral 0 2 f 0 1 0 2 f proof lemma proved induction f 2 rc key case f g h shall prove clause 2 suppose neutral 0 2 g h 0 1 0 take arbitrary preterm b 2 g shall prove ab 2 h induction b since b sn preterm ab reduces one step either one 0 b 1 0 ab 00 abortcx abortd b b 00 abortdx easily prove four terms belong h ih ab 2 h consequently 2 g h ut denition 34 interpretation types interpretation map type variables reducibility candidates note exists interpretation maps type variables sn interpretation naturally extended types following way interpretation fx dened 6 x lemma 34 let b types interpretation lemma proved induction structure lemma 35 let f 2 rc x u variables b terms c sequence terms 1 abx 2 f b sn xab 2 f 2 u ad udc 2 sn c 3 c 4 2 sn u 2 sn proof 1 prove clause induction abx b using lemma 31 lemma 33 must take care reducts xab may form abortc case treated using clause 3 lemma 32 2 prove clause induction u ad udc 3 clause 1 prove ubc 2 sn b 2 f since 4 proved analyzing reduction rules ut theorem 31 assume derived nd assume also interpretation b rst look statement theorem looks ambiguous instance given proof x c may split lefthand side two ways results following conclusion holds b 1 2 c b 2 2 holds b 2 c c 2 actually theorem implies hold ambiguity arises state proof theorem proof theorem proved induction type inference let substitution b 1 x case assumptionrule case x prove x 2 two subcases x x c x b assumption b 2 c x 2 ii x u x zu zc lemma 35 x 2 case introduction case x c b c c term type c suitable renaming x c take 2 b ih hence lemma 35 x cd 2 c hence c case elimination case bc hence bc 2 case 8introduction case 8x b b derivable let f 2 rc 0 fx since type variable x occur freely b hence ih 2 0 b finally 2 8x b case 8elimination case 8x b bcx 2 8x b ih hence 2 cxb lemma 34 2 bcx case introduction case ub b suitable renaming u b ih hence b 0 c 2 sn therefore clause 4 lemma 35 u b 0 c 2 sn clause 2 lemma 35 u bc 2 sn consequently case elimination case abortb ih b 2 32 abortb 2 ut choosing x theorem obtain 2 term type interpretation since exists interpretation sn following theorem corollary 31 nd strongly normalizing 4 translation catchthrow calculi nd section gives translations catchthrow calculi nd following give translations classical catchthrow calculi l k ct nk ct translations work also l ct nj ct since subcalculi 41 translation nakanos calculus shall translate l k ct nd translation standard encoding propositional logic secondorder logic except catchthrowconstructs first translate types l k ct variables nd point type ab translated b translation ects intention abstraction translated abstraction translate preterms l k ct nd assume individual variable x l k ct x variable nd tag variable u l k ct u variable nd also assume mapping variables injective preterms translated follows x x aborta aborta x xa ab ab axyx xyxa tappa translation extended contexts variables following way let context individual variables fx 1 context tag variables l k ct dene note types tag variables negated translation translation preserves typing reduction shall see lemma 41 preservation type assignment derived l k ct derived nd proof since translation propositional connectives standard verify cases ih since fu ag fu ag ua derive fu ag catchu introduction rule throw ih since fu ag abortua derive elimination rule elimination rule ih since b b derive introduction rule tapp ih elimination rule derive lemma 42 translation compatible substitution namely abx abx av b avu lemma proved straightforward induction construction omitted lemma 43 preservation reduction b typable terms 1 b l k ct b nd proof lemma proved induction structure term prove key cases 1 6 x x 2 fva lemma 42 athrowu bx aabortubx induction term aabortcx abortc c aabortubx abortub 2 catchu 1 u 62 ftva since u 62 fv catchu ua 1 3 catchu throwu catchu throwu uabortua u 62 fva 4 tappua tappua v uav reduces avu lemma 42 avu avu hence done ut lemmas following theorem theorem 41 system l k ct strongly normalizing hence l ct strongly normalizing remark translation l k ct nd really need second order quantier namely eliminate 8 add nd translate ct modied calculus since prove sn modied calculus elementary method 16 also prove sn l k ct elementary method however need second order quantier 8 translating nk ct shall see next section therefore proved sn l k ct based reducibility method 42 translation satos calculus subsection translate nk ct nd dening translation try give naive translation nk ct l k ct explains fails natural candidate translation type tapplya type c supplied type inference term moment let us ignore obtain c translation interpret one reduction rules nk ct exception following one lefthand side interpreted tapplyua v casecatchu inj 1 necessarily reduce avu hence naive translation nk ct ct fails moreover seems dicult nd suitable extension l k ct strongly normalizing reduce term avu however situation changes consider secondorder calculus disjunctive type primitive dened b shall see later term tapplyua v reduces avu encoding let us dene translation nk ct nd translation types translation l k ct nd translation preterms except translation new constructs dened follows tapplya assume x used term translation may look complex result secondorder encoding naive translation nk ct ct translation extended context individual variables way context tag variables need change translation since tag variable type b translated variable type c b c type body enclosing expression words cannot determine type c reach enclosing expression solve problem introduce mapping set tag variables nk ct set types nd make translation contexts tag variables dependent let context tag variables fu b1 g mapping fu b1 n g types nd dene denition 0 abbreviation dened c 0 8x result translation lemma 44 preservation type assignment derivable nk ct mapping whose domain contains tag variables derivable nd proof proved induction derivation verify key cases derive fix mapping suppose otherwise proof shorter 0 bg let 0 mapping 0 v v v 6 u 0 u ih derive 0 0 bg also facts derive desired type inference introduction rule derive fix ih derive b abortuxyya derive desired type inference elimination rule derive ih derive b bg tapplya u b axxyabortuzwwy calculating type term derive desired type inference ut next lemma used proving preservation reduction translation lemma 45 let typable term nk ct let substitution xvxt 1 2 v v result translation tag variable v b nk ct 1 xx 2 yabortuzwwy auv nd proof prove lemma induction structure term state key cases case v following reduction sequence case tapplyb v b following reduction sequence lemma 46 preservation reduction b typable terms 1 b nd b nd proof check key cases tapplyexpression following put 1 xx 2 yabortuzwwy 1 tapplyinj 1 tapplyinj 1 2 tapplyinj 2 tapplyinj 2 abortuzwwa last term u b 3 tapplyva u tapplyva u vzwzat 1 2 auv hence desired property ut lemmas following theorem theorem 42 system nk ct hence nj ct strongly normalizing remark proof use second order quantier 8 indispensable give translation nk ct since nk ct rstorder system one may think proof used strong method sn nk ct could proved elementary method present answer question trial apply elementary method nk ct successful 5 extension catchthrow calculi given translation nd easy introduce secondorder quantier four catchthrow calculi without loss nice properties strong normalization since catchthrow calculi formulated churchstyle variables explicitly labeled types introduce termconstructs type abstractionapplication usual let xa denote former ax latter typing rules given follows 8introduction rule marked x may occur freely also reduction rule xab 1 abx added adding rules l k ct obtain secondorder catchthrow calculus l k2 ct similarly obtain nk 2 ct calculi l k2 ct nk 2 ct enjoy nice properties subject reduction strong normalization brie mention expressivity calculi structures integers binary trees encoded secondorder quantier 6 dene functions catchthrow mechanism various data types extended calculi instance function multiply mentioned typed follows int uufttuuf intlist wwfttwwf timesa b multiplication two integers b dened usual int intlist iterators type int intlist term int zb x x 62 fv b ifthenelse expression namely reduces x 0 b otherwise easily seen function multiply computation one given introduction since representation free structures good computation 6 may consider another direction extension namely may add inductive data types 8 rst author already proposed add inductive data types nj ct without loss sn calculus showed higherorder functions use catchthrow mechanism represented extended calculus however fully studied direction classical catchthrow calculi left future work 6 concluding remarks investigated four catchthrow calculi nakano sato particular calculi correspond classical logic curryhoward isomorphism dene nondeterministic variant parigots calculus proved strong normalizability variant gave faithful translations catchthrow calculi variant corollary obtained strong normalizability four calculi also discussed extension brie recently fujita 4 studied exc callbyname variant de grootes formulation exception mechanism standard ml calculus subcalculus rstorder version calculus since catchthrow mechanism exception mechanism essentially motivation similar main dierences calculus nd 1 calculus con uent nondeterministic computations 2 uses rstorder version actually implicational use secondorder version 3 calculus two sorts variables reminiscent individual variables tag variables use one sort variables thus directly abstract tags crolard 2 also studied con uent calculus catchthrow mechanism since calculus translated parigots calculus similar fujitas formulation thus diers calculi studied paper extracting algorithmic contents classical proofs quite active research area many researchers area aim obtaining con uent calculi classical logic however classical logic said inherently nondeterministic namely classical proofs may contain multiple computational meanings therefore want represent many computational meanings possible natural begin nondeterministic calculi approach design study nondeterministic calculi rst study con uent subcalculi believe catchthrow calculi presented paper good basis approach barbanera berardis calculus 1 another nondeterministic calculus classical proofs calculus could also good basis studies extracting computational meaning classical proofs left future work acknowledgement would like express heartful thanks hiroshi nakano makoto tatsuta izumi takeuti helpful comments earlier works also thank kenetsu fujita pointing references errors anonymous referees valuable comments improvement author supported part grantinaid scientic research ministry education science culture japan 09780266 10143105 r proofs types cambridge university press classical catchthrow calculus tag abstractions strong normalizability tr common lisp language proofs types formulaeastype notion control intuitionistic classical natural deduction systems catch throw rules lambdamycalculus extracting constructive content classical logic via controllike reductions simple calculus exception handling classical brouwerheytingkolmogorov interpretation ctr emmanuel beffara vincent danos disjunctive normal forms local exceptions acm sigplan notices v38 n9 p203211 september
creation views reuse software different data representations software reuse inhibited many different ways equivalent data represented describe methods views constructed semiautomatically describe application data types correspond abstract types used numerical generic algorithms given views specialized versions generic algorithms operate directly application data produced compilation enables reuse generic algorithms application minimal effort graphical user interfaces allow views specified easily rapidly algorithms presented deriving symbolic algebra equations relate variables used application data variables needed generic algorithms arbitrary application data structures allowed units measurement converted needed techniques allow reuse single version generic algorithm variety possible data representations programming languages techniques also applied data conversion objectoriented functional transformational programming b introduction algorithm like mathematical theorem sense algorithm developed reusable never recoded manually like engineering artifacts however algorithms used application must adapted fit parts application almost everyone willing reuse standard algorithm sqrt algorithms testing whether point inside polygon less likely reused argument result types sqrt match application types however many possible polygon representations application unlikely use data types library program strong typing important optimization checking types statically compiler avoid generation runtime typechecking code thus providing type safety saving time storage unfortunately rigidity types inhibits reuse traditional ways making application data match procedure reused costly discourage reuse 24 effective method reuse must minimize two costs 1 human cost time required programmer find program reused understand documentation adapt reused program andor application fit 2 computational cost added cost running reused program compared handwritten version paper describes methods reuse using views describe application data types correspond abstract types used generic algorithms algorithms based algebra create views correspondences specified via easily used graphical interface given views compiler produces efficient specialized versions generic algorithms operate directly application data single copy generic algorithm specialized variety application data representations variety programming languages efficiency encapsulation type safety strong type checking retained barriers reuse caused type rigidity eliminated techniques described enabling technology makes software reuse easy practical graphical interface illustrated fig 1 example assume user existing data describes christmas tree user would like reuse small program calculates area side cone data view type xmastree cone made using program mkv make view mkv cone xmastree figure 1 viewing christmas tree cone view specified correspondences application data type abstract representation cone user first selects button cone diagram selects corresponding item within menu fields xmastree type system draws lines selected items show correspondences using correspondences together equations associated cone system constructs view xmastree cone generic procedure associated cone specialized used xmastree data gldefun t1 treexmastree function written lisplike functional form requests sidearea cone view tree function compiled lisp code computes sidearea directly application data structure lambda tree 31415926535897931 mechanical translation produce code applications languages c float t1c tree return 31415926535897931 treebaseradius sqrtsquaretreebaseradius user obtains specialized code without understand algorithm without understand implementation cone abstract data type user needs select items diagram correspond application data paper concentrate numerical data kinds used scientific engineering programs previously described 33 34 35 techniques reuse generic algorithms deal discrete data structures linked lists trees methods together methods described paper allow reuse algorithms involve discrete data structures numerical data generic algorithms specialized range simple formulas formula area circle larger procedures testing whether point inside polygon section 2 gives formal definition views section 3 presents algorithms construct views correspondences using algebraic manipulation equations section 4 describes graphical user interface specifying views section 5 describes several ways views enable software reuse specialization generic procedures translation data desired form objectoriented functional transformational programming section 6 surveys related work section 7 presents conclusions finally online demonstration program described representation views traditional data types combine two issues separated facilitate reuse 1 way application data represented 2 procedures associated conceptual kind object termed implementation inheritance interface inheritance objectoriented programming 9 two combined code procedure implicitly states assumptions details data representation inhibits software reuse since assumptions made writing procedure become requirements must met procedure reused effective reuse assumptions must minimized objectoriented programming functional programming partly separate two issues still make representation assumptions also incur performance penalties discuss later views make clean separation representation procedures compilation techniques yield good performance produce code multiple target languages many ways representations equivalent data differ 1 names individual variables 2 data representations units measurement variables 3 data structures used aggregate variables 4 set variables chosen represent object 5 conceptual method ontology 30 representation example vector could represented using cartesian coordinates polar coordinates order reuse generic algorithm application data must possible either translate data form expected algorithm modify algorithm work existing data done using views view describes application data type corresponds abstract type effect view encapsulates application data type makes appear abstract fig 2 illustrates application type pipe viewed circle defined terms radius radius circle corresponds insidediameter pipe divided 2 view makes visible name radius hiding names pipe procedures defined circle inherited view note case pipe circle rather circle useful view pipe second view pipe circle using outsidediameter also useful length insidediameter outsidediameter material radius pipeascircle pipe figure 2 view encapsulation application data formalize notion views follows abstract type considered abstract record containing set basis variables view encapsulates application type hiding names presents external interface consists basis variables abstract type view allows basis variables read written view emulates abstract record maintaining two properties 1 storage property value z written basis variable v read v yield value z 2 independence property read basis variable v yields value z value written basis variable v j read v still yield z two properties express behavior normally expected record stored values retrieved storing one field change values fields properties maintained view faithfully emulates record consisting basis variables using application type internal storage view inherits generic procedures associated abstract type view thus makes application type appear fullfledged implementation abstract type smith 45 uses term theory morphism similar notion gries 17 uses term coupling invariant cites term coordinate transformation used dijkstra 7 example fig 2 illustrates simple view pipe viewed circle terms basis variable radius read radius accomplished dividing insidediameter 2 write radius implemented multiplying value written 2 storing insidediameter source code accesses radius view equivalent compiled code c shown gldefun t5 ppipe radius circle p float t5 p return pinsidediameter 2 gldefun t6 ppipe rreal radius circle p r return view makes application data appear exactly like abstract type generic procedure defined abstract type produce results using application data view optimized inline compilation code access data views specialized versions generic algorithms operate directly application data efficient practice often necessary relax storage independence properties slightly 1 storage independence properties assumed hold despite representation inaccuracy eg floatingpoint roundoff error example application type uses polar coordinates viewed cartesian vector value x read may slightly different value x written 2 view may partial ie may define basis variables used example compute area circle radius needed use undefined basis variable detected error compiler 3 creation views correspondences view contains set procedures read write basis variable abstract type procedures could written hand however nontrivial ensure procedures complete consistent efficient satisfy storage independence properties procedures view application type linesegment fig 5 66 lines code would difficult make view manually section describes algorithms derive procedures view correspondences using symbolic algebra later section describes graphical user interface makes easy specify correspondences 31 basis variables equations setf get circle basisvars radius setf get circle equations diameter 2 radius circumference pi diameter area pi expt radius 2 figure 3 equations circle abstract type defines set basis variables set equations basis variables equations simple circle abstract type shown fig 3 linesegment shown fig 4 equations written fully parenthesized lisp notation operator appearing first subexpression basis variables specified designer abstract data type constitute contract implementer user generic procedures implementer assume every use generic procedures behave set basis variables directly implemented user assume view application data emulates direct implementation basis variables generic procedures work application data view created correspondences provided graphical interface equations correspondence pair abstractvar applicationvar associates variable abstract type corresponding variable application processed sequentially view must procedure read write basis variable maintaining storage independence properties procedures derived symbolic algebra although powerful packages mathematica 54 exist use simple equation solver interface actually allows algebraic expression terms variables computed quantities application type setf get linesegment basisvars p1x p1y p2x p2y setf get linesegment equations p1y p1 p2y p2 deltay p2y p1y slope deltay float deltax slope tan theta slope 10 tan phi length sqrt expt deltax 2 expt deltay 2 theta atan deltay deltax phi atan deltax deltay deltay length sin theta deltax length cos theta deltay length cos phi figure 4 equations linesegment relatively large possibly redundant set simple equations fig 4 equations describe abstract data types typically simple simple equation solver sufficient equations solved algebraic manipulations equation solver given formula desired variable lefthand side formula desired variable equation solved otherwise attempt made invert righthand side using algebraic laws find desired variable example equation x z equivalent x z x z manipulations performed recursively desired variable isolated course procedure assumes desired variable occurs exactly equation equations specify variable tuple variables used describe grouping relationships application data might specify point terms separate x components data structure represents point whole either containing x components directly view defines x user graphical interface able specify either whole representation point one components however would incorrect specify whole component treatment tuple equations described guarantees correct combinations specified corresponding tuple definition equations define extract components tuple 32 incremental equation solving equation set initialized making copy equations target abstract type correspondence abstract variable application variable processed equation set examined see whether equations solved incremental solution equations accomplishes several goals 1 produces equations computing variables abstract type terms stored variables application type equations later compiled code 2 produces efficient ways computing variables described 3 algorithm returns list variables defined computable based correspondences entered thus far buttons variables removed user interface preventing user entering contradictory specification following algorithm call vardefined performed correspondence abstractvariable applicationvariable 1 abstract variable added list defined variables list solved variables ie variables computable correspondences specified far 2 equation examined determine unsolved variables contains exactly one unsolved variable equation solved produce new equation defining variable righthand side new equation symbolically optimized using patternmatching optimizer ii new equation saved later use generating code iii variable added list solved variables iv equation deleted b unsolved variables equation deleted case occur equation set contains multiple equations computing variable assuming equation set consistent equation represent mathematical identity among variables already defined c equation defines tuple variable component tuple solved variable added list deleted tuple variables equation deleted equation contains deleted tuple variable equation deleted deleted tuple variable never become defined 3 variables solved step 2a step 2 repeated 4 finally list variables returned list includes newly defined variable variables solved using equations deleted tuple variables figure 5 viewing ls1 line segment fig 5 shows correspondences application type ls1 linesegment correspondences specified using graphical user interface vardefined called individual correspondence specified correspondences saved view remade without using graphical interface correspondence pair abstract variable field application type example fig 5 correspondences length size fig 6 shows calls vardefined actions performed correspondence processed action labeled number step algorithm correspondences processed two results produced 1 list abstract variables defined references application type 2 list equations define abstract variables 1 enter vardefined 2c deleting tuple 2d deleting eqn p1x x p1 2d deleting eqn p1y p1 4 exit vars p1 p1y 1 enter vardefined 4 exit vars length 1 enter vardefined 2a solved eqn slope tan theta 2a solved eqn phi pi 20 theta 2a solved eqn deltay length sin theta 2a solved eqn deltax length cos theta 3 repeating step 2 2a solved eqn deltay p2y p1y giving p2y deltay p1y 2b deleting eqn slope deltay 2b deleting eqn slope 10 tan phi 2b deleting eqn length 2b deleting eqn atan deltay deltax 2b deleting eqn phi atan deltax deltay 2b deleting eqn deltay length cos phi 2b deleting eqn deltax length sin phi 3 repeating step 2 2c deleting tuple 2d deleting eqn p2x x p2 2d deleting eqn p2y p2 4 exit vars p2 p2y deltax deltay phi 1 enter vardefined 2a solved eqn deltax p2x p1x giving p1x p2x deltax 3 repeating step 2 4 exit vars p1x p2x figure incremental equation solving abstract type gammapsi r theta theta theta theta figure 7 variable dependency graph ls1 equations form directed acyclic graph ultimately defines variable lefthand side equation terms references application type fig 7 shows graph ls1 example variable righthand side equation replaced defining equation process repeated replacements possible result expression tree whose leaves references application type 2 easily proved induction initially solved variables defined correspondence application type variable becomes solved via equation defined terms previously solved variables therefore graph variable references acyclic replacement variables equational definitions result expression tree whose leaf nodes references application type general abstract type define procedures compute variables shown diagram functions basis variables therefore strictly necessary view type define procedures compute basis variables variables could derived however approach might inefficient example would inefficient calculate length basis variables application type since ls1 type stores length directly field size desirable compute variable directly possible application data ie using data references operations possible vardefined algorithm operates incrementally produces equation calculate abstract variable soon possible equations therefore close references application type would possible guarantee optimal computation variable implementing search algorithm replacement process performed glisp compiler code uses view compiled 1 assign abstract variable defined field application type cost 1 mark solved 2 examine equation equation set determine variables solved terms existing solved variables assign cost solution sum costs components cost operator variable unsolved higher cost adopt new equation definition new cost cost 3 repeat step 2 redefinitions occur implemented algorithm vardefined algorithm approximates produced excellent results practice algorithm would useful operators much higher cost others 33 storing basis variables generic procedures read write data thus necessary define methods store basis variables view assume values stored basis variables reasonable restriction since corresponds record consisting basis variables ordinary programming language storing method small procedure whose arguments instance application type value stored basis variable procedure must update application data way storage independence properties maintained without constraint method used store variable would ambiguous generic algorithms might behave differently different data implementations variables abstract type correspond directly fields application type called transfer variables list saved fig 7 transfer variables p1y length theta p2x storing new values transfer variables following change value basis variable would accomplish storing basis variable procedure could derived trivial way 1 compute values basis variables one stored application data 2 compute values transfer variables basis variables 3 store values application data structure however procedure might inefficient desirable update smallest possible subset stored variables algorithm accomplishes 1 set basis equations created done initializing equation set equations abstract type calling vardefined basis variable result set equations computing nonbasis variable terms basis variables implicitly dependency graph shows dependency variables basis variables 2 set xfers computed subset transfer variables depend basis variable stored dependency determined recursively computing union leaf nodes expression tree transfer variable implicitly defined basis equations 3 set dep computed subset basis variables member xfers depends 4 code generated compute basis variable dep basis variable stored application data 5 code generated compute transfer variable xfers store corresponding field application structure temporary variables generated intermediate variables used computing transfer variables used otherwise intermediate variables expanded using basis equations result algorithm procedure revises application data structure much necessary emulate store basis variable leaving values basis variables unchanged one procedure created basis variable special case basis variable corresponds exactly transfer variable affect value transfer variable procedure needs created glambda varls1 p1y deltay p2y p1y deltax p2x p1x figure 8 method store p1y ls1 data structure example procedure store basis variable p1y ls1 shown fig 8 although p1y corresponds directly low field also necessary update values size angle fields order leave value basis variable p2y unchanged right field need updated 34 creating application data basis variables generic procedures create new data structures example two vectors added produce new vector therefore view must procedure create instance application type set basis variable values similar storing basis variable except basis variables stored simultaneously glambda self p1x p1y p2x p2y let deltay deltax deltay p2y p1y deltax p2x p1x angle atan deltay deltax figure 9 method create ls1 data structure basis variables fig 9 shows procedure creates ls1 data structure set linesegment basis variables two local variables deltax deltay created since variables used compiled glisp function produces instance ls1 data structure specified component values tuple substructures involved additional functions inserted create well glisp compiler invokes method compiling function result use views recursive example linesegment could specified two points p1 p2 polar coordinates r theta view cartesian vector case creating new linesegment instance would also create new polar components 35 data translation views suppose two data types 1 2 view abstract type easy translate data 1 type 1 1 basis variable v abstract type compute value data 1 using view type 1 view view figure 10 application data share view 2 create data structure type 2 set basis variables using view however algorithm might efficient example types 1 2 might store nonbasis variable could transferred directly without computing basis variable values reason developed another algorithm creating data translation procedures algorithm begins finding unique abstract type intersection views source goal types name view used type specified intersection unique next set xfers computed set transfer variables goal type ie variables abstract type correspond stored fields goal type code generated create instance goal type using values transfer variables shared view source type since view computes transfer variables close source data possible resulting code often efficient never worse version computes basis variables first optimal code could guaranteed search process described earlier 36 unit conversion application data use various units measurement programming languages omit units measurement entirely way state units used much less check consistency units glisp allows units specified automatically performs unit conversion 37 checks validity therefore unit conversion performed automatically uses views described paper checking user could specify partial set correspondences abstract type application type generic procedures defined abstract type may involve subset basis variables example possible compute slope linesegment abstract variable theta defined however actual errors detected system user enters correspondences mkv issues warning basis variables remain unsolved method store basis variable produced variable solved basis variables set dep described section 33 solved method create application data structure basis variables produced basis variables solved attempt specialize generic procedure uses missing parts view type result errors detected glisp compiler possible user specify correspondence computed cannot stored example variable abstract type could defined sum two stored fields application type possible determine unambiguously store variable attempt store variable result error detected glisp compiler views replace evade strong typing indeed code produced correctly typed mechanically translated strongly typed language views enhance type checking checking units measurement provide encapsulation view used operations defined view available view mechanism provides benefits encapsulation enhancing reusability producing efficient code encapsulation mechanisms 9 4 graphical user interface graphical user interface makes easy specify correspondences application type abstract type using mouse pointing device program called mkv make view called goal abstract type source type arguments mkv opens window draws menu values available source type diagram menu variables abstract type fig 1 user selects items goal diagram clicking mouse labeled buttons diagram interface program highlights button mouse pointer moved near clicking mouse selects item user selects corresponding item menu represents application data line drawn two items show correspondence user also specify algebraic expression involving one application data fields selecting op command menu specifying expression tree operators operands diagram present buttons many ways represent given kind data 3 diagram likely buttons correspond directly existing form data fig 11 shows diagram linesegment even though linesegment simple concept line segment could specified many ways two end points one end point length angle etc diagram intended present virtually reasonable possibilities buttons interface several advantages 1 diagrams easily rapidly perceived humans 26 widely used engineering scientific communication 11 3 alternative representations sufficiently different require different diagrams menu select among alternative diagrams could presented user first figure initial diagram line segment 2 interface selfdocumenting user need consult manual know details abstract data type specify view 3 interface fast requiring mouse clicks create view 4 user perform errorprone algebraic manipulations easy add diagrams new abstract types drawing program allows creation diagrams including buttons thing needed specification basis variables equations abstract type shown figs 3 4 achieving reuse views views important practical reuse achieve clean separation representation application data abstract data types used generic procedures user obtains benefits reuse without understand conform standard defined someone else section describe several ways views applied achieve reuse 1 specialization generic procedures views 2 translation data 3 creation wrappers transforms use objectoriented functional transformational programming 51 specialization generic procedures glisp compiler 31 32 produce specialized version generic procedure compiling relative view result selfcontained procedure performs action generic procedure directly application data specialized procedure used part application program glisp highlevel language abstract data types compiled lisp implemented common lisp 47 glisp types include data structures lisp languages glisp described briefly detail see 33 31 data representation barrier reuse languages syntax program code depends data structures used depends whether data stored computed prevents reuse code alternative implementations data glisp uses single syntax similar lisp function call access features object 33 interpretation form depends compiletime type object 1 feature name data field object code access field compiled 2 feature message selector defined type object runtime message send compiled b procedure implements message specialized compiled inline recursively 3 feature name view defined type object type object locally changed view type 4 feature defined function code left unchanged function call 5 otherwise warning message generated feature undefined way generic program access feature application type without making assumptions feature implemented similar objectoriented programming however since actual data types known compile time message sending eliminated replaced inline compilation calls specialized procedures equivalent making transformations code significantly improves efficiency compiled code view implemented glisp type whose stored form application data abstract type associated view superclass view type view type defines messages compute basis variables abstract type application type simple example consider handwritten simplicity view pipe circle fig 2 pipeascircle p pipe prop radius insidediameter p supers circle stored form pipeascircle named p type pipe basis variable radius defined insidediameter pipe divided 2 circle superclass methods circle inherited pipeascircle gldefun t7 ppipe area circle p float t7 p return 078539816 function t7 argument p whose type pipe code circle p changes type p view type pipeascircle definition area inherited circle compiled inline definition terms radius expanded inline insidediameter pipe divided 2 use view zero cost runtime optimizer combined translation view constant producing new constant 4 view made generic procedures abstract type available automatic specialization thus single viewing process allows reuse many procedures larger example consider function finds perpendicular distance point left directed line segment point right distance negative although large function easy find effective algorithm reference book derive hand graduate students assigned produce procedure hand ls1 data type report takes 20 minutes hour books often omit important features 3 assumes human determine sign result even formula found may expressed terms available data versions formula involve division numbers nearly zero reuse carefully developed generic procedure faster less costly less errorprone writing one hand code results viewing compilation process presented expect user system read understand code authors 42 proposed user read edit code produced automatic programming system easy read someone elses code especially true machinegenerated code optimized expect users treat output system black box often done library subroutines fig 12 shows generic function linesegmentleftofdistance fig 13 shows specialized version ls1 record c code produced glisp compilation gldefun linesegmentleftofdistance lslinesegment pvector deltay ls figure 12 generic function distance point left line segment float lsdist l p return coslangle px lright lsize coslangle figure 13 leftofdistance specialized ls1 c followed mechanical translation c resulting c code dependence lisp since ls1 type quite different abstract type linesegment example illustrates single generic procedure reused variety quite different implementations data specialized version efficient two multiplies division length removed algebraic optimization expressed terms application data without added overhead repeated subexpressions sometimes appear specialized code removed wellunderstood compiler technique common subexpression elimination 43 useful viewpoint mapping abstract data type corresponding application type isomorphism two based generic algorithm specialized version algorithm compilation program ordinary programming language produces equivalent program terms lowerlevel operations data implementations specialization generic procedure produces equivalent procedure tightly bound specific implementation abstract data similar viewpoints found mathematical definitions isomorphism eg 39 p 129 denotational semantics 15 work program transformation 45 17 13 describes views terms isomorphisms however note many applications use approximations satisfy strict mathematical definition isomorphism 52 reuse data translation one way reuse program data different format translate data right form translation also required combine separate data sets different formats use computer networks increases users often need combine data different sources use data program assumes different format arpa knowledgesharing project 30 addresses problem sharing knowledge bases developed using different ontologies writing data translation programs hand requires human understanding data formats 40 presents language describing parameter lists system produces interface modules translate source calling sequence target calling sequence paper 33 described automatic construction translation procedures correspondences techniques paper extend standardization data representations formats one way achieve interoperability however difficult find standards fit everyones needs conformity standards costly users views provide benefits standardization without costs described section 35 views two application types common abstract type data conversion procedure convert one application type generated automatically thus interchange data requires owner data set create view describes local data format corresponds abstract type n views needed translate among n data formats knowledge others data formats unnecessary use remote procedure calls servers across network could facilitated advertising abstract data type expected remote procedure users create views data abstract data translation data performed automatically materialization new data set may computationally expensive cost minor small data sets also reasonable translate large data set incrementally whole large amount computation performed 25 found translation data phases large compiler minor cost 53 objectoriented functional transformational program ming algorithms paper used styles program development one benefit objectoriented programming oop reuse methods predefined time oop systems often impose restrictions application objects must meet eg application object must stored data superclass must provide certain methods names used existing methods thus reuse oop requires conformance existing standards views allow new kinds objects used existing methods term adapter wrapper 9 denotes object class makes application data appear instance target class wrapper object contains pointer application data performs message translation implement messages required member target class pipe example shown fig 2 wrapper class pipeascircle would implement radius message expected class circle sending insidediameter message pipe returning result message divided 2 algorithms user interfaces described paper could used create wrapper classes messages expected target class correspond basis variables equations produced making views easily converted methods appropriate syntax oop system previously described 35 use wrapper objects allow display directmanipulation editing user data generic editor programs two disadvantages using wrapper objects 9 necessary allocate wrapper object runtime costs time storage second since translation data performed interpretively overhead additional message sending translation may performed many times execution however cases costs tolerable wrapper objects easy way achieve reuse views used related way functional programming functions created calculate value basis variable data application type pipe example function radiusppipe would created returns value insidediameter divided 2 storing basis variables could implemented storing application data functional languages allow creating new data updated values case strict functional languages polya language 17 8 allows user specify set transformations made intermediate code generic algorithm transformations equivalent transformations performed glisp compiler 31 algorithms presented could used generate transforms language polya 6 related work 61 software reuse krueger 24 excellent survey software reuse also gives criteria effective software reuse biggerstaff perlis 4 contains papers theory applications software reuse mili 29 provides extensive survey approaches software reuse emphasizing technical challenges reuse software production artificial intelligence approaches software engineering described 1 28 41 papers sources reviewed individually section 62 software components weide 52 proposes software components industry analogous electronic components industry based formally specified unchangeable components rigid interfaces components would verified unchangeable rigid interfaces errors using modifying would prevented views described paper allow components adapted fit application 63 languages generic procedures programming languages ada modula2 21 27 c 48 allow parameterized modules constructing module containing generic procedures parameterized abstract data type user obtains specialized version module procedures however languages allow much less parameterization possible using views example possible define procedure works either cartesian polar vectors even possible state units measurement languages 64 functional set languages ml 53 38 like strongly typed lisp includes polymorphic functions eg functions lists arbitrary type functors functions map structures composed types functions structures ml also includes references pointers allow imperative programming ml functors instantiate generic modules container types however ml allow generics general described system allows storing data structure view example radius value stored pipe view system also allows composition views miranda 50 strongly typed purely functional language supports higherorder functions allows generic functions written often difficult write efficient programs purely functional language 38 change data values requires creation new structure functional language 65 transformation systems transformation systems generate programs starting abstract algorithm specification repeatedly apply transformations replace parts abstract algorithm code closer implementation executable code finally reached views specify transformations features abstract types implementations kant et al 23 describe sinapse system generating scientific programs involving simulation differential equations large spatial grids applications seismic analysis sinapse accepts relatively small program specification generates much larger program fortran languages repeatedly applying transformations within mathematica 54 system appears work well within domain applicability kids 46 transform general algorithms executable versions highly efficient combinatorial problems user selects transformations used supplies formal theory domain application system interesting powerful user must mathematically sophisticated gries prins 16 proposed system would use syntactic transformations specify implementation abstract algorithms 31 describes related techniques implemented earlier volpano 51 gries 17 describe transformation programs syntactic coordinate transformations variables patterns involving uses vari ables views require fewer specifications operate semantic typebased algebraic levels rather syntactic level patterns use handled automatically algebraic optimization compiler berlin weise 2 used partial evaluation improve efficiency scientific pro grams using information features problem constant compiler performs many constant calculations possible compile time resulting program specialized runs faster system incorporates partial evaluation means inline compilation symbolic optimization 66 views goguen describes library interconnection language called lil 12 implemented language obj3 13 14 incorporates parameterized programming views view obj3 mapping theory module consistently maps sorts types sorts operations operations obj3 based formal logical theory using ordersorted algebra operates theorem prover computation performed term rewriting authors state 14 p 56 obj3 compiler rather closer interpreter associa tivecommutative rewrite engine efficient enough large problems tracz 49 describes lileanna implements lil construction ada packages views lileanna map types operations exceptions theories system creates views correspondences application types mathematical objects possible correspondences general onetoone correspondences specified obj3 views system produces efficient specialized procedures ordinary programming languages intended used program generation system garlan 10 kaiser 22 use views allow multiple tools program development environment access common set data program developed meld system combine features collections object classes methods allow additive construction system selected component features hailpern ossher 18 describe views oop subsets methods defined class use views restrict use certain methods example debugger could use methods unavailable ordinary programs system used development environment 19 67 data translation idl interface description language 25 allows exchange large structured data possibly including structure sharing separately written components large software system compiler idl performs representation translation different representations data used different components use idl requires user write precise specifications source target data structures herlihy liskov 20 describe method transmission structured data net work possibly different data representation destination method employs userwritten procedures encode decode data transmissible representations also describe method transmission shared structures 5 describes system automatically generates stub programs interconnect processing modules different languages processors work complementary techniques presented paper common object request broker architecture corba 6 includes interface definition language automatically generate stubs allow interoperability objects across distributed systems across languages machine architectures purtilo atlee 40 describe system translates calling sequences producing small interface modules reorder translate parameters necessary called procedure cases emphasis relatively direct translation data focusing issues record structure number representation etc techniques described paper could used extend approaches cases ontology method description objects differs specialization generic algorithms efficient interpretive conversion data 68 objectoriented programming oop popular mechanism software reuse gamma et al 9 describe design patterns useful oop described views could used construct wrapper objects make application objects appear members desired class use views glisp compiler extends good ideas oop 1 oop makes connection message corresponding procedure runtime often significant cost 9 c 48 relatively efficient message dispatching cost flexibility glisp 31 specialize method inline optimize resulting code context overhead interpretation eliminated often extra cost 2 interpretation messages oop postpones error checking runtime views glisp type inference inline expansion cause checking done statically 3 views provide clean separation application data abstract type oop systems require conformance instance superclass eg instance may contain data variables views multiple views type eg pipe viewed circle two distinct ways views allow partial use abstract type eg area circle found without specifying center 4 oop user must learn available classes messages oop operating systems involve 1500 classes nontrivial views user understand abstract type indicate correspondences application type abstract type user interface selfdocumenting 5 system allows translation separate application language c without requiring application written particular language 7 discussion conclusions believe generation application code compilation views efficient practical technique expansion code views recursive compile time composition views possible generic algorithms often written terms generics examples presented paper small ones clarity approach scale larger algorithms produced specialized versions algorithms comprise 200 lines code c eg finding convex hull set points uses leftofdistance generic function defined linesegment finding perimeter area center mass polygon etc compilation translation c 200line program takes approximately 10 seconds workstation much faster human coding output code efficient often better code produced human programmers efficiency generated code consider specialized compilation generic procedures best way achieve reuse using views approach several significant advantages 1 user interface selfdocumenting allows views created quickly easily 2 specialized versions generic algorithms application created seconds 3 specialized algorithms produced standard programming language independent system 4 code produced optimized efficient 5 static error checking performed compile time related techniques used create programs connecting diagrammatic representations physical mathematical laws 36 sizes various components system noncomment lines lisp source code shown following table component lines make views mkv 265 symbolic algebra 1003 graphical interface 1020 glisp compiler 9097 translation c 831 total 12216 symbolic algebra component includes algorithms used mkv described paper amount code required making views large translation specialized code languages c difficult c translation component large much could reused languages translation uses patterns easily changed acknowledgments computer equipment used research furnished hewlett packard ibm thank anonymous reviewers helpful suggestions improving paper r ieee trans compiling scientific code using partial eval uation crc standard mathematical tables formulae software reusability 2 vols packaging system heterogeneous execution environments common object request broker architecture specification discipline programming program transformations design patterns elements reusable objectoriented software views tools integrated environments reusing interconnecting software components principles parameterized programming introducing obj denotational description programming languages new notion encapsulation transform new language construct extending objects support multiple interfaces access control integrating tool fragments value transmission method abstract data types data abstraction program development using modula2 synthesizing programming environments reusable features scientific programming automated synthesis software reuse idl sharing intermediate representations diagram sometimes worth 10000 words modula2 software component library automating software design reusing software issues research directions enabling technology knowledge sharing glisp lispbased programming system data abstraction negotiated interfaces software reuse software reuse view type clusters software reuse compilation view type clusters generating programs connections physical models conversion units measurement ml working programmer introduction discrete structures module reuse interface adaptation readings artificial intelligence software engineering programmers apprentice mathematical theory global program optimization models thought kids semiautomatic program development system knowledgebased software development system language lileanna parameterized programming language overview miranda templates approach software reuse reusable software components mathematica system mathematics computer advances computers tr ctr jeffrey parsons chad saunders cognitive heuristics software engineering applying extending anchoring adjustment artifact reuse ieee transactions software engineering v30 n12 p873888 december 2004 ted j biggerstaff perspective generative reuse annals software engineering 5 p169226 1998 batory bart j geraci composition validation subjectivity genvoca generators ieee transactions software engineering v23 n2 p6782 february 1997 gordon novak jr software reuse specialization generic procedures views ieee transactions software engineering v23 n7 p401417 july 1997
classistype inadequate object reuse well known class type two different concepts objectoriented programming languages oopls however many popular oopls classes used types paper argue classistype principle major obstacle software reuse especially object reuse concepts basic entities ie objects object classes object types object kinds type hierarchy oopls revisited notion object reuse defined elaborated addition show parameterized types generic functions better served used kindbounded quantification universal quantification mechanisms b introduction objectoriented languages technology propelled software reuse unprecedented level however software reuse current stage still mostly 1 within single software project 2 form sourcecode reuse libraries dream software construction would similar assembling integrated circuits ics hardware still realized programming many essential aspects twenty years ago software construction still basically stage program writing advanced stage software integration si consider object reuse rather class reuse key concept software integration objects basic building blocks objectoriented system firstclass citizens programming via software integration means reuse integrate objects developed independently work supported natural sciences engineering research council canada grant ogp0041630 projects object vendors executable form program conveniently without knowing implementation details consider object reuse much important concept class reuse software integration consider example physical world purchase airconditioner house need want know design technical details airconditioner necessary us know whether airconditioner satisfies specifications eg cooling capacity physical dimensions voltage case object airconditioner type specifications concern interest need even want know class object technical details airconditioner consider one major cause stagnation reuse major classbased objectoriented programming languages object classes directly used object types example specify object type function parameter use class place type approach may due fact semantics object type easy define specific implementation important notice classes implementationdependent entities general also objects cannot exist autonomously apart class definitions current classbased languages contrast object types implementationindependent entities classistype principle used many objectoriented languages restricts object type specific implementation argue paper classistype principle classes obstacle object reuse another issue concerns type hierachy objectoriented languages parameterized types note c class template parameterized type classistype principle consider parameterized type type function maps given type types type domain type function ie domain type parameters commonly represented n set types however many cases types used replace type parameter parameterized type restrictions implicitly imposed parameterized type definition consider object kinds higherlevel entities object types 31 32 26 25 34 best suited defining domains type parameters parameterized types well generic functions objects object classes object types object kinds basic entities type hierarchies various objectoriented languages 31 next section review basic concepts entities well relationships among also discuss similarities differences abstract classes interfaces object types focus attention classistype principle giving initial analysis advantages well potential problems also distinguish object kinds supertypes object reuse defined analyzed section 3 consider object reuse concerns mainly following five issues 1 object creation 2 object autonomy 3 object application 4 object integration 5 object modification describe five issues well role object reuse section 4 discuss roles classes classistype principle play five issues object reuse find classes apt object creation object autonomy classistype principle inadequate object application object integration object modification ie last three issues object reuse also give insight analysis case section 5 argue parameterized types generic functions best served kindbounded qualification ie type parameter qualified higherlevel entity object kind conclude paper section 6 summarizing suggestions development objectoriented languages type hierarchy objectoriented systems section give view basic type entities objectoriented systems consider objects object classes object types well concept object kinds brief commonly accepted concepts pay attention points related topics subsequent sections paper note object classes object types different entities however approach object classes used place object types ie classistype principle used many objectoriented languages including c java also describe concept object kind fundamental differences supertypes object kinds three seemingly equivalent terms abstract class interface object type also compared 21 objects object integrated unit data methods abstraction application domain implementation domain entity crisp boundaries meaning problem concerned object identity data fields method fields data fields store internal state object act data storage method fields functions modify internal state object access data storage interface object outside world internal state object modified dynamically execution normally change made methods methods may accessed outside object may used methods object call methods directly accessed outside properties object clearly objects firstclass entities objectoriented systems 22 object classes serve descriptions objects well mechanism create objects objects instances classes classbased languages way describe object class class also considered set objects share description thus relation object class c denoted 2 c general object classes implementationdependent entities example stack class array implementation stack class linkedlist implementation considered different classes different objects class implementation different identities maybe different internal states abstract class may independent implementation however abstract class cannot description object directly object instantiated directly concrete class abstract class abstract class set direct object members object classes static entities unlike objects classes cannot changed runtime defined relationship classes static modify relationship objects classes runtime call property class method class accessed directly outside objects class direct members share exactly set methods thus exactly properties 23 object types intuitively speaking object type description collection properties without giving implemen tation thus object type also considered set objects properties possibly different implementations clearly object types implementation independent entities objects class also object type however objects object type may belong class example two integerstack classes 1 2 implemented linked list array respectively set operations pushint pop top empty 1 2 two different classes type say case also say implementation stack object type considered member set denoted fact 1 object type may defined many ways example object type define listing properties names signatures methods 18 extracting type class using operator 1 implicitly deleting implementation details class type needed similar classes subtypes defined terms supertypes say object type possesses properties note type spite creation may independent definition cases object actually possesses properties object type use different names properties example two properties void inserttop content content deletetop defined type content pop void push content know insert top property push delete top corresponds pop would convenient language construct like following object isof type inserttop push deletetop pop allows programmer claim object type specify correspondence properties type checking type equivalence usually quite complex construct would helpful reducing work compiler formally binary operator links object object type operator inside construct propterty matching operator links property object property object type simple interpretaion construct require two properties side operator exactly signature although may different names interpretaion general good enough practical purposes flexible complex interpretaion require object type property lefthand side may function type subtype property righthand side interpretation would involve contravariance covariance rules relationship classes object types interesting one collections sets objects object types implementation independent entities classes say object type defines set objects external behaviors however precise meaning behaviors would become extremely complicated define behaviors restricted specific implementation may use eg axiomatic denotational logical way specify behaviors object type methods complex practical moment easiest way precisely define semantics properties type perhaps give specific implementation operations words easy safe define object type object class comes see many popular objectoriented languages classistype principle using object classes object types main advantage using classistype principle object types defined way rigorous unambiguous precise easy define although necessarily easy comprehend main disadvantage object type restricted one particular implementation thus becomes implementation dependent argue later major obstacle object reuse software integration objectoriented languages eg theta 18 object types separate entities classes theta new object type simply new type defined names signatures methods properties semantics methods properties formally defined left programmer interpret names possibly informal definitions comments example stack type operations push pop top etc well understood simply names graph type easily understood lines explanations comments informal approach dangerous without care however perhaps practical way defining object type program without restricted specific implementation way works well physical world abstract classes available many major objectoriented languages abstract classes play role object types certain extent however abstract classes object types main differences abstract class object type following 1 abstract classes may may implementation independent object types implementation independent exception consistency aspect abstract classes 2 object abstract class c say 2 c exists concrete class c 0 descendant c instance c 0 words exist declaration link family relation c declare c 1 subclass subclass c n instance c 0 contrast fact type simply implied fact properties relationship direct necessarily exist family relation interfaces java onestep closer object types abstract classes interfaces implementationindependent entities thus 1 apply 2 still 24 object kinds object types share certain set common properties form object kind specified properties hence object kinds higherlevel object types members object kind object types object kinds introduced studied 31 32 26 25 34 name kind also appeared 16 21 8 9 10 however connotations word show later section 5 object kinds useful defining parameterized types generic functions relation object kind members ie object types cannot represented supertype relation consider two object types word character string acyclic graph word implemented array linked list acyclic graph adjacency matrix adjacency list etc name type w type g respectively two different types common property distance two words respectively two acyclic graphs measured ie two object types distance function naturally represent set types set common properties higherlevel entity case define object kind k set types distance function clearly w g types k important notice k supertype w g k cannot replaced supertype w g case assume define supertype instead kind k distance function measures distance pair objects type would imply distance function word acyclic graph subtyping principle clearly intend define 3 object reuse section consider issues concern object reuse classify objects following two categories internal objects external objects program call objects created within program internal objects created elsewhere used program external objects since reuse internal objects relatively straightforward involved fewer issues external objects discussion focused reuse external objects sources external objects may include projects object vendors object reuse different class reuse source code reuse object reuse mean reuse objects already created executable form especially developed independently larger programming environment object reuse may involve following five interrelated issues 1 object creation object created 2 object autonomy whether object survive autonomously 3 object application object used object integration two objects integrated larger objects object modification whether individual object modified side effects object created first application object created many ways classbased languages like c 28 java 3 eiffle 22 modula3 23 objects instantiated classes objectbased languages eg cecil 11 self 30 omega 6 objects created cloning extension prototypical objects without existence classes apparently object created necessarily affect object used internally externally consider object creation essential issue object reuse order object used internally also externally terms environment created essential object able survive autonomously means object executable without class objects creation environment many issues may involve object autonomy include embedding versus delegation global variables class variables visibility attributes however feel difficult objectoriented languages modified safely export objects live autonomously reused safely runtime environments example objects going exported specially marked exporting objects compiler check whether satisfy certain conditions autonomy eg global variables generate autonomous objects using embedding instead delegation etc object application definition clearly important issue object reuse conditions necessary external object used linked programming environment let us consider airconditioner example purchase airconditioner house necessary us know whether airconditioner satisfies specifications eg cooling capacity physical dimensions voltage however need want know design technical details airconditioner also airconditioner satisfies requirements whatever internal implementation would job internal implementation part requirement case need object object type whether object type conforms required object type need want know object class thus object type system separate class system need set object reuse type system example object type may explicitly declared obtained using operator given class c removes implementation details c returns object type object types may inheritance hierarchies importantly system able check given object given object type whether object give object type external object used programming environment may act server providing oneway services may also call methods send messages internal objects words object may interact internal objects also consider situation use two external objects programming environment objects may require interact strong typed objectoriented system assumed object involved multiobject interaction needs know type information objects however may situation external objects developed independently different vendors thus general developer object know types objects defined many different ways solve problem example solutions 1 standardization object types object interfaces 2 writing wrapper adapter programs order independently developed objects interact 3 using construct suggested section 2 match equivalent types different appearances solution 1 may longterm solution however even long term difficult standardize types reusable objects mechanisms place wrapper adapter programs complicated programmer know type declarations object involved class declarations current classistype principle would much convenient use construct together standardization would also convenient objects modified creation several objectbased languages data fields methods object modified uniform way without sideeffect object modification object autonomy two closely related issues however consider issue convenience issue notion object reuse appears similar componentbased computing 29 many ways component object object reuse independently developed executable form consider component object collection closely related objects term however componentbased computing mechanisms general part objectoriented language impose external structure programs written current programming languages rather change idl consider standard way specify object types sense componentbased computing mechanisms meant alleviate problems current objectoriented languages object reuse outside rather inside 4 classistype inadequate object reuse play two major roles classbased languages 1 object description creation mechanism 2 object types object creation mechanism classes serve first two issues object reuse well minor modifications current popular classbased languages used develop autonomous objects objects also created many ways objectbased 1 prototypebased languages 27 24 13 eg direct declaration cloning extension prototypical objects consider classes object creation mechanism adequate mechanism whether creating single object stock objects consider classistype principle ie classes plying role object types relation object reuse let us assume going use registrar object external source program program instantiate many student objects student class type program method registration student s1 registers calls registration method uses external object registrar registration s1register registrar implies following definition method registration student class boolean register registrar registrar class well object type registrar class registrar declared program since classistype principle used following problems ffl class registrar possibly descendants describes implementation details object registrar complicated large reuse instead developing since include class registrar descendants program would economical instantiate registrar object program rather use external object registrar object reuse degenerates class reuse source code reuse ffl registrar student s1 external objects created independently register method s1 object may defined since student object class definition registrar created also registrar object know class definition s1 objects seriously restricts way registrar s1 objects defined makes integration objects extremely complex ffl neither registrar object s1 object modified additional features efficient implementations created example observe following three general problems classis type principle object reuse 1 classes implementation dependent entities classistype principle unnecessarily restricts object type specific implementation compatible general idea reuse 2 classistype principle object used object type class specified instance instance descendant class words declaration link family relation since external objects developed programmed independently necessary link makes reuse external objects complicated difficult 3 classes detailed description objects information type object quired classistype principle makes object type information cumbersome even sometime redundant object classistype principle makes realization object application object integration object modification difficult even impossible cases 5 parameterized types generic functions parameterized type function maps type several types another type let denote set types parameterized type p function example c sorted vector template declaration 28 following templateclass class sortedvector v int sz size vector int n current number elements public explicit vector int operatorint n zs return false int return true bool delete int delete ith element type parameter template template maps int type integer sorted vector type maps char type character sorted vector type etc appears given type template would map sorted vector type however totally true notice comparison vi two objects type function insert implies cannot type types operator domain type function template set types subset call subset kind k sorted vector template type function k general parameterized type function k 1 kinds kind k may defined follows kind k k bool operator template may written follows templatek class sortedvector k denotes type bound kind k similarly generic function function maps type function thus kinds used define domain type functions call type polymorphism kindbounded polymorphism note discussed section 2 kinds cannot replaced supertypes kind supertype clearly two different concepts consider situation type comparison operator essentially uses different name say less language construct like following explicitly link corresponding names may introduced type isin kind k lessthan operator using kindbounded polymorphism least following advantages 1 restrictions type variables implicitly imposed definition parameterized type generic function explicitly clearly stated definition kind user parameterized type generic function need read detailed definition parameterized type generic function find buried constraints 2 kinds higher level types kind affiliate specific parameterized type generic function kinds natural entities represent constraints types make generic constructs conceptually transparent notions similar kinds studied 16 21 20 8 9 10 clause parameterized procedures parameterized types clu 19 theta 18 well statement generic procedures ada 2 similar definition kinds however unlike kinds clause statement independent entities inseparable part specific parameterized type etc contrast kinds treated uniformly entities type hierarchy several parameterized types genric functions restrictions type parameters expressed kind comparisons kind opaque types modula3 signatures g 5 kinds quest 10 etc found 31 concept object kinds shown useful realizing algorithmic abstraction 31 programming languages conjecture object kinds also useful formal semiformal descriptions design patterns well implementation objectoriented languages 6 conclusion past half century programming languages continuously evolving higher levels exist two opposite directions development programming languages getting complicated conceptually easier easier technically takes much longer time learn programming language forty years ago programming task takes much less time paper made several suggestions development objectoriented programming lan guages summarized following 1 separation object types object classes 2 exporting autonomous objects type information 3 introducing typematching construct like construct section 2 matches type given object given object type 4 introducing object kinds kindbounded polymorphism construct fitting object type object kind object type system separated classes would much complicated implement however system would make objectoriented language much flexible feasible object reuse software integration r theory objects ada 9x mappingrevision team java programming language programming ada typesafe oop prototypes concept omega algebraic specification techniques object oriented programming environments modest model records inheritance bounded quantification semantics secondorder lambda calculus formal description programming concepts ifip stateofart report cecil language specification rationale fbounded polymorphism objectoriented programming interpretation objectoriented programming languages data types values principles obj2 interpretation fonctionelle et elimination des coupures de larithmetique dordre superieur algebraic specification abstract data types theta reference manual preliminary version abstraction specification program development semantic model types applicative languages investigation programming language polymorphic type structure eiffle language systems programming modula3 introducing kinds c shared view sharing treaty orlando component software beyond objectoriented programming self power simplicity algorithmic abstraction objectoriented languages software reuse via algorithm abstraction parametric polymorphism objectoriented languages algorithm abstraction via polymorphism objectoriented languages tr data types values abstraction specification program development shared view sharing treaty orlando semantics secondorder lambda calculus modest model records inheritance unbounded quantification inheritance subtyping fbounded polymorphism objectoriented programming systems programming modula3 eiffel language component software principles obj2 c programming language integration objectoriented programming languages programming ada theory objects semantic model types applicative languages investigation programming language polymorphic type structure algorithmic abstraction via polymorphism objectoriented programming languages ctr chitra babu janakiram method driven model unified model object composition language acm sigplan notices v39 n8 august 2004
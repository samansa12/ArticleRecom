subexponential bound linear programming present simple randomized algorithm solves linear programs n constraints variables expected onded lnn114 time unit cost model count number arithmetic operations numbers input expectation internal randomizations performed algorithm holds input algorithm presented abstract framework facilitates application several related problems algorithm presented previous work authors shw analysis subexponential complexity bound new b introduction linear programming one basic problems combinatorial optimization received considerable attention last four decades many algorithms proposed solution starting simplex algorithm relatives dan proceeding polynomialtime solutions khachiyan kha karmarkar kar continuing several recent techniques reviewed proposed algorithms proven extremely efficient practice analysis running time fully satisfactory far example simplex algorithm shown exponential worst case klm algorithms khachiyan karmarkar polynomial bitcomplexity number arithmetic operations perform depends size coefficients defining input cannot bounded solely terms n number constraints number vari ables paper assume different model computation namely real ram widely used computational geometry input may contain arbitrary real num bers arithmetic operation real numbers charged unit cost distinguish complexity bounds model bounds bitcomplexity model call combinatorial recently best known combinatorial bounds exponential either n subexponential randomized bound given recent paper kalai kal also paper one major open problems area find strongly polynomial algorithm ie combinatorial polynomial complexity linear programming paper describe simple randomized algorithm solves linear programs n inequalities variables expected lnn dln n g arithmetic operations conjunction clarksons linear programming algorithm cla3 gives expected bound od expectation running time respect internal randomizations performed algorithm holds input complexity matches recent algorithm due kalai kal except constant exponent significant difference kalai version algorithm runs e long n linear guarantee bound chronologically speaking algorithm published first shw weaker analysis running time kalais analysis subexponential bound came next immediately afterwards realized algorithm also subexponential running time algorithm presented abstract framework facilitates application algorithm large class problems including computation smallest enclosing balls ellipsoids finite point sets dspace computing largest balls ellipsoids convex polytopes dspace computing distance polytopes dspace etc however guarantee subexponential running time problems see details compare complexity algorithm recent techniques brief survey relevant recent literature megiddo meg2 given first deterministic algorithm whose running time form oc n thus linear n fixed however factor c algorithm 2 2 improvement c found dye1 cla1 recently number randomized algorithms presented problem see dyf cla3 sei better dependence best expected running time given clarkson cla3 od log n nevertheless dependence still exponential recent algorithm seidel sei worse expected complexity odn extremely simple randomized incremental algorithm wel algorithm enhanced movetofront heuristic practice drastically improved performance algorithm still difficult analyze algorithm another variant inbetween techniques sei wel interesting examples linear programs constraints adding movetofront heuristic new algorithm gives significantly worse performance mat1 algorithm also seems behave well practice analysis given also provides considerably improved worstcase upper bound expected complexity recently derandomization techniques applied clarksons algorithm obtain deterministic oc n time lp algorithms c order 2 od log chm abstract framework present considers set h n constraints function w maps every subset h optimal solution w satisfies simple conditions turns needed prove correctness algorithm analyze expected running time terms two primitive operations violation tests basis computations turns primitive operations easily implemented polynomial time linear programming means clear instances problems framework example case computing smallest enclosing ball basis computation amounts computing smallest ball enclosing points dspace recently gartner gar2 able show done expected e arithmetic operations clarksons algorithm cla3 also shown work framework algorithm seidel sei generalization applications wel needs make explicit use geometry problems different framework recently developed dyer dye2 yields deterministic algorithms linear n larger constants paper organized follows next section introduce notations review basic observations linear programming required presentation analysis algorithm section 3 analysis culminates recurrence relationship whose solution nontrivial interesting task section 4 devoted solution finally section 5 describe abstract framework mention examples notation basics following prepare notation required presentation model case linear programming objective function defined vertical vector problem maximize c delta x intersection given n halfspaces let lexicographical ordering r ie x 1 x 2 ordering extended r f1 gamma1g 1 gamma1 special symbols convention let h set closed halfspaces dspace call also constraints dspace v h denote lexicographically smallest point feasible region fh v h called value h seems standard look backwards lexicographically smallest point ie case reader accustomed may prefer think backwards instead fh empty let v fh nonempty contains minimum let v intuitively view 1 point lies halfspaces dominates points gamma1 may seen point minus infinity simply symbol undefined basis b set constraints b basis h minimal subset b h constraint h violated h equivalent constraint h extreme h v h gammafhg v h note h extreme h h 2 h h violated h gamma fhg following properties either trivial like ii standard linear programming theory like iii cite explicitly constitute needed correctness time analysis algorithms described h sets constraints dspace g h let h constraint dspace violated g h violated h iii v h 1 basis b h exactly constraints f h extreme constraints 3 algorithm let h set constraints x given set h constraints following algorithm compute basis h h basis always exists algorithm works initial basis b 0 instead particular could take basis b 0 h available take set constraints symbolic value gamma representing arbitrarily small always assume v hh 1 constraint sets consider wellknown condition obtained cost extra dimension extra constraint however note made general position assumptions eg require bases unique given set h n constraints might first consider following trivial approach remove random constraint h compute basis b h gamma fhg recursively h violated b equivalently h violated h gamma fhg b basis h done h violated try removing hopefully different random constraint note probability h violated h gamma fhg since extreme constraints h much basic idea already find seidels lp algorithm sei however order guarantee efficiency need additional ingredients first procedure subex lp actually solving problem two parameters set h constraints basis c h general c basis h call candidate basis viewed auxiliary information get computation solution note c influence output procedure influences efficiency problem computing basis h h solved function procedure subex lph h set n constraints dspace returns basis h h return following pseudocode subex lp uses two primitive operations first test h violated b constraint h basis b violation test operation implemented time od keep v b basis b second subex lp assumes availability operation basisb h computes basis b fhg delement basis b constraint h basis computation step corresponds pivot step appropriate representation b performed od 2 operations note constraint sets h considered execution function procedure subex lph c h set n constraints dspace return c returns basis h else choose random h h violated b v b 62 h return subex lph basisb h else return simple inductive argument shows procedure returns required answer happens finite number steps since first recursive call decreases number constraints second call increases value candidate basis finitely many different bases analysis expected behavior algorithm let us take closer look probability algorithm makes second recursive call candidate basis basisb h noted happens exactly h extreme h since choose h h gamma c c always elements follows probability extreme ngammad moreover gamma k extreme constraints h already c bound improves k ngammad fact never bad choices choices bound lowered minfngammadkg ngammad want show numerator decreases rapidly go recursion entail subexponential time bound key notion analysis hidden dimension given g h basis c g hidden dimension pair g c measures close c solution basis g hidden dimension g c minus number constraints h 2 c must contained basis b g value greater equal value c lemma 2 hidden dimension g c gamma jfh 2 g v ggammafhg proof need show constraint h 2 g satisfies v ggammafhg appears g basis h b b conversely basis g gamma fhg h b completes proof lemma let us remark hidden dimension g c depends c via value c intuitive interpretation local optima defined constraints g lying level v c contained kflat defined gamma k bounding hyperplanes constraints c k hidden dimension hidden dimension zero implies c basis g enumerate constraints h way ng ordering unique parameter k emerging ordering unique definition equals hidden dimension h c note h c hence choices h possibly entail second call h chosen first call candidate basis c returns basis b compute hidden dimension pair h c 0 second call k gamma hidden dimension monotone ie c g h hidden dimension g c exceed hidden dimension h c holds constraints c g v ggammafh g v h gammafh g g h denote k n b k n maximum expected number violation tests basis computations respectively entailed call subex lph c n constraints hidden dimension k discussion yields following recurrence relationships simple proofs induction show b k n 2 k n gamma k n 2 k n gamma turns n much larger gross overestimate next section show lnn also every constraint tested violation b basis b ever appearing computation tha since test elements b violation b add 1 k n account initial basis h recall account od arithmetic operations violation test od 2 arithmetic operations basis computation note also computation v hh add nonnegativity constraints initiate subex lp anticipating solution recurrences given next section thus conclude theorem 3 let h set n constraints dspace lexicographically smallest nonnegative point v hh intersection halfspaces h computed randomized algorithm expected number ond lnn dln n operations clarkson cla3 shows linear program n constraints dspace solved expected od stands complexity solving linear program 9d 2 constraints dspace replace 9d 2 bound observe replacement middle term 32 always dominated two terms moreover even omit log n factor last term 33 without changing asymptotics whole expression thus obtain corollary 4 lexicographically smallest nonnegative point v hh intersection n halfspaces h dspace computed randomized algorithm expected number od log 33 operations 4 solving recurrence section prove promised bounds b k n first put b k let fk n function satisfies recurrence b k n equality thus majorizing b k n thus fk n solution recurrence prove following upper bound lemma 5 n k fk n holds n e k4 k ip large range values n k bound essentially tight least leading term order avoid various technicalities lower bound proof restrict range n try get tight bound could concerning order magnitude lower order terms show lemma 6 k tending infinity n k n 2 ok emphasize lower bound fk n b k n lower bound b k n conceivable b k n much smaller see mat1 recent related lower bounds upper bound proof lemma 5 apply technique generating functions easy inductive proof 12 k nbound mentioned previous section omitted define n 0 multiply recurrence 41 z k sum k obtain g g z jx g words recurrence follows regarding z complex variable want find value coefficient fk n z k taylor expansion g n z well known equal fk n 2i z z k1 dz integral closed curve fl contains origin contain pole g n z choose fl circle 1 easily checked none denominators product defining g n z vanish follows inequality also implies yields bound integer parameter determined later let us set estimate terms product q 2 distinguish two cases first j q use estimate using stirlings formula q absolute values terms alternating sum parentheses form decreasing sequence hence stop summation term error sign first omitted term j q finally estimate get values n k set yields bound ip two extreme cases definition q gives q 2 happens n exponentially large compared k n e k4 k use easy bound comes close k smaller set obtain bound e playing estimates somewhat one get better bounds 42 n k case observe n q product 43 goes n one gets c n instead c q better choice q possible n large n e k4 k establishes lemma 5 lower bound proof lower bound based following explicit form fk n lemma 7 first sum qtuples second sum qtuples q also 0 contributes one term equal 1 sum formally interpret term corresponding unique 0tuple term empty product equal 1 proof initial conditions term sum yielding value 1 similarly get nonzero term gives 1 consider difference fk n gamma fk n defined 45 terms appear 45 k n k precisely sum terms mq1n n function defined 45 thus satisfies initial conditions recurrence relation proof lemma 6 let us first define several auxiliary parameters let function tending 0 slowly enough instance log log k set q since assume k large may neglect effect truncating q integers similarly integer parameters sequel assumption log guarantees consider inner sum 45 given qtuple k sum least one easily verifies induction say 1 use stirlings formula get estimate estimate expression wellknown easy prove number nr k rtuples r let n r k denote number rtuples additional condition claim q see suffices encode every rtuple contributing qtuple contributing n q k encoding performed follows leave element otherwise replace bm equal one element equal j 1gammamgamma1bm tuple 1 5 2 8 transformed 1 3 3 2 2 3 3 3 3 1 note replaced block elements sum number elements resulting vector q may pad vector ones get exactly q elements easy see encoding reversible observed sum elements resulting vector exceed sum initial rtuple q proves 47 value may choose use 47 show number qtuples k least combining 46 observing lnnm k obtain proves lemma 6 5 abstract framework let us consider optimization problems specified pairs h w h finite set function values linearly ordered set w assume w minimum value gamma1 elements h called constraints called value g goal compute minimal subset bh h value h general value h easy determine assuming availability two basic operations specified turns algorithm section 3 used perform computational task long following axioms axiom 1 monotonicity f g f g h axiom 2 locality f g h implies also wf axioms 1 2 hold call h w lptype problem obviously linear programming lptype problem set constraint set g h axioms coincide lemma 1 ii notions needed section 3 carry obvious way basis b set constraints proper subsets b 0 b g h basis g minimal subset b g constraint h violated g wg constraint h extreme g wg gamma fhg wg efficiency algorithm following parameter crucial maximum cardinality basis called combinatorial dimension h w denoted dimh w assume following primitive operations available violation test h violated b constraint h basis b tests whether h violated b basis computation basisb h constraint h basis b computes basis b fhg note checking whether h violates b equivalent checking whether wbasisb h wb shows two primitive operations closely related ingredients necessary apply algorithm lptype problem provided initial basis b 0 first call subex lp also show using simpler inductive argument mentioned section 3 expected number primitive operations performed algorithm o2 ffi n combinatorial dimension however order ensure subexponential time bound need extra condition axiom 3 basis regularity b basis h constraint every basis b fhg exactly dimh w elements axioms 13 satisfied call h w basisregular lptype problem seen linear programming dspace basisregular lptype problem combinatorial dimension provided program feasible lemma 1 iii provides stronger property every basis cardinality actually whole treatment section 3 careful use properties linear programming except formulated lemma 1 would glad use properties obtain faster algorithm know course extra computational assumption order start algorithm initial basis initial basis b 0 exactly dimh w elements available case linear programming nonnegativityconstraints h play role initial basis may conclude theorem 8 given basisregular lptype problem h w jh dimension ffi initial basis b algorithm subex lp computes basis h expected number ffiln n violation tests basis computations turns clarksons algorithm also formulated analysed within framework basic cases involving offi 2 constraints solved algorithm expected number required violation tests offin log ffi expected number required basis computations e log ffi log n many problems shown satisfy axioms 1 2 see list problems except linear programming basisregularity naturally satisfied however artificially enforce axiom 3 following trick due bernd gartner gar1 let h w lptype problem combinatorial dimension ffi value set w define pair h w 0 g h new value set fgamma1g ordering straightforward proof following lemma omitted lemma 9 given lptype problem h w pair h w 0 defined basis regular lptype problem combinatorial dimension dimh w basis b complemented arbitrary dimh w gamma jbj elements serve initial basis hence transform every lptype problem basisregular one although careful new interpretation violation tests basis computations thus obtain algorithm expected subexponential number violation tests basis computations primitive operations might quite expensive exhibit two examples lptype problems successfully apply algorithm including efficient implementation primitive operations smallest enclosing ball problem computing disk smallest radius containing given set n points plane goes back j j sylvester 1857 syl first linear time solution problem provided megiddo meg1 see reference short guide previous 3 log n solutions general problem computing smallest ball enclosing set n points dspace solved linear time long dimension considered fixed see meg1 meg2 deterministic algorithm wel simple randomized algorithm however algorithms exponential given set p n points dspace define rq smallest radius closed ball containing q p wellknown smallest radius exists ball realizing radius unique moreover always subset b q containing eg jun basic facts hand easy show p r lptype problem combinatorial dimension clearly adding points constraints set cannot decrease radius smallest enclosing ball monotonicity holds p violated q p p lies outside unique smallest ball containing q easily implies locality problem basisregular apply transformation validate analysis violation test easy point balltest basis computation amounts nontrivial task basically compute smallest ball enclosing 2 points dspace recently gartner gar2 able show problem solved expected e arithmetic operations hence obtain corollary 10 smallest enclosing ball n points dspace computed expected number n e 2 lnn operations combining clarksons algorithm complexity reduces bound 33 linear programming distance polytopes given two closed polytopes p 1 p 2 want compute distance ie dista b denoting euclidean distance points b polytopes tersect distance 0 intersect distance equals maximum distance two parallel hyperplanes separating polytopes hyperplanes unique orthogonal segment connecting two points 2 p 1 b 2 p 2 easy exercise prove always sets b 1 b 2 vertices p 1 p 2 respectively denotes convex hull distance positive bound formulate problem lptype problem follows let vertex set p assume every subset u v unique representation 2 convention define empty define 1 pair v w constitutes lptype problem except inequalities go way round u w v implies wu ww 1 plays role gamma1 order see locality observe p violated u lies unique pair parallel hyperplanes separate u 1 u 2 distance wu also shows perform violation test mentioned combinatorial dimension problem d2 1 polytopes intersect hence basis computation compute distance two polytopes space altogether d3 vertices invoke gar2 ensure performed expected e arithmetic operations corollary 11 distance two convex polytopes dspace altogether n vertices computed expected number n e 2 lnn operations best previously published result expected bd2c randomized algorithm considered fixed cla2 result corollary 11 also established polytopes given intersections n halfspaces combining result clarksons yields bound 33 examples quite number examples fit frame work thus solved time linear number constraints dimension considered fixed mentioned subexponential bound delicate issue depends efficiently solve small problems provide list examples without giving details smallest enclosing ellipsoid given n points dspace compute ellipsoid smallest volume containing points combinatorial dimension dd see dll juh wel problem treated number recent papers pos wel dye2 chm constraints points value set points volume smallest enclosing ellipsoid affine hull ellipsoid also called lownerjohn ellipsoid known unique dll locality easily follows monotonicity obviously satisfied primitive operations treated applying general methods solving systems polynomial inequalities cannot claim subexponential time bounds course bound linear number points holds largest ellipsoid polytope given polytope dspace intersection n halfspaces compute ellipsoid largest volume contained polytope combinatorial dimension dd smallest intersecting ball given n closed convex objects dspace compute ball smallest radius intersects combinatorial dimension order see combinatorial dimension make following observation consider minkowski sum convex object closed ball radius r centered origin ball radius r intersecting objects intersection minkowski sums nonempty hellys theorem intersection nonempty intersection 1 nonempty r smallest radius makes intersection nonempty interiors minkowski sums common point set b 0 d1 common point corresponding set objects contains basis cardinality 1 claimed combinatorial dimension follows easily angleoptimal placement point polygon let p starshaped polygon n vertices plane polygon starshaped point inside polygon sees edges vertices locus points called kernel want compute point p kernel p connecting p vertices p straight edges minimal angle two adjacent edges maximized combinatorial dimension 3 unlike previous examples might obvious constraints problem let us assume polygon allows placement p angles occurring least ff restricts locus p intersection following convex regions every vertex v polygon incident edges e 0 e inner respect p angle fi wedge angle fi gamma 2ff apex v p forced lie ii every edge e p incident vertices v v 0 circular arc contains points see vertices v v 0 angle ff lie inner side e point p forced lie region bounded e circular arc suggests take vertices incident edges edges incident vertices constraints purpose algorithm ignoring stem polygon thus number constraints 2n combinatorial dimension 3 reasoning using hellys theorem integer linear programming given n halfspaces vector c dspace compute point x integer coordinates intersection halfspaces maximizes c delta x combinatorial dimension 2 see doi bel sca although integer linear programming fits framework bad example sense basis computation bound unit cost model problems mention far may occur reader natural examples eg largest ball polytope given polytope dspace intersection halfspaces compute ball largest radius contained polytope smallest volume annulus given n points dspace find two concentric balls symmetric difference contains points minimal volume indeed problems lptype problems actually directly formulated linear programs 1 2 respectively variables transformation smallest volume annulusproblem found dor thus also subexponential time bounds hold recently chazelle matousek chm gave deterministic algorithm solving lp type problems time offi offi n provided additional axiom holds together additional computational assumption still extra requirements satisfied many natural lptype problems matousek mat2 investigates problem finding best solution satisfying k given constraints abstract lptype problems defined nina amenta ame1 considers following extension abstract framework suppose given family lptype problems h w parameterized real parameter underlying ordered value set w maximum element 1 representing infeasibility goal find smallest h w feasible ie w 1 ame1 provides conditions problem transformed single lptype problem gives bounds resulting combinatorial dimension related work found ame2 6 discussion presented randomized subexponential algorithm solves linear programs related problems clearly challenging open problem improve bounds provided kal find polynomial combinatorial algorithm linear programming section 4 shown bound give tight recursion 31 derived analysis even stronger mat1 gives abstract examples lptype problems combinatorial dimension 2d constraints algorithm primitive operations order show better bound algorithm linear programming use properties axioms 1 3 rote rot megiddo meg3 suggest dual onepermutation variants al gorithm interesting examples linear programs one permutation variant algorithm suggested mat1 seems behave much worse certain linear programs original algorithm fact substantiated experimental results mat1 seen contrast situation seidels linear programming algorithm wel acknowledgments authors would like thank gil kalai providing draft copy paper nina amenta boris aronov bernard chazelle ken clarkson bernd gartner nimrod megiddo gunter rote several comments useful discussions r proc 10th annual acm symposium computational geometry theorem concerning integer lattice proc 4th siamacm symposium discrete algo rithms linear programming new applications random sampling computational geometry proc 29th ieee symposium foundations computer science linear programming extensions algorithmen zur ermittlung der formab weichung mit koordinatenmegeraten multidimensional search technique application euclidean onecenter problem proc 8th annual acm symposium computational geometry randomized algorithm fixeddimensional linear pro gramming proc 33rd ieee symposium foundations computer science acm symposium theory computing new polynomialtime algorithm linear programming polynomial algorithm linear programming good simplex algorithm lower bounds subexponential optimization algorithm proc 10th annual acm symposium computational geometry time algorithms linear time programming r 3 related problems linear programming linear time dimension fixed note subexponential simplex algorithms proc 16th annual acm symposium theory computing proc national academy sciences united states america low dimensional linear programming convex hulls made easy proc 9th symposium theoretical aspects computer science question geometry situation new results new trends computer science tr new polynomialtime algorithm linear programming linear programming myampersandtimes 3supscrptdsupscrpt2 time multidimensional search technique application euclidean one centre problem smalldimensional linear programming convex hulls made easy optimal convex hull algorithm new results cuttings extended abstract subexponential randomized simplex algorithm extended abstract class convex programs applications computational geometry linear programming linear time dimension fixed combinatorial bound linear programming related problems minimum spanning ellipsoids ctr bernd grtner sven schnherr exact primitives smallest enclosing ellipses proceedings thirteenth annual symposium computational geometry p430432 june 0406 1997 nice france kong qiuming zhu incremental procedures partitioning highly intermixed multiclass datasets hyperspherical hyperellipsoidal clusters data knowledge engineering v63 n2 p457477 november 2007 michael goldwasser survey linear programming randomized subexponential time acm sigact news v26 n2 p96104 june 1995 matthew j katz franck nielsen piercing sets objects proceedings twelfth annual symposium computational geometry p113121 may 2426 1996 philadelphia pennsylvania united states nina amenta bounded boxes hausdorff distance new proof interesting hellytype theorem proceedings tenth annual symposium computational geometry p340347 june 0608 1994 stony brook new york united states nina amenta helly theorems generalized linear programming proceedings ninth annual symposium computational geometry p6372 may 1821 1993 san diego california united states bernard chazelle ji matouek lineartime deterministic algorithms optimization problems fixed dimension proceedings fourth annual acmsiam symposium discrete algorithms p281290 january 2527 1993 austin texas united states piyush kumar joseph b mitchell e alper yildirim approximate minimum enclosing balls high dimensions using coresets journal experimental algorithmics jea 8 gil kalai subexponential randomized simplex algorithm extended abstract proceedings twentyfourth annual acm symposium theory computing p475482 may 0406 1992 victoria british columbia canada kenneth l clarkson las vegas algorithms linear integer programming dimension small journal acm jacm v42 n2 p488499 march 1995 sandeep sen parallel multidimensional search using approximation algorithms applications linearprogramming related problems proceedings eighth annual acm symposium parallel algorithms architectures p251260 june 2426 1996 padua italy henrik bjrklund sergei vorobyov combinatorial strongly subexponential strategy improvement algorithm mean payoff games discrete applied mathematics v155 n2 p210229 january 2007 ji matouek geometric optimization violated constraints proceedings tenth annual symposium computational geometry p312321 june 0608 1994 stony brook new york united states henrik bjrklund sergei vorobyov combinatorial structure randomized subexponential algorithms infinite games theoretical computer science v349 n3 p347360 december 2005 michael goodrich efficient piecewiselinear function approximation using uniform metric preliminary version proceedings tenth annual symposium computational geometry p322331 june 0608 1994 stony brook new york united states michael goodrich fixeddimensional parallel linear programming via relative egrapproximations proceedings seventh annual acmsiam symposium discrete algorithms p132141 january 2830 1996 atlanta georgia united states michael saks kleitman combinatorics discrete mathematics v257 n23 p225247 28 november bernard chazelle computational geometry retrospective proceedings twentysixth annual acm symposium theory computing p7594 may 2325 1994 montreal quebec canada
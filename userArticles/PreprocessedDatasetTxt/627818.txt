objectbased semantic realtime concurrency control bounded imprecision abstractthis paper describes concurrency control technique realtime objectoriented databases supports logical consistency temporal consistency well bounded imprecision results tradeoffs concurrency control technique uses semantic locking mechanism within object userdefined conditional compatibility methods object semantics specify sacrifice precise logical consistency meet temporal consistency requirements also specify accumulation bounding resulting logical imprecision show technique certain general restrictions preserve global correctness bound imprecision proving guarantee form epsilon serializability specialized objectoriented databases b introduction realtime applications air traffic control autonomous vehicle control automated manufacturing involve large amounts environmental sensor data applications supported realtime database systems rtdbms 1 addition supporting typical logical consistency requirements rtdbms concurrency control technique must maintain temporal consistency con straints data temporal consistency constrains old data still considered valid transaction temporal consistency constrains transactions execute considered correct traditional dbms concurrency control techniques designed enforce logical consistency constraints temporal consistency constraints data values transaction execu tion instance typical serializabilitybased concurrency control technique might disrupt earliestdeadlinefirst transaction scheduling order blocking transaction tight deadline work sponsored naval undersea warfare center national science foundation favor transaction looser deadline order maintain logical consistency preserving serialization order transactions serializabilitybased techniques also problem rtdbms restrict allowed concurrency often required logical correctness 2 overrestriction impedes realtime transaction schedulers ability preserve transaction temporal consistency requiring serializability reduces likelihood creating schedule meets timing constraints 3 data temporal consistency also ignored serializabilitybased concurrency control techniques instance serializability technique would block transaction update updates temporally inconsistent data another transaction read reading data blocking might cause read receive temporally inconsistent data hand relaxing serializability allowing transaction update preempt transaction read could violate logical consistency read example indicates requirements meeting logical temporal consistency constraints conflict proposals techniques relax serializability 2 4 5 6 7 8 many techniques use semantic knowledge system determine logical correctness instead mandating serializable schedule however techniques intended rtdbmss thus incorporate semantics associated temporal consistency survey realtime database concurrency control issues presented 9 many techniques relax serializability still neglect data temporal consistency considerations exception work presented 10 replaces serializability correctness criterion called similarity similarity semantically defined relation pair data values indicates values recorded close enough time considered equal used define concurrency control technique incorporates temporal consistency considerations technique however directly address logical consistency temporal consistency designed concurrency control technique 3 called semantic locking supports expression enforcement tradeoffs logical temporal consistency constraints realtime objectoriented database management systems technique designed soft realtime data management means makes effort preserve temporal consistency offer priori guarantee meeting timing constraints due lack guarantees technique appropriate hard realtime data management timing constraints must predictably met semantic locking technique concurrency control distributed individual data objects controls concurrent access based semantically defined compatibility function objects methods 3 semanticallydefined compatibility similar described 8 12 use notion commutativity define operation conflict semantics allowed technique richer allowed 8 12 semantics include among things expression conditions logical consistency relaxed order maintain temporal consistency instance example semantics could express transaction update allowed write data item transaction read reading condition temporal consistency data item threatened violated rtdbms concurrency control technique sacrifices logical consistency maintain temporal consistency may introduce certain amount logical imprecision data andor transactions instance example concurrency control technique allows transaction update write data item transaction read reading data item read might get imprecise view data data item might become imprecise two transactions write allowed execute concurrently imprecision database desirable often tolerable instance air traffic control application transaction queries position airplanes within airspace may readlock position data items several seconds transactions execution could desirable allow updates readlocked data items order maintain temporal consistency updates readlocked data could introduce imprecision querying transactions view positions tracked aircraft however application may specify sufficient values relative position data within specified range exact values application may allow bounded imprecision transactions return values however allowing imprecision become unbounded database acceptable paper describe semantic locking technique specify accumulation bounding logical imprecision results tradeoff logical consistency temporal consistency also derive two general restrictions expressed semantics show restrictions sufficient bounding logical imprecision system formally prove sufficiency restrictions demonstrating semantic locking concurrency control technique restrictions guarantees form epsilon serializability esr 13 specialized objectoriented databases esr formal correctness criteria specifies schedule transaction execution correct results schedule data values transaction return values within specified limits serializable schedule demonstrating technique maintain version esr show provide logical correctness better enforcing temporal consistency section 2 presents model realtime objectoriented database section 3 describes semantic locking technique section 4 first describes esr correctness criteria extends model realtime objectoriented database section presents two general restrictions expressed semantics proves semantic locking technique restrictions meets objectoriented esr correctness criteria section 5 summarizes compares work related work rtdbms semantic locking concurrency control technique based upon model realtime objectoriented database called rtsorac realtime semantic objects relationships constraints 14 model extends objectoriented data models incorporating time objects transactions incorporation time allows explicit specification data temporal consistency transaction temporal consistency rtsorac model comprised database manager set object types set relationship types set transactions database manager performs typical database management operations including scheduling execution processor necessarily including concurrency control assume database manager uses form realtime prioritybased preemptive scheduling execution pro cessor database object types specify structure database objects relationships instances relationship types specify associations among database objects define interobject constraints within database transactions executable entities access objects relationships database paper focuses bounding imprecision objects transac tions presenting rtsorac model concentrate describing model object types transactions model relationship types described detail 14 illustrate realtime objectoriented database model using simplified submarine command control system application involves contact tracking contact classification response planning tasks must fast access large amounts sensor data 15 sensor data considered precise thus provides periodic source precise data database since sensor data valid certain amount time database system must ensure temporal consistency data transactions contact tracking response planning get valid data data system may accessed transactions timing constraints involved tracking ships combat scenario transactions application may also allow certain amounts imprecision depending semantics instance transaction requests position information involving friendly updatespeed updatebearing incposition getspeed getcountry c cf speed bearing position size signature captain torpedoes country speedtime bearingtime 3 speedtime 5 figure 1 example submarine object type ship may allow imprecision transaction tracking ships combat scenario figure 1 illustrates example submarine object type database schema 21 object types object type defined hn mccf component n name object type component set attributes characterized hvalue time impamti value abstract data type represents characteristic value object type field atime defines age attribute attribute allows amount imprecision must belong metric space metric space set values distance function defined distance function properties positivity symmetry upholds triangle inequality 13 field aimpamt type avalue represents amount imprecision introduced value attributes submarine include speed bearing country speed bearing may allow certain amount imprecision values real number metric space country metric space attribute must therefore remain precise times object types component set methods provides means transactions access instances object type method defined harg op exec oci arg set arguments structure attribute valuetimeimpamt input argument one whose value used method update attributes return argument one whose value computed method returned invoking transaction define sets inputargs returnargs represent subsets arg contain methods input arguments methods return arguments respectively op sequence programming language operations including reads writes attributes represents executable code method exec worst case execution time method computed using techniques described 11 oc set constraints execution method including absolute timing constraints method whole subset operations within method 14 figure osition method submarine object type adds value input argument p ositionvalue c component object type set constraints defines correct states instance object type constraint defined hpr eri pr predicate include three fields attributes value time imprecision notice logical temporal consistency constraints well bounds imprecision expressed predicates instance figure 1 predicate speedtime gamma 5 expresses temporal consistency constraint speed attribute five seconds old logical constraint speed represented predicate speedvalue 0 predicate defines maximum amount imprecision may allowed value speed attribute component er constraint enforcement rule sequence programming language statements executed predicate becomes ie constraint violated cf component object type boolean compatibility function domain theta theta sstate compatibility function uses semantic information methods well current system state sstate define compatibility ordered pair methods object type describe cf component detail section 31 22 transactions transaction defined hmi l cp mi set method invocation requests request represented hm arg temporali component method invocation request identifier method invoked arg set arguments method recall method argument return argument input argument return argument specifies limit amount imprecision allowed value returned r import limit r input argument 2 arg specifies value time imprecision amount passed method well maximum amount imprecision may exported transaction export limit note concurrency control technique describe section 3 limit amount imprecision transaction may export however generality model supports limit temporal field method invocation request specifies whether transaction requires temporally consistent data returned l component transaction set lock requests releases lock request associated method invocation request transaction may request lock prior request method invocation perhaps enforce transaction logical consistency requirement case lock request future method invocation transaction may also request lock simultaneously method invocation case lock requested simultaneous method invocation model transaction achieve various forms twophase locking 2pl 16 requesting releasing locks specific orders flexible transaction locking techniques follow 2pl also supported component c transaction set constraints transaction constraints expressed execution timing imprecision 14 priority p transaction used database manager perform realtime transaction scheduling survey realtime transaction scheduling see 9 method invocation requested transaction executed transactions priority transaction made set method invocations model assumes transaction cannot perform intermediate computations example assume user submarine database wants precise location information submarines database transaction perform task would request lock simultaneous invocation getp osition method submarine object database specifying imprecision import limit zero arguments return locations transaction would hold locks methods invocations complete 3 semantic locking technique section describes realtime concurrency control technique database objects rtsorac model technique uses semantic locks determine transactions may invoke methods object granting semantic locks controlled individual object uses compatibility function define conditional conflict description technique concentrates concurrency control within individual objects concerned bounding imprecision within objects transactions briefly address interobject concurrency control end section 31 compatibility function compatibility function cf component object section 21 runtime function defined every ordered pair methods object function form act represents method active lock req represents method lock requested transaction boolean expression may contain predicates involving several characteristics object system general concept affected set introduced 17 used basis representing set attributes object method readswrites modify notion statically define method read affected set readaffectedm write affected set writeaffectedm compatibility function may refer time field attribute well current time time attribute becomes temporally invalid deadlinea express situation logical consistency may tradedoff maintain restore temporal consistency current amount imprecision attribute aimpamt methods return argument r rimpamt along limits amount imprecision allowed data fflspec citedrewpu93 r import limit r used determine compatibility ensures interleavings introduce much imprecision values method arguments used determine compatibility pair method invocations similar techniques presented 7 imprecision accumulation addition specifying compatibility two locks method invocations semantic locking technique requires compatibility function express information potential imprecision could introduced interleaving method invocations three potential sources imprecision compatibility function must express invocations methods 1 1 imprecision value attribute write affected sets 1 2 imprecision value return arguments 1 reads attributes written 3 imprecision value return arguments 2 reads attributes written compatibility imprecision accumulation increment s1 impamt increment speedimpamt data fflspec speed gamma js1 value gamma s2valuej c cf incpositiona getpositionp increment pimpamt javaluej figure 2 compatibility function examples compatibility function examples figure 2 uses submarine example section 21 demonstrate several ways compatibility function semantically express conditional compatibility method locks example shows compatibility function express tradeoff logical consistency temporal consistency lock currently active getspeed lock updatespeed requested serializability locks would compatible getspeeds view speed attribute could corrupted however timing constraint speed violated important allow updatespeed restore temporal consistency therefore two locks held concurrently long value written speed updatespeed 2 value close enough current value speed speedvalue determination based imprecision limit getspeeds return argument 1 amount imprecision updatespeed write speed 2 impamt also shown potential accumulation imprecision could result interleaving case getspeeds return argument 1 would potential increase imprecision equal difference value speed update takes place speedvalue value speed write takes place 2 value plus amount imprecision written speed updatespeed 2 impamt example b figure 2 illustrates attribute become imprecise two invocations updatespeed may occur concurrently sensor writes one value human user also updates speed two locks updatespeed may held concurrently long difference values written associated invocations exceed allowed amount imprecision speed attribute case objects speed attribute would potential increase imprecision equal value js 1 valuej interleaving allowed semantic lock request req step granted true initialization every act 2 activelocks la act priority queue act priority req priority cf act save impamts return args act increment imprecision la 2 else granted false endif end granted priority queue lb else activelocks lc endif endif compatibilities enqueue request done yes request add lock active locks set la figure 3 mechanism semantic lock request example c figure 2 represents compatibility function method complex examples method incp osition reads p osition attribute increments value input argument writes result back p osition attribute lock invocation method may held concurrently lock invocation getp osition amount incp osition increments p osition within imprecision bounds return argument p getposition case getp ositions return argument p would potential increase imprecision equal value incp ositions argument interleaving allowed 32 semantic locking mechanism semantic locking mechanism must handle three actions transaction semantic lock request method invocation request semantic lock release described section 22 semantic lock may requested future method invocation request simultaneous method invocation request future method invocation requests useful transaction requires locks granted execution occurs strict twophase locking figures 3 4 show procedures semantic locking mechanism executes receiving semantic lock request method invocation request respectively priority queue maintained hold requests immediately granted method invocation request req step initialimprecisionm req precondition fails b priority queue l else every 2 w riteaffectedm req save original aimpamt end every r 2 returnargsm req save original rimpamt end already locked execute req semantic lock update j check queue k else semantic lock request e lock granted f execute req h else every 2 w riteaffectedm req restore original aimpamt every r 2 returnargsm req restore original rimpamt every saved return argument r active method invocation restore original rimpamt endif endif method invocation preconditions already update enqueue request check queue done yes yes initial imprecision update imprecision lock request granted yes execute method restore impamts g f execute method figure 4 mechanism method invocation request 321 semantic lock request object receives semantic lock request method invocation req semantic locking mechanism evaluates compatibility function ensure req compatible currently active locks queued lock requests method invocations higher priority req figure 3 step la 1 compatibility function test succeeds mechanism accumulates imprecision could introduced corresponding interleaving step la 2 recall boolean expression compatibility function include tests involving value time imprecision information method arguments involved semantic lock request future method invocation values arguments time request thus evaluating compatibility function cf act req either act req future method invocation clause compatibility function involves method arguments must evaluate false compatibility function tests succeed semantic locking mechanism grants semantic lock places active lock set step lc test fails mechanism places request priority queue retried another lock released step lb 322 method invocation request object receives method invocation request semantic locking mechanism evaluates set preconditions either requests semantic lock invocation necessary updates existing semantic lock specific argument amounts preconditions successfully evaluated locks granted updated semantic locking mechanism allows method invocation execute mechanism also accumulates imprecision could result requested method execute following paragraphs describe steps figure 4 semantic locking mechanism method invocation request req initial imprecision calculation given method invocation request req semantic locking mechanism first computes potential amount imprecision req introduce attributes writes return arguments computation takes account imprecision attributes read methods input arguments well computations done method values figure 4 step initial imprecision procedure computes amount imprecision req write attribute write affected set req req exportimpa procedure also computes amount imprecision req return return arguments r req importimpr procedure computes values using amount imprecision already attribute return argument calculating method may update imprecision operations performs initial imprecision procedure may created object designer compiletime tool examines structure req determine method affect imprecision attributes write affected set return arguments preconditions test next phase semantic locking mechanism method invocation request req tests preconditions determine executing req would violate temporal consistency imprecision constraints step b mechanism evaluates following preconditions req requested preconditions req exportimpa data fflspec b precondition ensures transaction requires temporally valid data invoked method execute data reads become temporally invalid execution time precondition b ensures executing method invocation allow much initial imprecision introduced attributes method invocation writes precondition c ensures method invocation executes introduce much initial imprecision return arguments precondition fails semantic locking mechanism places request priority queue step l retried another lock released preconditions hold semantic locking mechanism updates imprecision amounts every attribute write affected set req value req exportimpa similarly updates imprecision amounts every return argument r req value req importimpr step c mechanism saves original values imprecision amounts attributes return arguments involved restored lock granted preconditions block transaction data accesses imprecise requirements must way restoring precision data transactions blocked indefinitely certain transactions write precise data characterized independent updates 18 transaction may come sensor user intervention restores precision data writes allows transactions blocked imprecision data executed associated semantic lock semantic locking mechanism next determines whether req already locked semantic lock requested earlier step semantic lock requested step e described section 321 lock granted semantic locking mechanism allows method invocation execute step h otherwise mechanism restores original values imprecision amounts changed step g semantic lock associated req granted earlier semantic locking mechanism allows req executed step mechanism performs semantic lock update step j procedure entails updating existing semantic lock associated req specific argument information available lock granted updating existing locks potentially increases concurrency among methods values arguments compatibility function likely evaluate true semantic lock updated lock requests waiting priority queue checked compatibility newly updated lock step k 323 releasing locks semantic lock released explicitly holding transaction whenever semantic lock released removed active locks set priority queue checked requests may granted since newlyreleased semantic lock may associated method invocation restored logical temporal consistency attribute lock may caused incompatibilities queued lock requests may granted also method invocation requests queued may pass preconditions temporal consistency precision restored data requests queue reissued priority order requests granted removed queue 33 interobject concurrency control semantic locking mechanism described paper maintains consistency individual objects transactions addition transactions current technique obtain multiple locks therefore enforce interobject consistency enforcement similar techniques used traditional database systems requires transactions written maintain interobject consistency extending semantic locking provide system enforcement interobject consistency possi ble outside scope paper outline approach mentioned section 2 interobject constraints expressed rtsorac relationships interobject constraint defined methods objects participating relationship enforced enforcement rule constraint enforcement rule interobject constraint may invoke methods participating objects thus automatically support interobject constraint semantic locking technique propagate semantic lock requests relationships ensure enforement rule maintains interobject constraint execute stance assume semantic lock requested method 1 object participates relationship r relationship r interobject constraint c object enforcement rule constraint c requires method 2 executed conditions execution upon request semantic lock 1 semantic locking mechanism also propagate semantic lock request 2 propagated locks granted original lock request granted propagated semantic locks would released original lock released paper concentrates semantic locking imprecision management individual objects significant problem working extending semantic locking technique automatically support interobject constraints outlined description outside scope paper 34 implementation implemented rtsorac model prototype system extends open object oriented database system open oodb 19 support realtime requirements realtime extensions execute sun sparc classic workstation solaris 24 operating system rtsorac objects implemented main memory using solaris shared memory capability transactions access objects shared memory segment objects address space design provides fast predictable access data objects accessing objects transactions execute semantic locking mechanism provide concurrency control performance measurements prototype system indicate requesting semantic lock requires approximately locks object time increases linearly active lock pending request implementation described fully 20 bounding imprecision section show semantic locking technique bound imprecision objects transactions database prove semantic locking technique two general restrictions design objects compatibility function ensures epsilonserializability esr 13 correctness criteria defined objectoriented databases met first summarize definition esr 13 18 extend definition objectoriented databases second present two general restrictions compatibility function third formally prove sufficiency restrictions ensuring semantic locking technique maintains objectoriented esr finally describe example restricted semantic locking technique bounds imprecision submarine tracking example 41 epsilon serializability epsilon serializability esr correctness criterion generalizes serializability allowing bounded imprecision transaction processing esr assumes serializable schedules transactions using precise data always result precise data database precise return values transactions value resulting schedule h imprecise differs corresponding value resulting possible serializable schedule transactions h order accumulate limit imprecision esr assumes use data items belong metric space defined section 2 13 transaction specifies limits amount imprecision import export respect particular data item import limit tx defined maximum amount imprecision transaction import respect data item x export limit tx defined limit amount imprecision exported transaction data item x 13 every data item x database data fflspecification data fflspec x expresses limit amount imprecision written x 18 amount imprecision imported exported transaction well imprecision written data items must accumulated transactions execution import imprecision tx represents amount imprecision imported transaction respect data item x similarly export imprecision tx represents amount imprecision exported transaction respect data item x data imprecision x defines amount imprecision written data item x esr defines safety set conditions specifies boundaries amount imprecision permitted transactions data safety divided two parts transaction safety data safety safety transaction respect data item x defined 13 follows 1 trsafety tx j import imprecision tx import limit tx export imprecision tx export limit tx data safety described informally 18 formalize definition data safety data item x data imprecision x data fflspec x original definition esr 13 18 stated esr guaranteed transactions data items safe formally guaranteed trsafety tx datasafety x invariant every transaction every data item x definition adapt objectoriented data model use show semantic locking technique maintains bounded imprecision 42 objectoriented esr definitions data transaction safety general define safety specifically rtsorac realtime objectoriented data model although model allows arbitrary attributes return arguments assume following definitions theorem attribute value element metric space data safety data rtsorac model represented objects safety object defined follows data fflspec set attributes every attribute object meets specified imprecision constraints object safe transaction safety transactions rtsorac model operate objects methods object data values obtained return arguments methods passed objects input arguments methods let mi set method invocations transaction let set methods object denote 13 terms import inconsistency tx export inconsistency tx used renamed import imprecision tx export imprecision tx method invocations invoked mi define safety transaction ot respect object follows ot safety j long arguments method invocations object invoked ot within imprecision limits safe respect define object epsilon serializability oesr guaranteed ot safety objectsafety invariant every object transaction every object definition oesr specialization general definition esr 43 restrictions compatibility function rtsorac compatibility function allows object type designer define compatibility among object methods based semantics application present two restrictions conditions compatibility function sufficient guarantee oesr intuitively restrictions allow readwrite writewrite conflicts affected sets methods long specified imprecision limits violated imprecision managed restrictions comes interleavings allowed compatibility function imprecision may introduced calculations performed methods accumulated initial imprecision procedure compatibility function evaluated see section 322 let attribute object 1 two methods restrictions r1 2 writeaffectedm 1 compatibility function cf 1 cf 2 may return true includes conjunctive clause data fflspec gamma aimpamt z 1 z 2 values written respectively furthermore compatibility functions associated imprecision accumulation must specify following aimpamt aimpamt r2 2 readaffectedm 1 every r 2 returnargsm 1 value r using current value let x value written 2 let w value r using x compatibility function cf 2 may return true includes conjunctive clause jz gamma wj import limit r gamma rimpamt furthermore compatibility associated imprecision accumulation must specify following r b compatibility function cf 1 may return true includes conjunctive clause furthermore compatibility functions associated imprecision accumulation must specify following r rimpamt rimpamt restriction captures notion two method invocations interleave write attribute amount imprecision may introduced distance two values written jz 1 j maintain safety amount cannot greater imprecision limit less current amount imprecision data fflspec gamma aimpamt accumulation imprecision aimpamt also reflected r1 example restriction r1 recall compatibility function example figure 2b section 31 notice speed attribute write affected set method updatespeed thus restriction r1 applies compatibility function cf updatespeed 1 updatespeed 2 value written speed attribute updatespeed 1 value written speed updatespeed 2 thus compatibility function cf updatespeed 1 updatespeed 2 may return true restriction based fact method invocation reads attribute 1 interleaved method invocation writes attribute 2 view 1 attribute return argument r may imprecise r2a amount imprecision view attribute distance value attribute 2 takes place value attribute 2 write takes place jz gamma wj amount cannot greater imprecision limits imposed r less current amount imprecision r import limit r gamma rimpamt also must accumulated imprecision amount r restriction r2b differs r2a r2b 1 currently active 2 quested initial imprecision procedure 1 computes amount imprecision 1 return r 1 invoked thus rimpamt include amount imprecision 2 might introduce ximpamt allowing interleaving 1 could cause imprecision introduced returned r additional amount imprecision introduced 2 ximpamt must taken account testing compatibility 1 must also included accumulation imprecision r figure 2a section 31 presents example compatibility function meets restriction r2b notice function evaluate true difference value speed attribute update takes place speedvalue value attribute update takes place 2 value within allowable amount imprecision specified return argument getspeed method notice also allowable amount imprecision must take account amount imprecision already return argument 1 amount imprecision argument used update speed attribute 2 impamt restrictions requires nonserializable interleavings allowed certain conditions involving argument amounts evaluate true thus cf future method invocation restrictions require serializable interleavings allowed therefore imprecision accumulated one method invocations tested compatibility future method invocation call concurrency control technique results placing restrictions r1 compatibility function restricted semantic locking technique 44 correctness show restricted semantic locking technique guarantees oesr first prove lemma objectsafety remains invariant step semantic locking mechanism prove similar lemma otsafety lemmas rely design restricted semantic locking technique contains tests safety conditions potential accumulation imprecision sufficient demonstrate safety maintained semantic lock requests simultaneous method invocations since part semantic locking mechanism introduce imprecision data transactions semantic lock request future method invocation introduce imprecision argument amounts known thus restrictions require imprecision accumulated interleaving method invocation lock releases also introduce imprecision lemma 1 restricted semantic locking technique used objectsafety invariant every object proof let object set attributes assume initially safe restricted semantic locking technique used consider steps semantic locking mechanism figure 4 imprecision amount aimpamt updated ffl step c imprecision accumulated preconditions requested method invocation hold 2 writeaffectedm since preconditions hold step mexportimpa precondition b data fflspec combining two relations data fflspec requirement object safety thus object safety remains invariant step c ffl step la imprecision accumulated step la 2 compatibility function evaluation step la 1 method invocations 1 evaluates true 2 writeaffectedm 1 case imprecision step la 2 aimpamt new aimpamt old j z 1 z 2 values written 1 respectively restriction r1 jz 1 data fflspec gamma aimpamt old inequality rewritten data fflspec combining relation relation involving aimpamt new yields aimpamt new data fflspec requirement object safety thus object safety remains invariant lemma 2 restricted semantic locking technique used ot safety invariant every transaction respect every object proof let object transaction method invocation invoked r return argument input argument assume initially safe respect restricted semantic locking technique used show rimpamt import limit r first case semantic lock requested case holds semantic lock case 1 transaction requests semantic lock semantic lock held another method invocation 1 consider situations rimpamt updated semantic locking mechanism ffl step c imprecision accumulated preconditions hold since preconditions hold step c 2 ensures mimportimpr precondition c mimportimpr import limit r combining two relations rimpamt import limit r requirement ot safety thus ot safety remains invariant step c ffl step la imprecision accumulated step la 2 compatibility function evaluation step la 1 cf 1 evaluates true readaffectedm case imprecision step la 2 z value r using current value w value r using value written 1 restriction r2a jz gamma wj import limit r gamma rimpamt old inequality rewritten rimpamt old combining relation relation involving rimpamt new yields rimpamt new import limit r requirement ot safety thus ot safety remains invariant step la 2 case 2 transaction holds semantic lock semantic lock requested case rimpamt updated step la semantic locking mechanism compatibility function evaluation step la 1 evaluates true readaffectedm case imprecision step la 2 rimpamt new rimpamt old value written 1 z value r using current value w value r using x restriction r2b old ximpamt inequality rewritten rimpamt old combining relation relation involving rimpamt new yields rimpamt new import limit r requirement ot safety thus ot safety remains invariant step la 2 ot safety property iimptamt export limit trivially met semantic locking technique limit amount imprecision exported transaction transactions objects stated 18 transactions execute simple operations export limit omitted transaction rely completely data fflspecs imprecision control simple model transactions section 22 allows us define input arguments export limit regardless value iimpamt ot safety invariant 2 theorem 1 restricted semantic locking technique used oesr guaranteed proof follows definition 2 lemma 1 lemma 2 2 theorem 1 shows restricted semantic locking technique used imprecision introduced data transactions bounded oesr guaranteed across objects transactions result shows restricted semantic locking technique maintains single global correctness criterion bounds imprecision database 45 example use example submarine object instance object type figure 1 section 2 illustrate semantic locking technique maintains imprecision limits data object therefore guarantees oesr objects method updatespeeds writes value value field objects speed attribute assume speed attribute initially precise active lock simultaneous invocation updatespeed100 objects priority queue empty let transaction request lock simultaneous invocation updatespeed106 value 106 03 units imprecision indicated figure 1 imprecision limit speed data fflspec speed 10 submarine object receives request updatespeed106 method invocation executes semantic locking mechanism figure 4 first computes initial imprecision procedure step speed attribute write affected set updatespeed updatespeed return arguments initial imprecision procedure computes updatespeedexportimpspeed invocation updatespeed106 writes 106 speed 03 units imprecision preconditions requested updatespeed106 method invocation tested next step b precondition trivially holds readaffectedupdatespeed precondition b also holds since updatespeed return arguments precondition c holds well semantic locking mechanism initializes imprecision amount speed attribute value updatespeedexportimpspeed semantic lock requested simultaneous method invocation condition step true semantic lock request performed step e step la 1 objects semantic locking mechanism checks compatibility requested invocation updatespeed106 currently locked invocation updatespeed10 recall figure 2 example section 43 cf updatespeed 1 updatespeed 2 data ffl speedimpamt test compatibility function uses imprecision amount speed stored step c thus js 1 data fflspec speed gamma 07 method invocations compatible step la 1 objects semantic locking mechanism executes step la 2 accumulate imprecision speed attribute imprecision amount speed stored step c recall figure 2 cf updatespeed 1 updatespeed 2 thus mechanism computes new value imprecision amount speed attribute speedimpamt 03 active locks check compatibility compatibility function evaluates true objects mechanism grants semantic lock invocation adds lock objects active lock set step lc finally semantic locking mechanism executes updatespeed106 step h note imprecision amount speed attribute 09 updatespeed method invocations execute concurrently imprecision limits maintained although demonstrated relatively simple method interleavings example essentially two writes single attribute use read affected write affected sets semantic locking technique allows perform similar fashion complicated object methods 5 conclusion paper presented model objectbased semantic realtime concurrency control technique capable enforcing temporal logical consistency constraints within realtime database objects moreover demonstrated technique bound imprecision introduced one constraint traded another done showing certain general restrictions technique guarantees global correctness criterion specialization epsilon serializability objectoriented databases although technique designed soft realtime databases therefore offers guarantees meeting timing constraints support provides realtime treatment temporal consistency requirements userdefined compatibility function provides support maintaining data temporal consistency allowing specification tradeoff temporal logical consistency technique allows relaxing serializability among transactions likelihood realtime scheduler able determine schedule maintains transaction timing constraints increased technique differs previous realtime concurrency control work 9 semantic concurrency control work 2 5 6 based objectoriented data model differs objectbased concurrency control work 7 8 12 17 21 incorporates temporal consistency requirements differs approaches realtime concurrency control work 10 manage bound imprecision accumulated due trading logical consistency temporal consistency differs esrbased techniques limit logical imprecision introduced temporal consistency data transactions threatened semantic locking technique closest concurrency control protocol presented 8 protocol uses commutativity bounded imprecision define operation conflicts similar protocol user defines allowed amount imprecision given operation invocation protocol uses modified commutativity table determine operation execute concurrently active operations however protocol 8 take temporal considerations account furthermore restrictions compatibility function defined section 43 provide user guide defining compatibility function maintain correctness similar guide 8 defining commutativity bounded imprecision two drawbacks technique complexity posed system designer additional overhead required runtime system grant locks one reason complexity applications require realtime database management submarine command control generally complex supported traditional databases adding support imprecision maintenance providing potential increase concurrency also adds complexity technique currently developing tool ease burden system designers tool computes read write affected sets methods along static characteristics proposes default object compatibility functions imprecision accumulation designer interactively modify compatibility function constraints objects transactions based applicationspecific semantic information although performance measurements technique prototype system indicate takes order hundreds microseconds depending number current locks requests execute semantic locking extra overhead prohibitive indicate semantic locking appropriate applications short method executions lock durations longerlived method executions transactions increased concurrency semantic locking easily justify increased overhead currently performing simulation studies accurately specify circumstances semantic locking superior unfor tunately bounding overhead blocking time introduced semantic locking technique feasible due complexity technique limits usefulness hard realtime databases believe generality technique conditional compatibility function semantic locking mechanism distributed object treatment temporal consistency definition restrictions sufficient bound imprecision definition objectoriented version esr valuable contributions towards expressing enforcing imprecision object databases well providing support maintaining temporal logical consistency found realtime databases acknowledgements thank joan peckham janet prichard paul fortier krithi ramamritham helpful comments suggestions thank john black work implementing prototype system feedback along way r realtime databases using semantic knowledge transaction processing distributed database system objectbased semantic realtime concurrency control concurrency control advanced database applications multilevel concurrency new correctness criterion database concurrency control using semantic knowledge transactions increase concurrency synchronizing shared abstract types tolerating bounded inconsistency increasing concurrency database systems realtime databases concurrency control scheduling ssp semanticsbased protocol realtime data access semantic locking objectoriented database sys tems formal characterization epsilon serializability rtsorac realtime objectoriented database model realtime considerations submarine target motion analysis concurrency control recovery database systems synchronizing transactions objects asynchronous consistency restoration epsilon serializability architechture open objectoriented database management system rtsorac incorporating realtime objectoriented database management commutativitybased concurrency control abstract data types divergence control epsilonserializability tr ctr victor fay wolfe lisa cingiser dipippo roman ginis michael squadrito steven wohlever igor zykh russell johnston expressing enforcing timing constraints dynamicrealtime corba system realtime systems v16 n23 p253280 may 1999 kwokwa lam sang h son victor c lee sheunglun hung relaxing consistency requirement readonly transactions information sciencesinformatics computer science international journal v143 n14 p115146 june 2002 salvatore march charles wood gove n allen research frontiers object technology information systems frontiers v1 n1 p5174 july 1999
parallel complexity numerically accurate linear system solvers prove number negative results practical ie work efficient numerically accurate algorithms computing main matrix factorizations particular prove popular householder givens methods computing qr decomposition pcomplete hence presumably inherently sequential real floating point number models also prove gaussian elimination ge weak form pivoting aims making resulting algorithm nondegenerate likely inherently sequential well finally prove ge partial pivoting pcomplete gf2 restricted symmetric positive definite matrices known even standard ge pivoting fail altogether results paper give formal support widespread belief tradeoff parallelism accuracy numerical algorithms b introduction strongly nonsingular mauro leoncini giovanni manzini luciano margara august 8 1997 parallel complexity numerically accurate linear system solvers work merges preliminary results presented esa 96 spaa 97 dipartimento di informatica universita di pisa corso italia 40 56125 pisa italy imccnr via maria 46 56126 pisa italy email leoncinidiunipiit supported murst 40 funds dipartimento di scienze e tecnologie avanzate universita di torino via cavour 84 15100 alessan dria italy email manziniunialit dipartimento scienze dellinformazione universita di bologna piazza porta donato 5 40127 italy email margaracsuniboit matrix factorization algorithms form backbone stateoftheart numerical libraries packages lapack matlab 2 14 indeed factoring matrix almost always first step many scientific computations usually one places heaviest demand terms computing resources view importance authors investigated parallel complexity popular matrix factor izations namely 5 decompositions see appendix definitions simple properties list positive known results follows decomposition arithmetic whenever exists ie provided leading principal minors input matrix nonsingular case say matrix 16 18we prove number negative results practical ie work efficient numerically accurate algorithms computing main matrix factorizations particular prove popular householder givens methods computing qr decomposition pcomplete hence presumably inherently sequential real floating point number models also prove gaussian elimination ge weak form pivoting aims making resulting algorithm nondegenerate possibly unstable likely inherently sequential well finally prove ge partial pivoting pcomplete restricted symmetric positive definite matrices known even plain ge fail altogether results paper give formal support widespread belief tradeoff parallelism accuracy numerical algorithms ffl2 1log stable minimal lu plu nc qr nc lu qr lu qr plu n n n n n confused analogous lfmis problem graph theory known pcomplete 10 decomposition arithmetic matrices full column rank since easily reduces decomposition strongly nonsingular matrices 16 decomposition arithmetic nonsingular matrices 7 algorithm finding permutation matrix strongly nonsingular builds upon computation lexicographically first maximal independent subset rows matrix 3 5 factorization arbitrary matrix arithmetic 7 permutation 5 leftmost submatrix full column rank found computing lfmis sets column vectors unfortunately none algorithms proved numerically accurate respect realistic model arithmetic double precision floating point actually finding numerically stable nc algorithm compute decomposition matrix regarded one major open problems parallel computation theory 10 positive solution problem around corner confirmed negative results proved algorithms practical use computing decompositions already 1989 vavasis proved gaussian elimination partial pivoting gep standard method computing decomposition pcomplete real rational numbers 20 note strictly speaking membership p could defined real number model dealing real matrices real number computations assume implicitly class p defined include problems solvable polynomial time models real ram see 17 result 20 proved showing decision problem defined terms geps behavior pcomplete parallel complexity theory pcompleteness result implies gep likely inherently sequential ie admitting implementations one authors proved gep probably even harder parallelize sense implementation exist unless problems admit polynomial speedup 12 paper prove new negative results classical factorization algo rithms consider methods householders reflections givens rotations compute decomposition matrix main use decomposition within iterative methods computation eigenvalues matrix compute least squares solutions overdetermined linear systems 9 moreover householders givens methods hereafter denoted hqr gqr respectively potential competitors gaussian elimination solve systems linear equations stably parallel date fastest stable parallel solver based gqr characterized parallel time processor pram 19 gep hqr run log processors also gqr especially suitable solving large sparse systems given ability annihilate selected entries input matrix low cost also consider application gaussian elimination partial pivoting special classes matrices weaker form pivoting call r pivoting gem minimal pivoting pivot chosen annihilate given column first nonzero main diagonal minimal pivoting especially suitable systoliclike implementations linear system solvers see eg 11 although called way minimal pivoting regarded minimum modification required gaussian elimination nondegenerate arbitrary input matrices prove following results 1 hqr gqr pcomplete real floating point numbers exhibit reductions nand circuit value problem nandcvp fanout 2 particular prove pcomplete decide sign given diagonal element upper triangular matrices computed either hqr gqr reductions seem intricate simple one 20 probably consequence apparently complex effect reflections rotations respect linear combinations gaussian elimination would like stress pcompleteness proofs case floating point arithmetic apply directly checked algorithms available stateoftheart package matlab using ieee 754 standard floating point arithmetic words negative results apply widely inuse algorithms 2 extend vavasis result proving gep pcomplete input strongly nonsingular matrices class includes matrices important practical applications namely diagonally dominant symmetric positive definite ones note plain gaussian elimination pivoting guaranteed fail input strongly nonsingular matrix however since usually unstable one still uses gep 3 prove gem pcomplete general matrices 4 show known algorithm computing plu decomposition nonsingular matrix corresponds ge nonstandard pivoting strategy slightly differs minimal pivoting also prove ge nonstandard strategy pcomplete input arbitrary matrices somehow accounts difficulties finding algorithm compute plu decomposition possibly singular matrices results paper give evidence pervasiveness phenomenon observed also numerical analysts practical perspective namely tradeoff degree parallelism one hand nondegeneracy accuracy properties numerical algorithms 5 rest paper organized follows section 2 introduce little notation give preliminary definitions section 3 describe key ideas common pcompleteness proofs factorization methods considered paper sections 4 5 address qr decomposition via householders reflections givens rotations respectively section 6 prove negative results gaussian elimination partial minimal pivoting section 7 show correspondence known decompostion algorithm gaussian elimination conclude considerations open problems appendix discuss preliminaries f column minor principal row row echelon x x j x n lu l u l lu lu plu plu qr q r q r qr qr algorithms considered paper appendix b give basic definitions floating point number representation clearly material well known algorithms computer arithmetic found many excellent textbooks particular see 9 finally include one technical proof appendix c notations adopted matrices matrixrelated concepts standard ones see 9 matrices denoted capital letters entry matrix referred either vectors designated lower case letters usually taken end alphabet eg etc note notation refers vector ie 1 matrix 1 th row resp column matrix denoted resp matrix submatrix minor square submatrix formed set row column indices symbols denote identity matrix otherwise zero matrix respectively zero vector denoted using symbol 0 transpose matrix usually denoted matrix orthogonal permutation matrix matrix zero everywhere except one 1 row column permutation matrix orthogonal transpose column vector vector ie matrix size 1 let square matrix order decomposition pair matrices lower diagonal elements upper triangular arbitrary even nonsingular matrix decomposition might defined sufficient condition existence unicity strongly nonsingular decomposition triple matrices permutation matrix decomposition always defined unique decomposition pair matrices orthogonal upper triangular decomposition always exists cases factorization exists get matrix properly said form rather upper triangular leftmost minor upper triangular rightmost minor general dense submatrix however confusion possible always speak triangular factor given factorization detailed description algorithms considered paper found appendix details however necessary understand common structure reductions details required proofs theorems 43 53 deal floating point version algorithms except following general description sufficient defines class matrix factorization f proper embedding p3 input output 3 framework reductions kk k k k n k k b b r algorithms includes among others classical qr algorithms gaussian elimination let input matrix algorithms bring upper triangular form applying series transformations introduce zeros strictly lower triangular portion left right notation usually adopted indicate matrix obtained 1 transformations elements referred zero min transformation applied one algorithm every algorithm satisfies following properties words first entries row zero first stages modify row column complementary nonzero structure respect columns 1 1 mean affected first 1 transformations property call matrix larger matrix matrix dimensions 1 let triangular factor computed input let matrix minor suppose consequence repeated applicability first 1 stages algorithm input affects rows identifies contains minor words factorization viewed part factorization alone perhaps simplest example proper embedding stage modifies entry particular introduces zeros th column without destroying previously introduced zeros view avoid redundant descriptions rest paper use notation indicate submatrix elements rightward downward pcompleteness results based reductions nandcvp restricted version cvp circuit value problem briefly recall description input boolean circuit composed entirely gates boolean values value computed input nandcvp pcomplete reported 10 order simplify proofs assume without loss generality gate fanout two shall prove section following general result applies factorization algorithm b b true false 31 informal description nand duplicator copier wire n xr c n encoding scheme logical values logspace bounded transducer following properties given description fanout 2 nand circuit boolean inputs builds matrix order factorization computed algorithm upper triangular encoding shall prove theorem 31 transducer exists provided certain elementary matrices well defined properties later show matrices exist algorithms considered paper unfortunately formal description proof correctness transducer require quite large amount details spite idea behind construction easy namely repeatedly apply proper embedding property hence first describe reduction informal way afterward proceed formal derivation moreover actually implemented transducer collection matlab files elementary matrices floating point versions householders givens qr algorithms interesting technical ones electronically available authors let let denote appropriate numerical encodings truth values need three kinds square elementary matrices first matrix apply compute factorization get encoding right bottom entry upper triangular factor second elementary matrix compute incomplete factorization ie apply last transformation get 0in right bottom corner incomplete triangular factor third elementary matrix compute factorization get right bottom entry triangular factor using matrices building blocks construct matrix simulates circuit structure close block diagonal one block nand gate circuit duplicator blocks used simulate fanout 2 nand gates wire blocks route computed values according circuits structure factorization block diagonal matrix could performed independently factoring single blocks certain degree overlapping blocks necessary pass computed values around illustrate preceding scheme work practice see difficulties may appear consider first construction submatrix simulates gate basic idea append duplicator nand block pictorially shown figure 1 left block dark gray area block light gray white zones contain zeros right bottom entry coincides top left entry example proper embedding suppose order 1 stages encoding exactly required ie top left entry duplicated light gray area figure 1 right 32 elementary matrices n w time algorithm starts working column ws ws modified transformations changes submatrix still triangularized occurred first row already know entry modified properly needs case entries ie black colored ones figure 1 right simulation proceed correctly required black entries store rest first row cannot rely initial contents figure 1 nd matrix composition effect first 1 stages second example figure 2 pictorially describes block used pass value possibly far away place block dark gray area figure 2 split across non consecutive rows columns precisely order top left dark gray area intended represent principal minor order 1 white zones contain zeros light gray area arbitrary size stores arbitrary values situation represents proper embedding first 1 stages input order result factorization block implies encoding logical value initially top left entry copied far away right bottom entry figure 2 splitting block get idea complete matrix might looks like see figure 3 circuit computing exclusive two bits considered corresponding matrix four blocks one block four blocks denoted different gray levels note however figure 3 incorporate yet solution black entries problem mentioned prove correctness transducer theorem 31 convenient introduce block partitioning elementary matrices defined previous section nand matrix n b c c c input output input places auxiliary b ac ac r x x figure 3 circuit computing left structure corresponding matrix right let denote one matrix partition follows 1 diagonal blocks square matrices also diagonal ie zeros outside main diagonal refer submatrices let denote order respectively note elementary matrix actually defines set matrices fact regard diagonal entries particular elementary matrix obtained filling input places encoding logical values formally define behavior elementary matrices respect factorization algorithm let denote order block partitioning 1 set factorization computed encoding often required practice overwrites input matrix value replace reason defined 1 output submatrix remark applies elementary matrices also require real value 0 0 defined using auxiliary actual input f 33 construction duplicator matrix wire matrix w xd r r x z x z w xw r r x x vectors solve black entries problem outlined section 31 intuitively appending auxiliary vectors right instead simply zeros figure 1 left obtain desired values black colored entries figure right see proof theorem 31 initial zeros auxiliary vector prevents problem pumping construction let denote order block partitioning 1 set incomplete factorization computed ie represents first 2 transformations applied obtain also require pair real numbers auxiliary vector defined let denote order block partitioning 1 set factorization computed get require real number auxiliary vector 0 defined elementary matrices including auxiliary vectors exist householders givens methods gaussian elimination well section present main result theorem 31 existence single reduction scheme works algorithm still require couple definitions suppose input variables let number places inputs gates variables used number inputs counting multiplicities let gates sorted topological order given specific assignment logical values input variables may refer th th value input set required gate z c ab z c theorem 31 proof b b n w n n n c xr r n c z z n n n g input row position let elementary matrices given fanout nand circuit input variables truth assignment build square matrix following holds order number gates b factorization computed encoding c number input rows equals number actual inputs th row either structure 2 3 depending whether th actual input enters first second input gate actual input affects one input place construction done using work space say intend initially row either encoding one actual inputs log prove result induction let actual inputs let encodings respectively case easy set property b follows definition properties c easily verified well particular exactly 2 input rows positions 1 2 structure 2 3 respectively clearly matches number actual inputs finally actual inputs affect input places suppose number gates 1 let topological ordering dag representing clearly inputs actual inputs let circuit removed outputs replaced first input variable since 1 gates may assume constructed satisfies induction hypothesis build simply extend take account two cases depending fanout fully work case fanout 1 similar tedious develop reader follow details 1 let gate connected output suppose wlog provides first input induction hypothesis particular c following structure b z z z z z z x n n n n n n n n n ff w w w x x x w w w z z z z z z w ff w w n n w w w w z z z z z z 0has input row position corresponding first input gate encoding note property actual logical value encoded affects definition entry using elementary matrices define follows minor enclosed boxes set 1 order auxiliary column vectors choose matrix factorizes observe th row modified replacing follow regard block 8 10 matrix refer th row column really intend th block rows columns nonetheless square order plus size using part induction hypothesis see easy prove enjoys properties b well assume actual inputs since fanout 1 1 actual inputs induction 1 input rows construction exactly proves c property also easily holds prove b use properties application 1 stages affects first 3 block rows thus including auxiliary vectors properly embedded hence first 1 stages get c c n n w z z z z z z n w n n n w n encoding submatrix enclosed boxes set 2 auxiliary vectors choose transformation matrix triangularizes note entries corresponding first elements auxiliary vectors contain zero required first element definition auxiliary vectors zero would faced additional problem guaranteeing first 1 stages would set entries required values easy see including auxiliary vectors properly embedded additional 1 stages leads correctness follows induction hypothesis property 2 full description fanout 2 case definitely tedious introduces new difficulties extends means initial block followed block followed two blocks taking partial overlappings account immediately follows order plus order construction matrix done space proportional log simply reversing steps inductive process instead constructing using build would require logarithmic work space compute immediately output first case first gate fanout 2 rows columns also compute output row two rows output fanout 2 gates sent done space log essentially copying elementary matrices output medium possible problem might computation case fact 1 let number fanout 2 nand gates preceding gate linear ordering information obtained required repeatedly reading input using log work space counting easily follows results index top left entry th block hence either depending whether value consideration first second input e2 b ab nn qr true false c 9 9 9 102 4 householders qr decomposition algorithm theorem 41 proof theorem 42 proof n b c c n h n n qr n n x qr r r r r r z r x z x p exact floating point arithmetic logspace hard p real number model arithmetic matlab program implements transducer indeed logspace bounded uses definition blocks simple variables whose contents never exceed size magnitude data structure depending required clearly implemented using double precision ieee 754 arithmetic properly handle circuits approximately 2 gates section prove hqr presumably inherently sequential exact floating point arithmetic done proving certain set defined terms hqrs behavior logspace complete p factorization computed hqr note hqr intend classical householders algorithm presented many numerical analysis textbooks particular refer one 9 also algorithm available primitive routine scientific libraries linpacks 6 environments like matlabs 14 begin ready hand result membership p follows standard implementations perform arithmetic operations computations see eg 9 according result section 3 prove also logspace hard p sufficient exhibit encoding scheme elementary matrices required proof theorem 31 see however floating point case asks additional care rule possibility fatal roundoff error propagations simply list three elementary matrices required theorem 31 elementary matrix corresponding auxiliary vector shown additional column matrices enjoy properties defined section 32 automatically checked using symbolic package mathematica 9 10 matrix figure 4 1 1 encoding logical values 1 1 arbitrary real number performing 8 steps hqr input arithmetization selected encoding 6 7 matrix shown figure 5 left performing 4 steps hqr input arbitrary real numbers x x z x z x theorem 43 proof computed logspace hard p finite precision floating point arithmetic precisely best possible approximations blocks particular machine arithmetic figure 4 block hqr figure 5 blocks hqr 2 3 matrix figure figure 5 right performing 1 step hqr input arbitrary real number applying floating point implementation hqr single block defined theorem 42 results approximate results instance performed decomposition four matrices using builtin function available matlab found relative error affecting computed encoding ranged minimum 0 5 maximum 3 roundoff unit equals ieee 754 standard arithmetic might appear insignificant errors however matrix containing arbitrary number blocks roundoff error may accumulate point impossible recover exact ie 1 1 result clearly direct error analysis feasible since apply infinite number reduction matrices solution control error growth correcting intermediate results soon computed nand blocks note referring values certain elementary matrix properly intend non zero values one finds last row triangular factor computed hqr input including auxiliary vectors analogously input values ones computed elementary matrix preceding take duplicator wire blocks theorem 42 provide new definition nand blocks always compute exact results consider structure resulting theorem 31 corr corr corr corr corr z z z b b c c l c l 1 2 1 c x n n x n n x let th gate topological ordering let gates providing inputs let denote block corresponding according construction theorem 31 prove result maintain invariant values computed exact clearly true 1 using invariant first verify errors affecting values computed bounded small multiple roundoff unit use bound show redefine computes exact results thus extending invariant proof theorem 31 know output similarly placed one input rows consequence factorization possibly followed block follows error affecting output due factorizations factorization since limited number structural cases depending fanout gates considering possible combinations logical values involved largest error ever affecting output determined direct tedious error analysis simply test runs purpose following discussion may safely assume relative errors affecting computed quantities bounded constant order unit actually smaller 10 words may assume actual outputs recall last entry generic auxiliary vector factorization see definition section 32 however require machine number ie rational number representable without error arithmetic considerations bound error ready show correct erroneous outputs new nand block denoted extends two additional rows columns shown positive integer specified note 1 precisely auxiliary vector old produces 1 output auxiliary vector 0 first requirement thus quantity computer number length significand see sufficient condition length significand exceed 1 let us apply hqr extended auxiliary vector properly embedded 8 stages hqr get using result error second condition want 2 get rid error easy argument shows implies log thus recalling bound planerot nn corr corr corr f theorem 51 proof theorem 52 x x x g n n qr g g 5 qr decomposition givens rotations p exact floating point arithmetic logspace hard p real number model arithmetic see 5 sufficient consequence length cannot exceed 6 actual reflection matrix applied then2 easy floating point computation gives applying one stage leads correct results requirement means problem fact auxiliary values ever required non zero elements input rows blocks possibly follow nand elementary matrices ie blocks simply 1 2 5 4 represented exactly 3 bit significand elementary matrices theorem 43 available general transducer implemented matlab particular defined section prove following set factorization computed gqr logspace complete p way present results section closely follows metodology section 4 however spend words particular algorithm considered fact computation qr decomposition done various ways using plane givens rotations differently householders reflections single plane rotation annihilates one element matrix applied different sequences annihilations result different algorithms way degree freedom exploited obtain currently faster among known accurate ones parallel linear system solvers 19 15 also outline qr algorithm available matlab libraries linpack lapack provides primitive computes plane rotations hardness results section apply particular algorithm annihilates subdiagonal elements input matrix proceding downward rightward choice places gqr class defined section 2 position one stage algorithm sequence plane rotations introduce zeros one column see eg 9 point membership p holds independently annihilation order z g true false proof b theorem 5377777777 ff x z x z x z x z ppp logspace hard p finite precision floating point theorem 42 simply list three elementary matrices extended generic auxiliary vector matrices shown figures 6 8 encodings logical values 1 1 arbitrary real numbers matrices enjoy properties defined section 32 verified help symbolic package figure block gqr figure 7 block gqr figure 8 block gqr switch delicate case finite precision arithmetic m22 true e proof 0d e 0d e r r e x apply ideas theorem 43 extend definition always computes exact results however cannot reuse block adopted exact arithmetic case subtle problem urges different definition let us see details apply floating point implementation gqr clearly get approximate results note matrices gqr contain irrational numbers particular instead 0 0 bottom right corner get 1 even order roundoff unit fact zero causes whole construction fail note kind approximate results obtained hqr damage get point suppose column let us proceed considering stage algorithm hqr one single transformation annihilates whole column contribution tiny th transformation matrix negligible hand gqr elements annihilated selectively since zero one additional plane rotation required rows 1 place zero entry 1 unfortunately effect making element position positive serious trouble since entry contained encoding small perturbation truth value result subsequent plane rotations ones simulating routing logical value applied value passed around always encoding simulation fails general thus need replace duplicator one returns true zero entry 1 incomplete factor clearly exploit properties floating point arithmetic noindent let denote length significand largest exponent 2 represented arithmetic consideration respectively standard ieee 1023 nonzero elements new duplicator powers 2 way operation either exact simply operation new auxiliary vector define nothe possible assignments 0 1 1 0 rest proof similar theorem 43 show correct slightly erroneous values computed block assuming previous blocks gep gem corr corr corr corr corr z z b c 6 gaussian elimination pivoting8 0d e 0d e 0d e 0d e 0d e e e x x n g x x return exact results let stand nand block adopted exact arithmetic version gqr figure 6 new nand block new auxiliary vector take ie first 10 entries coincide 2 let us apply gqr extended auxiliary vector properly embedded 9 stages gqr get small constant order unit plane rotation annihilate entry 2 1 represented application floating point gives crucial point represented 2 significant bits alignment fraction part performed execution 2 simply cause contribute 2 lost hence computed element entry 1 3 2 2 one rotation produces exact values last row note value required place 1 section consider algorithm gaussian elimination partial pivoting simply technique avoids nondegeneracies ensures almost always numerical accuracy also consider lessknown minimal pivoting technique one guarantees plu factorization found minimal pivoting adopted systoliclike implementations gaussian elimination 11 brief description algorithms reported appendix prove gem inherently sequential unless applied strongly nonsingular matrices gep inherently sequential even restricted strongly nonsingular matrices theorem 61 set logspace complete 61 partial pivoting 62 minimal pivoting proof give builds original proof 20 hence share common structure reductions paper essentially show little additional effort respect vavasis proof exhibit reduction matrix obtained strongly nonsingular already pointed strongly nonsingular matrices remarkable importance practical applications class contains symmetric positive definite spd diagonally dominant matrices often arise discretization differential problems observe input matrices plain ge pivoting nondegenerate stable general hence algorithm choice 20 gep inherently sequential follws proof folllowing set pcomplete strongly nonsingular input gep uses row eliminate column postpone technical proof theorem 61 appendix c give example shows way matrix given 20 modified figure 9 depicts reduction matrix would obtained according rules 20 input description circuit figure 3 matrix nonsingular however seen leading principal minor order 2 singular matrix obtain according theorem 61 shown figure 10 easily seen matrix strongly diagonally dominant rows hence strongly nonsingular figure 9 matrix corresponding exclusive circuit symbol stands zero entry technique minimal pivoting ie selecting pivot row stage first one nonzero entry main diagonal column probably simplest modification allows ge cope degenerate cases however false true theorem 62 proof b x x set logspace complete real finite precision floating point arithmetic figure 10 matrix computation simple technique sufficient make gaussian elimination algorithm inherently sequential note even formal error analysis available gem difficult exhibit matrices plausibly appear real applications error incurred gem large actually gem likely unstable plain ge consider following set factorization computed gem set clearly gem runs time models arith metic first show also logspace hard input matrices singular show restrict input set gem belongs class prove hardness simply list three elementary matrices required theorem 31 note matrices models arithmetic operations performed gem floating point exact encoding logical values 0 1 matrices depicted figures 11 12 figure 11 nand left wire right blocks gem x z z u k figure 12 block gem clearly singular consider following matrix order 2 order matrix 1 antidiagonal 0 elsewhere determinant easily proved 1 moreover factorization computed gem note prove pcomplete exactly set little complicate definition still terms gems behavior usual following notation used denote matrix obtained 1 stages gem input considering entries however writing intend submatrix obtained 1 stages gem input considering entries position prove output read entry factor show executions gem input input result identical submatrices 0 proof induction initially equality follows definition consider stage 1 column contains nonzero element main diagonal say row index selected pivot row th executions results follows induction hypothesis fact exactly operations performed elements submatrices nonzero element found column stage first execution effect hence second execution one input construction pivot taken row 2 1 however pivot nonzero element row thus effect step simply exchange rows 2 1 conclude observing set theorem 62 clearly nc computable input set class strongly nonsingular matrices fact case gem plain gaussian elimination behave exactly theorem 71 7 algorithms l l computing plu factorization returned gems input nonsingular matrix arithmetic n r section show known algorithm computing plu decomposition nonsingular matrix see 7 corresponds ge nonstandard pivoting strategy minor variation minimal pivoting result seems curiosity however prove strategy inherently sequential input arbitrary matrices seen evidence difficulties finding algorithm compute plu decomposition possibly singular matrices new strategy referred minimal pivoting circular shift corresponding elimination algorithm simply gems reason name gems like gem searches current column say column first nonzero element one found say row circular shift row performed bring row place row latter place row 1 consider algorithm eberly 7 given nonsingular order let denote matrix formed first columns set indices lexicographically first maximal independent subset rows since full column rank moreover note computation see 3 permutation factorization simply th unit column vector clearly determined computing factorization done polylogarithmic parallel time using known algorithms show induction column index permutation determined gems basis trivial since index first nonzero element column 1 1 let partial factorization computed gems upper triangular nonzero diagonal elements since nonsingular unit vectors extend form permutation matrix clearly minimal pivoting ensures next pivot row selected gems one corresponding first nonzero element first column let index pivot row since gaussian elimination nothing linear combinations rows follows initial matrix satisfies turn implies ie nn f theorem 72 proof 8 conclusions open problems x z logspace hard p except auxiliary vector od show gems inherently sequential proving set factorization computed gems pcomplete clearly p obvious remains prove following gems class simply give elementary matrices easy everything first part proof theorem 62 new definition easy interesting exercise understand second part theorem 62 extend pcompleteness result nonsingular matrices work know cannot work view theorem 71 matrices corresponding householders givens algorithms circuit singular general precisely duplicator elementary matrix singular matrices correspond simple formulas fanout 1 circuits bound singular attempts made extend proofs nonsingular matrices failed deep reasons state affairs could interesting subject per se see reasons failures might deeper simply technical inability mention result allender et al 1 power singular matrices prove set singular integer matrices complete complexity class c l result extends problem verifying rank integer matrices course work different level essentially dealing presumably inherently sequential algorithms problems parallelize well using different approaches however coincidence suggests nonsingular matrices might enough power map general circuit major open problem qr algorithms also general matrices would interesting know status householders algorithm column pivoting particularly suitable accurate rank determination floating point arithmetic concerns givens rotations obvious open problem determine status annihilation orderings especially ones proved effective limited parallelism environments 19 15 suspect lead inherently sequential algorithms well r inherently seq nc5 set c l provided nondeterministic logspace bounded turing machine iff number accepting rejecting computations input gem nc gems nc table 1 parallel complexity ge different pivoting strategies different classes input matrices already mentioned complexity matrix rank feasible systems linear equations fast parallel matrix inversion algorithms efficient parallel independent subsets matrix factorizations parallel linear algebra matrix computations limits parallel computation introduction parallel algorithms architectures arrays trees hypercubes journal computer system sciences theoretical computer science computational geometry algebraic eigenvalue problem parallel complexity parallel complexity householder qr factorization alternative givens ordering complexity parallel matrix computations stable parallel linear system solvers ge computes decomposition whenever exists determining sequence 1 elementary transformations following properties pivoting strategy pivot row ge minimal pivoting gem qr factorization via householders reflections hqr gep computes decomposition hqr applies sequence 1 elementary orthogonal transformations gqr applies general real matri ces rotation used annihilate selected entry matrix orthogonal matrix defined follows floating point system characterized particular let denote matrix corresponding circuit according vavasis proof vavasis proof based observation nand gate outputs unless one inputs matrix order 3 define matrix set oddnumbered columns main submatrix proof theorem consequence following two lemmas following facts hold gep input figure 13 structure matrix consider step 2 1 gep entries row index larger 2 induction hypothesis know first 2 2 elimination steps affect auxiliary columns 2 2 order prove suppose pivot step 2 1 4 0 tr
detection weak unstable predicates distributed programs paper discusses detection global predicates distributed program earlieralgorithms detection global predicates proposed chandy lamport 1985work stable predicates predicate stable turn false itbecomes true algorithms detect even unstable predicates without excessiveoverhead past predicates regarded difficult detectthe predicates specified using logic described formally paper discussdetection weak conjunctive predicates formed conjunction predicateslocal processes system detection methods detect whether apredicate true interleaving events system regardless whether thepredicate stable also predicate reduced set weak conjunctivepredicates detectable class predicates captures many global predicates thatare interest programmer message complexity algorithm bounded bythe number messages used program main applications results indebugging testing distributed programs algorithms incorporated ina distributed debugger runs network sun workstations unix b introduction distributed program one runs multiple processors connected communication network state program distributed across network process access global state instant detection global predicate ie condition depends state multiple processes fundamental problem distributed computing problem arises many contexts designing testing debugging distributed programs global predicate may either stable unstable stable predicate one never turns false becomes true examples stable predicates deadlock termination system terminated stay terminated unstable predicate one without property value may alternate true false chandy lamport 3 given elegant algorithm detect stable predicates algorithm based taking consistent global snapshot system checking snapshot satisfies global predicate snapshot satisfies stable predicate inferred stable predicate true end work supported part nsf grant ccr 9110605 navy grant n0003991c0082 trw faculty assistantship award ibm agreement 153 vk garg electrical computer engineering dept university texas austin austin jaypineeceutexasedu b waldecker austin system center schlumberger well services austin snapshot algorithm similarly predicate false snapshot also false beginning snapshot algorithm taking snapshots periodically stable property detected bouge 2 spezialetti kearns 22 extended method repeated snapshots approach work unstable predicate may true two snapshots time snapshot taken entirely different approach required predicates paper present approach detects large class unstable predicates begin defining logic used specification global predicates formulas logic interpreted single run distributed program run distributed program generates partial order events many total orders consistent partial order call formula strong true total orders weak exists total order true consider special class predicates defined logic global state formula either disjunction conjunction local predicates since disjunctive predicates simply detected incorporating local predicate detection mechanism process focus conjunctive predicates paper describe algorithms detection weak types predicates detection strong predicates discussed 10 many detection algorithms use timestamp vectors proposed fidge 6 mattern 17 process detects local predicate records timestamp associated event timestamps sent checker process uses timestamps decide global predicate became true show method uses optimal number comparisons providing adversary argument also show checking process decentralized making algorithms useful even large networks algorithms presented paper many appli cations debugging distributed program programmer may specify breakpoint condition using logic detect condition became true algorithms also used testing distributed programs condition must true valid run distributed program may specified occurrence verified important property algorithms detect even errors may manifest particular execution may different processing speeds example consider distributed mutual exclusion algorithm run may possible two processes access critical region even permission enter critical region algorithms detect scenario certain conditions described paper cooper marzullo 5 haban weigel 11 also describe predicate detection deal general predicates detection predicates intractable since involves combinatorial explosion state space example algorithm proposed cooper marzullo 5 complexity ok n k maximum number events monitored process executed n number processes fundamental difference algorithm algorithm algorithm explicitly checks possible global states whereas algorithm miller choi 19 discuss mainly linked predicates discuss detection conjunctive predicates sense useful distributed programs moreover make distinction program messages messages used detection algorithm result linked predicate detected miller chois algorithm may true debugger present may become false removed algorithms avoid problem hurfin plouzeau raynal 12 also discuss methods detecting atomic sequences predicates distributed computa tions spezialetti kearns 23 discuss methods recognizing event occurrences without taking snapshots ever approach suitable monotonic events similar stable properties overview approaches found 20 paper organized follows section ii presents logic describing unstable predicates distributed program describes notion distributed run global sequence logic specification global predicates section iii discusses necessary sufficient condition detection weak conjunctive predicates also shows detection weak conjunctive predicates sufficient detect global predicate finite state program global predicate written boolean expression local conditions section iv presents algorithm detection weak conjunctive predicate section v describes technique decentralize algo rithm section vi gives details implementation algorithms distributed debugger finally section vii gives conclusions paper ii model distributed run assume looselycoupled messagepassing system without shared memory global clock distributed program consists set n processes denoted communicating solely via asynchronous mes sages paper concerned single run r distributed program process p run generates single execution trace ri finite sequence states actions alternate beginning initial state state process defined value variables including program counter example process p generates trace i0 i0 i1 local states local actions process p three kinds actions internal send receive send action denoted send means sending message oe process p process p j receive action denoted receive means receiving message oe process p process p j assume paper messages lost altered spuriously introduced make assumptions fifo nature channels run r vector traces ri trace process p reliability messages obtain receive also define happenedbefore relation denoted states similar lamports happenedbefore relation events 1 state trace ri happenedbefore state trace rj one following holds 1 occurs ri 2 action following send message action reception message 3 exists state u one traces relation partial order states processes system result rules 2 3 definition say message path state state different processes run visualized valid errorfree process time diagram 16 example 2 consider following distributed program process var xinteger initially 7 var yzinteger initially 00 begin begin possible values program counters distributed run r given another run r 0 constructed two messages sent process p 1 received reverse order b global sequence run defines partial order set actions states simplicity ignore actions run focus states traces thus ri denotes sequence states p general many total orders consistent linearizations partial order global sequence corresponds view run could obtained given existence global clock thus global sequence sequence global states global state vector local states definition global state different chandy lamport includes states channels model channel set messages sent received yet since set deduced local states require state channels explicitly included global state denote set global sequences consistent run r linearr global sequence g finite sequence global states denoted l k global state 0 k l suffix starting l denoted g k clearly observer restricts attention single process p would observe ri stutter ri stutter ri finite sequence state ri may repeated finite number times stutter arises purposely avoided reference physical time let skt mean 6 6 global sequence run defined definition 3 g global sequence run r denoted following constraints hold restricted p stutter ri state p global state g k example 4 global sequences consistent run r example 2 given l l model distributed run global sequences assume system computation always specified interleaving local actions next global state global sequence may result multiple independent local actions c logic operators three syntactic categories logic bool lin form syntax logic follows form lin j e lin lin lin lin j lin j bool bool predicate global system state bool boolean expression defined single global state system value determined global state known example global state bool x true x could variables different processes lin temporal formula defined global sequence 3 lin means exists suffix global sequence lin true suffix 21 also use 2 dual 3 also introduced binary operator capture sequencing directly p q means exists suffixes g g j global sequence p true suffix g q true suffix g j j form defined set global sequences simply lin qualified universal existential e quantifier thus semantics logic follows lin lin e quantify set global sequences distributed run may exhibit given trace pro cess ap means predicate p holds global sequences ep means predicate p holds global sequence call formulas starting strong formulas formulas starting e weak formulas intuition behind term strong strong formula true matter fast slow individual processes system execute holds execution speeds generate trace individual process weak formula true exists one global sequence true words predicate made true choosing appropriate execution speeds various processors difficulty checking truthness global predicate arises two sources first n processes system total number global sequences global state repeated exponential n size traces secondly global state distributed across network actual run thus detection general predicate logic feasible distributed program avoid problem combinatorial explosion focus detection predicates belonging class believe captures large subset predicates interesting programmer use word local refer predicate condition involves state single process system condition easily checked process detect predicates boolean expressions local predicates following examples formulas detectable algorithms 1 suppose developing mutual exclusion algo rithm let cs represent local predicate process p critical section following formula detects possibility violation mutual exclusion particular run 2 example 4 check note true global sequence g true global sequence h algorithm detect predicate true run r even though global sequence executed may g 3 assume database application serializability enforced using two phase locking scheme 15 assume two types locks read write following formula may useful identify error implementation iii weak conjunctive predicates weak conjunctive predicate wcp true given run exists global sequence consistent run conjuncts true global state practically speaking type predicate useful bad undesirable predicates ie predicates never become true cases programmer would like know whenever possible bad predicate may become true example consider classical mutual exclusion situation may use wcp check correctness criterion never two processes critical sections time met would want detect predicate process x critical section process critical section important observe algorithms report possibility mutual exclusion violation even violated execution happened detection occur exists consistent cut local predicates true thus techniques detect errors may hidden run due race conditions importance weak conjunctive predicates conjunctive predicates form interesting class predicates detection sufficient detection global predicate written boolean expression local predicates observation shown lemma 5 let p predicate constructed local predicates using boolean connectives detected using algorithm detect pure conjunction local predicates proof first write p disjunctive normal form thus e 3 pure conjunction local predicates next observe f semantics e 3 g f semantics g f semantics e 3 g thus problem detecting reduced solving l problems detecting pure conjunction local predicates approach useful global predicate written boolean expression local predicates example consider distributed program z three different processes rewritten part weak conjunctive predicate note even global predicate boolean expression local predicates satisfied finite number possible global states rewritten disjunction weak conjunctive predicates example consider predicate x different processes local predicate depends processes however know x take values f0 1g expression rewritten equivalent disjunct expression weak conjunctive predicate observe predicates form 2bool also easily detected simply duals detected shown section paper emphasized conjunctive predicates disjunctive predicates reason disjunctive predicates quite simple detect detect disjunctive predicate e3lp 1 lp 2 lpm sufficient process p monitor lp process finds local predicate true disjunctive predicate true b conditions weak conjunctive predicates use lp denote local predicate process p lp denote predicate lp true state say occurs sequence ri aim detect whether e 3lp 1 lp holds given r assume n lp lp j another local predicate lp lp j belong process present theorem states necessary sufficient conditions weak conjunctive predicate hold theorem 6 e 3lp 1 lp true run r iff 1 lp true state j incomparable 6 j r ks proof first assume e 3lp 1 lp true run r definition global sequence 2 linearr global state g local predicates true define ri consider two distinct indices j 1 since j correspond global state j must incomparable s2 therefore 9s ks prove direction 2 proof general case similar assume exist states states 1 2 incomparable lp 1 implies message path 1 2 viceversa thus message received 2 could sent 1 message received 1 could sent 2 fig 1 illustrates thus 1 1 2 2 p1 freezes s1 p2 executes s2 2 step 1 p1 p2 execute p1 s1 p2 s2 fig 1 incomparable states producing single global state possible construct following execution global 1 let processes execute consistent run r either p 1 1 p 2 2 p 2 2 p 1 1 assume without loss generality former case holds 2 freeze p 1 1 let p 2 execute 2 possible message sent received 2 global state g true g iv detection weak conjunctive predicates2 100 110 fig 2 examples lcmvectors theorem 6 shows necessary sufficient find set incomparable states local predicates true detect weak conjunctive predicate section present centralized algorithm later see algorithm decentralized algorithm one process serves checker processes involved wcp referred nonchecker processes processes shown fig 3 check local predicates nonchecker process keeps local lcmvector last causal message vector timestamps timestamp vectors slight modification virtual time vectors proposed 617 process p j lcmvec tori 6 j message id recent message p anybody causal relationship process p j next message id p j use maintain lcmvector information require every process include lcmvector program message sends whenever process receives program message updates lcmvector taking componentwise maximum lcmvector one contained message fig 2 illustrates showing lcmvector interval whenever local predicate process becomes true first time since recently sent message beginning trace generates debug message containing local timestamp vector sends checker process one reasons algorithm practical process required send lcmvector every time local predicate detected simple observation tells us lcmvector need sent message activity since last time lcmvector sent lcmvector change value message sent received show sufficient send lcmvector message sent irrespective number messages received let locals denote local predicate true state define predicate firsts true iff local predicate true first time since recently sent message beginning trace var lcmvector array 1n integer last causal msg rcvd process 1 n firstflag boolean init true local pred boolean expression local pred tested process 2 sending send prog upon receive prog msg upon local pred true firstflag firstflag false send dbg lcmvector checker process fig 3 algorithm weak conjunctive predicates nonchecker process p id say states different processes making wcp true theorem 6 theorem 7 9s proof trivially true show symmetry sufficient prove existence 0 1 1 first state trace p 1 since recently sent message beginning trace locals 0 true 1 exists know 0 exists choice 0 1 true proof obligation show wcps 0 sufficient show ks j 1 6 j message sent 0 also j 6 0 imply contradiction therefore conclude ks j 2 j analyze complexity nonchecker processes space complexity given array lcmvector main time complexity involved detecting local predicates sequential debugger additional time required maintain time vectors every receive message worst case one debug message generated program message sent worst case message complexity om number program messages sent addition program messages include time vectors give algorithm checker process detects wcp using debug messages sent processes checker process separate queue process involved wcp incoming debug messages processes enqueued appropriate queue assume checker process gets message process fifo order note require fifo underlying computation detection algorithm needs implement fifo property efficiency purposes underlying communication fifo checker process ensure receives messages nonchecker processes fifo using sequence numbers messages checker process applies following definition determine order two lcmvectors two lcmvectors u v furthermore know processes vectors came comparison two lcmvectors made constant time let p roc ng map lcmvector process belongs required computation check lcmvector u less lcmvector v lemma 8 let states processes p p j lcmvectors u v respectively message path fore since p j updates lcmvector upon receipt message update done taking componentwise maximum know following holds furthermore since vj next message id used could seen value 6 thereby know vj uj hence following holds show first part theorem skt message path state state viceversa hence p p j therefore thus task checker process reduced checking ordering lcmvectors determine ordering states following observation critical reducing number comparisons checker process lemma 9 lcmvector head one queue less lcmvector head queue smaller lcmvector may eliminated consideration checking see wcp satisfied proof order wcp satisfied must find set lcmvectors one queue incomparable others set lcmvector head one queue q less head another queue q j know less lcmvectors q j queues increasing order head tail also later arrivals q j must greater head q hence entry q j ever incomparable head q head q may eliminated consideration checking see wcp satisfied algorithm given fig 4 initiated whenever new lcmvector received corresponding queue nonempty simply inserted queue wise exists possibility conjunctive predicate may become true algorithm checks var changed newchanged set f12mg upon recvelem p k changed changed 6 oe begin newchanged fg changed j f12m gdo begin newchangednewchanged fig newchangednewchanged fjg changed newchanged changed deleteheadq end fig 4 algorithm weak conjunctive predicates checker process incomparable lcmvectors comparing heads queues moreover compares heads queues compared earlier purpose uses variable changed set indices head queues dated loop maintains invariant done finding elements lower elements including changed means two comparable elements f1 2 mg gamma changed loop terminates changed empty point queues non empty invariant deduce heads incomparable let queues p elements queue next theorem deals complexity algorithm theorem 10 algorithm requires om 2 p comparisons proof let compk denote number comparisons required k th iteration loop let denote total number iterations loop total number comparisons equals represent value changed k th eration jchangedkj k 2 represents number elements deleted iteration loop structure forloops get therefore total number comparisons required following theorem proves complexity problem thus showing algorithm optimal 8 theorem 11 algorithm determines whether exists set incomparable vectors size chains size p makes least pmm gamma 12 comparisons proof first show case size queue exactly one ie 1 adversary give algorithm set either zero exactly one pair elements comparable adversary also chooses answer incomparable first mm gamma tions thus algorithm cannot determine set comparable pair unless asks pairs show result general p let q k denote k th element queue q adversary give algorithm q following characteristic thus problem reduces p instances problem checks elements incompara ble algorithm completely solve one instance adversary chooses instance show queues consistent answers different final outcome v decentralization detection algorithm show techniques decentralizing algorithm property p1 deduce set vectors forms antichain pairs vectors incomparable following holds 8 distinct denote condition predicate incs following theorem shows process checking incs decomposed checking smaller sets theorem 12 let u sets lcmvectors taking componentwise maximum vectors set x incs iff inct inct incu clearly true show conjunct proved similar fashion p 2 deduce 8 distinct sp roct means max p definition max p 2 also deduce 8 u means definition maxu two assertions conclude show p 2 holds ie 8 distinct belong either u true inct incu let us assume without loss generality 2 u 2 u need show tp roct roct part proved sim ilarly inct conclude tp roct max p roct maxu p roct conclude tp roct roct using theorem notions hierar chy algorithm checking wcp decentralized follows may divide set processes two groups group checker process checks wcp within group finding one sends maximum lcmvectors higher process hierarchy process checks last two conjuncts theorem clearly argument generalized hierarchy depth example 13 consider distributed program four processes let lcmvectors corresponding processes instead checking whether entire set consists incomparable vectors divide two subsets check one incomparable computation done group checker processes group higherlevel process process check strictly greater maxu first two components maxu strictly greater max last two components hence theorem 12 vectors set pairwise incomparable vi implementation utddb main application results debugging testing distributed programs incorporated algorithms distributed debugger called utddb university texas distributed debugger 14 online debugger able detect global states sequences global states distributed computation utddb consists two types processes coordinator monitor type exists one coordinator process number monitor processes number application processes underlying distributed computation coordinator process serves checker process wcp well userinterface utddb programmer accepts input programmer distributed predicates detected also reports programmer predicate detected monitor process hidden programmer monitor processes detects local predicates defined within domain application process monitor ing done single stepping program step monitor examines address space application process check simple predicates list true also responsible implement algorithms described nonchecker process section particular maintains vector clock mechanism distributed debugger delays occurrence predicate detection halting program may substantial thus program finally halted may longer state programmer interested therefore weak conjunctive predicate ut ddb gives programmer option rolling back distributed computation consistent global state predicate true coordinator uses set timestamps detected wcp predicate calculate global state sends monitors application processes execute record incoming events file monitor receives message telling roll back application process monitor restarts application process replays recorded events process reaches local state part global state weak conjunctive predicate true restart assumes nondeterminism program due reordering messages algorithms also used trace analyzer another part utddb distributed programs 4 analyzer monitors distributed program gathers enough information form distributed run described section ii approach reduces probe effect distributed program may experience detection carried program execution user ask utddb whether predicate expressed subset logic described paper ever became true currently extending algorithms detection sequences global predicates 1925 relational global predicates 24 vii conclusions discussed detection global predicates distributed program earlier algorithms detection global predicates proposed chandy lamport work stable predicates algorithms detect even unstable predicates reasonable time space message complexity experience algorithms extremely encouraging current implementation main overhead local monitor process checking local predicates providing special hardware support even overhead reduced example architectures provide special hardware support breakpoint traps certain location accessed feature used make detection local predicates form program line x efficient believe algorithms presented paper part every distributed debugger incur low overhead quite useful identifying errors program acknowledgements would like thank bryan chin mohamed gouda greg hoagland jay misra william myre pazel alex tomlinson comments observations enabled us strengthen work would also like thank bryan chin implementing offline versions algorithms greg hoagland incorporating algorithms utddb would also like thank anonymous referees meticulous review earlier version paper r distributed debugging tools heterogeneous distributed systems repeated snapshots distributed systems synchronous communication implementation csp distributed snapshots determining global states distributed systems offline debugger distributed programs consistent detection global predicates partial orders parallel debugging causal distributed break points optimal algorithms decomposed partially ordered sets concurrent regular expressions relationship petri net languages detection unstable predicate distributed programs global events global breakpoints distributed systems detecting atomic sequences predicates distributed computations computing particular snapshots distributed systems debugger distributed programs database system concepts time clocks ordering events distributed system virtual time global states distributed sys tems debugging concurrent programs breakpoints halting distributed programs detecting causal relationships distributed computations search holy grail complexity propositional linear temporal logic efficient distributed snapshots general approach recognizing event occurrences distributed computations detecting relational global predicates distributed systems detection unstable predicates debugging distributed programs tr complexity propositional linear temporal logics database system concepts repeated snapshots distributed systems synchronous communications implementation csp global events global breakpoints distributed systems partial orders parallel debugging debugging concurrent programs consistent detection global predicates detection unstable predicates debugging distributed programs concurrent regular expressions relationship petri nets optimal algorithms decomposed partially ordered sets detecting relational global predicates distributed systems detecting atomic sequences predicates distributed computations distributed snapshots time clocks ordering events distributed system detection unstable predicates distributed programs ctr vijay k garg methods observing global properties distributed systems ieee parallel distributed technology systems technology v5 n4 p6977 october 1997 sujatha kashyap vijay k garg intractability results predicate detection information processing letters v94 n6 p277282 hsienkuang chiou willard korfhage enhancing distributed event predicate detection algorithms ieee transactions parallel distributed systems v7 n7 p673676 july 1996 loonbeen chen ichen wu efficient distributed online algorithm detect strong conjunctive predicates ieee transactions software engineering v28 n11 p10771084 november 2002 punit chandra ajay kshemkalyani distributed algorithm detect strong conjunctive predicates information processing letters v87 n5 p243249 15 september karun n biyani sandeep kulkarni testing dynamic adaptation distributed systems proceedings second international workshop automation software test p10 may 2026 2007 ajay kshemkalyani finegrained modality classification global predicates ieee transactions parallel distributed systems v14 n8 p807816 august michel hurfin masaaki mizuno mukesh singhal michel raynal efficient distributed detection conjunctions local predicates ieee transactions software engineering v24 n8 p664677 august 1998 sujatha kashyap vijay k garg exploiting predicate structure efficient reachability detection proceedings 20th ieeeacm international conference automated software engineering november 0711 2005 long beach ca usa guy dumais hon f li distributed predicate detection seriesparallel systems ieee transactions parallel distributed systems v13 n4 p373387 april 2002 craig chase vijay k garg detection global predicates techniques limitations distributed computing v11 n4 p191201 october 1998 vijay k garg brian waldecker detection strong unstable predicates distributed programs ieee transactions parallel distributed systems v7 n12 p13231333 december 1996 scott stoller detecting global predicates distributed systems clocks distributed computing v13 n2 p8598 april 2000 punit chandra ajay kshemkalyani causalitybased predicate detection across space time ieee transactions computers v54 n11 p14381453 november 2005 anish arora sandeep kulkarni murat demirbas resettable vector clocks journal parallel distributed computing v66 n2 p221237 february 2006 anirban majumdar clark thomborson manufacturing opaque predicates distributed systems code obfuscation proceedings 29th australasian computer science conference p187196 january 1619 2006 hobart australia felix c grtner fundamentals faulttolerant distributed computing asynchronous environments acm computing surveys csur v31 n1 p126 march 1999
preference logic grammars addition preferences normal logic programs convenient way represent many aspects default reasoning derivation atom a1 preferred atom a2 preference rule defined a2 derived a1 although situations modelled directly using default negation often easier define preference rules add negation bodies rules first noted govindarajan et al proc internat conf logic programming 1995 pp 731746 certain grammars may easier disambiguate parses using preferences enforcing disambiguation grammar rules paper define general fixedpoint semantics preference logic programs based embedding wellfounded semantics discuss features relation previous preference logic semantics study preference logic grammars used data standardization commercially important process extracting useful information poorly structured textual data process includes correcting misspellings truncations occur data extraction relevant information via parsing correcting inconsistencies extracted information declarativity prolog offers natural advantages data standardization commercial standardizer implemented using prolog however show use preference logic grammars allow construction much powerful declarative commercial standardizer discuss detail use nonmonotonic construct preferences leads improved commercial software b introduction contextfree grammars cfgs traditionally used specifying syntax language logic generally formalism choice specifying semantics meaning logic grammars combine two notations used specifying syntactic semantic constraints variety parsing applications programming languages natural languages documents layouts several forms logic grammars researched last two decades ad89 basically extend contextfree grammars generally allow use arguments nonterminals represent semantics arguments may terms logic ii use unification propagate semantic information iii use logical tests control application production rules important problem applications resolving ambiguitysyntactic semantic example syntactic ambiguity dangling else problem programming language syntax illustrate consider following cfg rules ifthen ifthenelse statements procedural programming languages ifstmt cond stmtseq j cond stmtseq else stmtseq given sentence form cond1 cond2 assign1 else assign2 two possible parses depending upon else paired parentheses used indicate cond1 cond2 assign1 else assign2 cond1 cond2 assign1 else assign2 one redesign language avoid ambiguity example typifies form ambiguity arises settings well language ifthenelse statements general easy alter grammar avoid ambiguity involves introduction several additional nonterminals destroys clarity original ambiguous grammar also results less efficient parsing scheme ambiguous grammars usually preferred parse mind example would like pair else closest previous unpaired present paper general means stating preferences develop methodology starting particular form logic grammar called definite clause grammar dcg also consider generalization dcgs called definite clause translation grammars dctgs abr84 primary contribution paper providing modular declarative means specifying criteria used resolving ambiguity logic grammar criteria understood using concept preference hence call resulting grammars preference logic grammars plg essence plg logic grammar nonterminals one arbiter preference rules attached whenever multiple parses sentence derivable nonterminal arbiter clauses dictate preferred parse sentence definite clause grammars translated logic programs preference logic grammars translated preference logic programs introduced earlier work gjm95 gjm96 gov97 paradigm preference logic programming introduced order obtain logical means specifying optimization problems operational semantics preference logic programs constructs optimal parse keeping track alternative parses pruning parses suboptimal first provide simple examples illustrate use plgs handling ambiguities programminglanguage grammars discuss two applications preference logic grammars optimal parsing natural language parsing topics substantial research area right give brief introduction issues paper optimal parsing extension standard parsing problem costs associated different ambiguous parses string preferred parse string one least cost many applications optimal layout documents bmw92 code generation agt89 etc viewed optimal parsing problems show paper criteria laying paragraphswhich formatter would use kp81can specified declaratively using logic grammar area ambiguity resolution illustrate use plg resolving ambiguity natural language sentences using problem prepositional attachment show preference clauses provide simple elegant way expressing preferences minimal attachment right association discuss problems associated ambiguity resolution remainder paper organized follows section 2 presents preference logic grammars illustrates use ambiguity resolution programming language grammars section 3 introduces preference logic programs shows preference logic grammars translated preference logic programs section 4 illustrates use plgs optimal parsing ambiguity resolution natural language sentences finally section 5 contains conclusions directions research assume reader familiar basic concepts logic programming definiteclause grammars good introductory treatment logic programming including theory found llo87 preference logic grammars describe syntax preference logic grammars illustrate use examples programming language grammars since preference logic grammars based upon definite clause grammars dcgs briefly describe dcgs first clause grammars definiteclause grammar dcg basically extension contextfree grammar wherein nonterminal optionally accompanied one arguments purpose paper consider two forms dcg rules literal literal literal 1 literal k first form dcg rule corresponds null production literal either terminal symbol form nonterminal arguments form terms sequence zero term usual built constants variables constructors general righthand side dcg rule legal sequence prolog goals enclosed f g goal sequence may occur position literal may occur illustrate definiteclause grammar show one encode bnf section 1 assuming definitions nonterminals expr cond var ambiguous dcg follows stmtseqs stmts stmts assigns stmts ifstmts dcg also illustrates parse tree construction argument nonterminal serves carry parse tree sentence spanned nonterminal example term ifct thought representing parse tree ifthen statement term ifcte thought representing parse tree ifthenelse statement c e stand parse trees conditionpart thenpart elsepart respectively clause grammars translated definite clause logic programs straightforward way pw80 one definite clause created per dcg rule nonterminal n arguments dcg rule translated predicate n2 arguments two extra arguments carry respectively input list parsed remaining list initial prefix input list parsed two extra arguments made last two arguments predicate illustrate translated program dcg stmtseqsio stmtsio stmtseqsssssio stmtsio1 stmtseqsso1o stmtsio assignsio stmtsio ifstmtsio assignassignveio varvio1 expreo1o stmtseqto1o stmtseqto1elseo2 stmtseqeo2o preference logic grammars preference logic grammar definite clause grammar nonterminal n optionally accompanied one preference clauses form l positive negative atom form pterms p predicate form rule states sentence spanned nonterminal n two different parses parse corresponding less preferred one corresponding u provided condition given later also illustrate show one extend definite clause translation grammars preference clauses ilustrate plgs extend dcg preference clause resolve dangling else ambiguity explained section 1 resolve ambiguity need specify criterion else pairs closest previous unpaired state criterion following preference clause rule states ifthenelse statement two different parses parse corresponding tree ifcifc1te less preferred one corresponding tree ifstmtifcifc1te note specification capable correctly resolving ambiguity arbitrarily nested ifthenelse statements example might appear preference clause requiring sentence scanned twice order compute two parses need happen actual implementation specification actually commit specific parsing strategy making use memoization related technique war92 avoid reparsing phrase condc stmtseqt second rule ifstmt considered example system xsb ssw would good vehicle implementing preference logic grammars memoization capability however go implementation issues paper illustrate use multiple preference clauses consider following ambiguous definite clause grammar arithmetic expressions expid id resolve ambiguity preference clauses may used specify precedence associativity modular declarative manner ie without rewriting original grammar first two arbiter clauses specify higher precedence third clause specifies leftassociative whereas fourth clause specifies rightassociative readers familiar prolog dcgs may concerned use leftrecursion grammar memoization used circumvent possible nontermination arising leftrecursion 3 translation preference logic grammars present translation preference logic grammars preference logic programs begin brief introduction preference logic programs 31 preference logic programs preference logic program plp may thought containing two parts firstorder theory arbiter firstorder theory consists clauses one two forms 1 clauses b form p p predicate sequence terms general b could constraints clp jl87 jm94 2 clauses constraints 2 clp jl87 jm94 must satisfied clause applicable goal must read antecedents implication variables appear rhs clause existentially quantified intended meaning clause set solutions head subset set solutions body moreover predicate symbols partitioned three disjoint sets depending kinds clauses used define 1 cpredicates appear heads definite clauses bodies clauses contain cpredicates c stands core 2 opredicates appear heads optimization clauses stands optimization ground instance optimization clause instance opredicate head candidate optimal solution provided corresponding instance body clause true constraints appear j body optimization clause referred guard must satisfied order head h reduced 3 dpredicates appear heads definite clauses one goal body clauses either opredicate dpredicate stands derived opredicates arbiter part preference logic program specifies optimization criterion opredicates clauses form p opredicate l atom whose head cpredicate constraint clp essence form arbiter states p less preferred pu l formalized semantics preference logic programs earlier work refer reader gjm96 gov97 detailed exposition short preference logic programs welldefined meaning long recursion optimization clauses wellfounded locallystratified similar spirit semantics negationasfailure llo87 given possibleworlds semantics preference logic program essentially world model constraints program ordering worlds enforced arbiter clauses program introduce concept preferential consequence refer truth optimal worlds contrast logical consequence refers truth worlds optimal 2 need full generality feature translation preference logic grammars answer query g substitution g preferential consequence preference logic program hard see notions also relevant semantics preference logic grammars also provided derivation scheme called ptsldderivation stands pruned tree sldderivation efficiently computing optimal answers queries gjm96 gov97 basic idea grow sld search tree query apply arbiter clauses prune unproductive search paths ie suboptimal solutions since computing preferential consequences opposed logical consequences incur cost theorem proving general modal logic order achieve needed efficiencies termination properties preference logic grammars must augment derivation procedure memotables present two simple examples preference logic programs first naive formulation shortestpath problem second dynamicprogramming formulation problem consider following clp clauses predicate pathxycp determines p path list edges distance c node x directed pathxycexy edgexyc unlike prolog definition symbol indeed stand addition operator logical specification shortest path problem could given follows sh pathxycp pathxycp sh pathxyc1p1 sh pathxyc2p2 c2 c1 first clause example optimization clause identifies sh path optimization predicate space feasible solutions predicate subset solutions path hence use clause clause effectively says every shortest path also path second clause example arbiter clause states criterion optimization given two solutions sh path one lesser distance preferred computationally speaking search tree path first constructed solution paths suboptimal according arbiter clause pruned remaining paths form solutions sh path program dynamicprogramming formulation shortestpath problem sh distxxn0 sh sh sh distxz1c1 sh distzync2 sh sh distxync2 c2 c1 show specification shortest distance associated path specified aid extra argument program explicitly expresses optimal subproblem property dynamicprogramming algorithm recursive clause sh dist encodes fact candidate shortest paths n edges two vertices b obtained extending shortest paths edges note variable z appears righthand side clause existentially quantified therefore gets bound neighbor source vertex fact candidate shortest path n edges generated composing shortest path neighboring vertex destination edge source neighbor note formulation state shortest path obtained considering edge least cost emanating source compute shortest path furthermore using memoization avoid recomputing subproblems previous formulation problem domain knowledge monotonicity would necesary achieve similar effect example also shows need guard conditions x n 1 x read antecedents implication 32 plgs plps translation preferene logic grammar preference logic program proceeds follows 1 nonterminal n preference clause attached grammar clauses translated definite clauses case definiteclause grammars 2 nonterminal n preference clause attached introduce new nonterminal pref n number arguments n one optimization clause associated pref n defined follows pref 3 grammatical arbiter clause n form translated preference clause pref n pref nu pref nv l 4 occurrence predicate n body plg rule translated program replace n pref n nonterminals preference rules attached give rise opredicates associated definitions target plp program nonterminals depend upon nonterminals one preference rules attached give rise dpredicates target plp program briefly describe ifthenelse grammar translated plp stmtseqsio stmtsio stmtseqsssssio stmtsio1 stmtseqsso1o stmtsio assignsio stmtsio pref ifstmtsio assignassignveio varvio1 expreo1o stmtseqto1o stmtseqto1elseo2 stmtseqeo2o pref pref ifstmtifcifc1teinout pref ifstmtifcifc1teinout note introduction new predicate pref ifstmt every occurrence ifstmt right hand side grammar rule replaced corresponding instance pref ifstmt 4 applications preference logic grammars present two major paradigms preference logic grammars optimal parsing natural language parsing 41 optimal parsing clause translation grammars first briefly describe definite clause translation grammars abr84 present example optimal parsing document layout appli cation definite clause translation grammars dctgs viewed logical counterpart attribute grammars knu68 attribute grammars syntax specified contextfree rules semantics specified attributes attached nonterminal nodes derivation trees function definitions define attributes attribute grammars dctgs readily translated constraint logic programs appropriate domain jl87 vh89 jm94 general need constraint logic programs rather ordinary definiteclause programs interested interpreting functions defining attributes appropriate domain rules augment contextfree rules two ways provides mechanism associating nonterminals logical variables represent subtrees rooted nonterminal ii provide mechanism specifying computation semantic values properties trees dctgs differ attribute grammars semantics dctgs captured associating set definite clauses nonterminal nodes derivation tree distinction made dctgs inherited synthesized attributes use logical variables unify parse trees eliminates need distinction dctgs associate logical variable n nonterminal nt writing logical variable n eventually instantiated subtree corresponding nonterminal nt specify computation semantic value x property p tree n write following simple dctg ad89 specifies syntax semantics bitstrings semantics bitstring decimal equivalent note syntactic rules specified productions semantic rules specified productions bit 0 bit 1 bitstring length0 bitstring bitb bitstringb1 number bitstringb two productions nonterminal bit two bitstring toplevel nonterminal number predicates specifying semantic properties bitval length value translation dctg logic program straightforward also explained ad89 linebreaking problem show problem laying paragraphs optimally specified formalism logically paragraph sequence lines line sequence words view paragraph captured following knuth plass kp81 describe lay sequence words forming paragraph computing badness paragraph terms badness lines make paragraph badness line determined properties line total width characters make line number white spaces line stretchability shrinkability white spaces desired length line etc kp81 insists line paragraph ratio difference actual length desired length stretchability shrinkability adjustment ratio bounded captured following dctg take liberty extend syntax include interpreted function para lineline para lineline parapara line word differencedln desiredlengthdl naturallengthn adjustmentds differenced 0 stretchabilitys adjustmentds differenced 0 shrinkabilitys lineshrinkbound linestretchbound line word lineline differencedln desiredlengthdl naturallengthn adjustmentds differenced 0 stretchabilitys adjustmentds differenced 0 shrinkabilitys lineshrinkbound linestretchbound grammars specifying document structures one extremely ambigu ous given description document sequence words representing content interested parse particular property instance may interested parse sequence words para least badness brown et al bmw92 augmented attribute grammars minimization directives specified attributes minimized preferred parse similarly extend dctgs statements specify preferred parse instance linebreaking example preferred parse specified augmenting definition para follows essence plgs allow one specify optimal parsing problems succinct manner note specification commit particular parsing strategy obtaining optimal parse naive method computing best parse involves enumerating parses approach easily lead exponential complexity note linebreaking algorithm used e x kp81 constructs optimal parse polynomial time 42 natural language parsing practical use preference logic grammars lies ambiguity resolution natural languages substantial research area provide brief glimpse issues example consider following simple ambiguous definiteclause grammar verbphrasevpvn verbv nounphrasen verbphrasevpvnp verbv nounphrasen prepphrasep prepphrasepppn prepositionp nounphrasen details determiner noun verb preposition shown given sentence boy saw girl binoculars two possible parses sentnpthe boy vpverbsaw npthe girl ppwith binoculars sentnpthe boy vpverbsaw npnpthe girl ppwith binoculars wellknown prepositional attachment problem example preferred reading sentence given first parse conforms principle minimal attachment kim73 ie create simplest syntactic analysis simplicity might measured number nodes parse tree hand minimal attachment yield preferred reading sentence boy saw girl long hair instead prefer parse sentence according principle right association ie new constituent analyzed part phrase subtree construction rather part higher phrase subtree principles expressed preference clauses shown nodes inp counts number nodes parse tree p spanp returns length sentence spanned p two principles purely syntactic nature general attachment problem complex requiring semantic contextual knowledge correct resolution considerable recent interest computational linguistics community use constraints preferences example sch86 discusses preference tradeoffs attachment decisions per85 shows principles minimal attachment right association realized suitable parsing actions bottomup parser usz91 presents controlled linguistic deduction means adding control knowledge declarative grammars erb92 discusses use preference values typed feature structures resolving ambiguity choosing feature structures highest preference value present developing extension preference logic grammars formulate principled practical scheme using contextsensitive information ambiguity resolution featurebased grammar formalisms 5 conclusions research presented logicgrammar extension called preference logic grammars shown use ambiguity resolution logic grammars specifying optimal parsing problems use preferential statements logic grammars concise modular declarative although extension originally motivated extension attribute grammars specify document layout bmw92 paper shows ideas applicable broader setting many interesting avenues research first develop implementation plgs incorporating memoization pruning applications optimal parsing desirable annotate grammar information pruning suboptimal parses done earliest opportunity purpose domain knowledge additive property costs important may noted kind information generally interest applications ambiguity resolution paradigm preference logic programming originally proposed specifying optimization relaxation problems gjm96 gov97 relaxation performed constraints specifying problem solutions optimality requirements need weakened plp gjm96 encode constraint relaxation regimes given wb93 also preference relaxation regimes latter achieved notion relaxable goal following form p opredicate c cpredicate constraint clp predicate p said relaxable predicate c said relaxation criterion relaxation goal essentially optimal solutions p satisfy cu intended solutions however none optimal solutions p satisfies cu feasible set solutions p reduced adding c additional constraint arbiter applied constrained set applications document processing notion relaxation seems particularly useful instance page may consist many paragraphs optimal layout page might require paragraphs make page laid suboptimally investigating methods criteria could incorporated logic grammar formalism another possible application relaxation specifying errorrecovery strategies compilers code generation area natural language processing interested exploring preferences used resolve several semantic ambiguity issues quantifier scoping example sentence every man loves woman quantifier scoping ambiguity ie every man love woman woman different different men latter reading usually one intended reflects preference quantifier nounphrase scope one verbphrase finally also interested incremental computation strategies parsing preference logic grammars example codegeneration small change made input program compiler compute optimal code sequence program scratch document layout application formatter e x l e x etc reformat whole document change obtain new layout r clause translation grammars logic grammars code generation using tree matching dynamic programming declarative semantics document pro cessing using preference values typed feature structures exploit nonabsolute constraints disambiguation preference logic programming optimization relaxation constraint logic languages optimization relaxation logic languages constraint logic programming constraint logic programming survey seven principles surface structure parsing natural language semantics contextfree languages breaking paragraphs lines foundations logic programming new characterization attachment preferences clause grammars language analysis survey formalism comparison augmented transition networks preference tradeoffs attachment decisions proceedingsin proc xsb overview use implementation strategies adding control information declarative grammars constraint satisfaction logic programming memoing logic programs hierarchical constraint logic programming tr foundations logic programming every logic program natural stratification iterated least fixed point model wellfounded semantics general logic programs preferred answer sets extended logic programs tabling nonmonotonic programming reasoning prioritized defaults psychiatric diagnosis viewpoint computational logic ctr haifeng guo bharat jayaraman modedirected preferences logic programs proceedings 2005 acm symposium applied computing march 1317 2005 santa fe new mexico haifeng guo bharat jayaraman gopal gupta miao liu optimization modedirected preferences proceedings 7th acm sigplan international conference principles practice declarative programming p242251 july 1113 2005 lisbon portugal torsten schaub kewen wang semantic framework preference handling answer set programming theory practice logic programming v3 n4 p569607 july logic programming knowledge representationthe aprolog perspective artificial intelligence v138 n12 p338 june 2002
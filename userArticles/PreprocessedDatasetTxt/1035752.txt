detecting global predicates distributed systems clocks paper proposes framework detecting global state predicates systems processes approximatelysynchronized realtime clocks timestamps clocks used define two orderings events definitely occurred possibly occurred orderings lead naturally definitions 3 distinct detection modalities ie 3 meanings predicate held computation namely poss supidbisup possibly held definitely held inst definitely held specific global state paper defines modalities gives efficient algorithms detecting algorithms based algorithms garg waldecker alagar venkatesan cooper marzullo fromentin raynal complexity analysis shows reasonable assumptions realtimeclockbased detection algorithms less expensive detection algorithms based lamports happenedbefore ordering sample applications given illustrate benefits approach b introduction history distributed system modeled sequence events since execution particular sequence events leaves system welldefined global state history uniquely determines sequence global states system passed un fortunately distributed system without perfect clock synchronization general preliminary description work appeared 30 scott stoller stollercsindianaedu wwwcsindianaedustoller department computer science indiana university bloomington impossible process determine order events different processors actually occurred therefore process determine sequence global states system passed leads obvious difficulty detecting whether global state predicate hereafter simply called predicate held cooper marzullo proposed solution asynchronous distributed systems 6 solution involves two modalities denote poss hb initely modalities based logical time 18 embodied happened relation hb partial ordering 1 events reflects potential causal dependencies happenedbefore total order uniquely determine history restrict possibilities given predicate phi computation satisfies poss hb interleaving events consistent happenedbefore system passes global state satisfying phi computation satisfies every interleaving events consistent happenedbefore system passes global state satisfying phi cooper marzullos definitions modalities established important conceptual framework predicate detection asynchronous systems basis considerable research 8 13 4 17 32 14 5 12 practice though poss hb modalities based happenedbefore significant drawbacks many cases first many systems difficult determine happenedbefore relation happenedbefore determined process maintains vector clock requires vector timestamp components attached every message n number processes system imposes computational overhead operations per message received update vector clock generating code inserts removes vector timestamps without changing existing types programs would open worms copying entire messages inefficient difficult programs use streamoriented communication protocol provide message boundaries tcp difficulty significantly compounded since receiver might receive fragment message several messages single receive event piggybacking vector timestamps requires changing communication statements application even predicate interest involves state one module source code available part system might impossible happened determined without vector clocks processes inform monitor send events receive events provide monitor enough information determine correspondence send receive events ie receive event monitor determine send event sent received message however method 1 paper partial orderings irreflexive unless specified otherwise often significant drawbacks general determining correspondence send receive events requires piggybacking identifier eg sequence number message involves difficulties piggybacking vector timestamp 2 additional drawback method monitor must informed send events receive events vector timestamps happenedbefore relation needed suffices inform monitor events might change truth value predicate interest 3 significantly reduce amount information sent monitor second drawback detecting poss hb phi computational cost worstcase time complexity omegagamma e n e maximum number events executed process worst case occurs little communication hence causal dependencies many interleavings must explored example exponential cost seen two sample applications considered 31 namely coherence protocol spanningtree algorithm third drawback systems hidden channels 2 ie means communication messages happenedbefore accurately capture causal relationships poss hb phi accurately capture meanings possibly held definitely held paper proposes framework predicate detection systems approximately synchronized realtime clocks timestamps clocks used define two orderings events db definitely occurred pb possibly occurred roughly speaking substituting orderings happenedbefore definitions poss hb obtain definitions four new modalities two modalities based db closely analogous poss hb denote poss db obtain algorithms detecting poss db adapting algorithms garg waldecker 13 14 alagar venkatesan 1 cooper marzullo 6 modalities based pb quite different pb db partial ordering yields degenerate case analogues poss hb equivalent show single modality denote inst closely related fromentin raynals concept properly hb adapt detecting inst algorithm detecting properly detection framework applicable wide range systems since require clocks synchronized within fixed bound however quality clock synchronization affect two event orderings described therefore results even underlying communication protocol uses sequence numbers operatingsystem protection mechanisms may prevent monitoring system accessing 3 optimization explicitly incorporated algorithms easily done detection example consider inst phi informally computation satisfies inst phi iff timestamps imply instant computation predicate phi held ie iff collection local states form global state satisfying phi based timestamps definitely overlapped time suppose phi actually holds global state g persists time ffi whether inst phi holds depends quality synchronization roughly maximum difference clocks known less ffi inst phi holds otherwise cases way determine whether local states g actually overlapped time inst phi might hold quality clock synchronization affects also cost detection example consider poss db phi informally computation satisfies poss db phi iff collection local states form global state satisfying phi based timestamps possibly overlapped time larger error clock synchronization combinations local states possibly overlap general phi must evaluated combination local states thus larger error expensive detection error bounded relative mean interval relevant events ie events potentially truthify falsify phi number global states must checked linear e asynchronous case number global states must checked oe n condition error clock synchronization holds many systems localarea distributed systems protocols like ntp efficiently maintain synchronization clocks within milliseconds 26 even extremely widearea distributed systems like internet clock synchronization usually maintained within tens milliseconds 24 26 detection framework algorithms proposed designed provide basis monitoring debugging applications systems sample applications described section 7 including applications timers provide hidden channel causing detection based happenedbefore less appropriate directions future work include implementing detection algorithms described developing efficient algorithms detecting global properties depend explicitly time investigating clockbased detection sequences global states perhaps along lines temporal modalities based happenedbefore 16 3 11 related work marzullo neiger 23 discuss global property detection partiallysynchronous systems fixed bound ffl error clocks known notation paper define modalities poss hd give detection algorithms two modalities combining happenedbefore realtime ordering exploits information computation hence certainly desirable whenever feasible modifying algorithms paper take happenedbefore account straightforward exercise resulting algorithms would appropriate monitoring systems paper presents algorithms use happenedbefore three reasons first important discussed section 1 often difficult practice modify system monitor determine happenedbefore relation consequently detection algorithms depend happenedbefore limited applicability 4 second using happenedbefore enables optimizations specifically involving priority queues impossible causal ordering also used third incorporating happened would obscured presentation complexity analysis realtimebased parts algorithms novel parts contributions paper relative 23 include detection algorithms based purely realtime clocks efficient detection algorithms definition algorithm inst 23 consider modality analogous inst also 23 assumes fixed bound error clock synchronization framework allows bound vary time supports tighter bounds hence accurate monitoring results attractive feature properly hb inst monitor report single global state g satisfying phi system actually passed feature however properly hb gives useful information systems perform global ie systemwide barrier synchronization synchronization expensive rarely used contrast assuming reasonably good clock synchronization inst informative even absence barrier synchronization since inst like properly hb detected efficiently arbitrary predicates appears useful modality possibly occurred relation pb reminiscent lamports affect relation concurrent systems 20 21 relations may contain cycles overlap pb overlap interval timestamps affect overlap nonatomic events framework assumes events atomic appropriate systems messagebased communication verissimo 33 discusses uncertainty event orderings caused granularity 5 imperfect synchronization digital realtime clocks analyzes conditions uncertainty significant application describes synchronization technique suitable certain applications masks uncertainty however 33 aim general approach detecting global properties presence uncertainty 4 algorithms apply directly even programs use highlevel communication libraries eg distributed shared memory dsm library source code available detecting happenedbefore cases would difficult 5 framework accommodates granularity digital clocks using instead ts1 ts2 3 background computation single process called local computation represented finite infinite sequence local states events thus local computation form e ff events ff local states convention e 1 corresponds creation process sequence finite ends event corresponds convention termination process computation distributed system collection local computations one per pro cess computation represented function process names local computations use integers process names thus computation c local computation process ci variables j always range process names use evc stc denote sets events local states respectively computation c convenience assume events local states computation distinct following functions implicitly parameterized computation computation considered evident context event e pre denotes process e occurs local state prs denotes process passes ss denote start event terminal event respectively example computation containing local computation 1 ss 2 e 2 2 e 3 global state distributed system collection local states one per process represented function process names local states set global states computation c denoted gs c thus g gs c iff process gi local state ci define reflexive partial ordering global states occurs g 0 2 orderings defined paper including implicitly parameterized computation computation considered evident context event e interval timestamp ce interval lower endpoint model events atomic instantaneous width interval timestamp depends quality clock synchronization event occurs assume interval timestamps nondecreasing consistent order events precisely assume ts1 every event e c 1 ts2 every event e 1 immediately succeeding event e 2 process ts3 every event e 1 every event e 2 e 1 occurred e 2 c 1 various ways satisfying assumptions depending underlying clock synchronization mechanism simple yet realistic example clock synchronization algorithm never decreases value clock machines precisely machines relevant predicate detected synchronize single time server ts1ts3 hold timestamps chosen value time servers clock interval ce event e occurred thus machine take c 1 c 2 value local clock e occurred bound difference clock time servers clock e occurred systems time servers organized peer groups clientserver hierarchy ce determined appropriate combination bounds errors relevant clocks either case information needed construct interval timestamps obtained standard clock synchronization subsystems ntp 25 26 distributed time service osf dce 27 4 generic theory consistent global states predicate detection asynchronous systems based theory consistent global states cgss 2 informally global state consistent could occurred computation convenient define consistent terms ideals recall ideal partial order hs oei set 8x 2 8y hevc hb called consistent cuts 2 recall partial order set ideals ordered inclusion forms lattice 8 furthermore set cgss ordered forms lattice isomorphic lattice consistent cuts 28 2 isomorphism important consequence detection algorithms implies minimal increase respect corresponds advancing one process one event adjacent ideals hevc hb differ exactly one event hence lattice cgss explored repeatedly advancing one process one event principle underlies detection algorithms cooper marzullo 6 garg waldecker 13 14 alagar venkatesan 1 section show theory specific happenedbefore relation rather applies partial ordering events provided processwise total ie two events e 1 e 2 process e 1 occurred e 2 generalized theory underlies detection algorithms sections 5 6 definition cgss let c computation let relation evc define relation stc informal interpretation 0 ends 0 starts formally two local states concurrent respect related global state consistent respect constituent local states pairwise concurrent consis g delta thus set cgss computation c respect note cgs hb usual notion cgss definitions poss modalities poss hb asynchronous systems defined terms lattice hcgs hb generalize follows computation c satisfies poss phi iff cgs c contains global state satisfying phi defined terms paths path partial order hs finite infinite sequence 6 oe distinct elements oe1 minimal respect ii ff immediate successor 7 oeff iii oe finite oejoej maximal respect informally path hcgs c corresponds order events computation could occurred computation c satisfies every path hcgs c contains global state satisfying phi cgss ideals processwisetotal partial ordering natural correspondence cgs c ideals hevc one think ideal set events occurred executing set events leaves process local state immediately following last event process thus ideal corresponds 6 use 1based indexing sequences 7 reflexive irreflexive partial order hs oei elements x 2 2 immediate successor x iff x global state g sgi maximal element fe 2 j ig correspondence isomorphism theorem 1 every processwisetotal partial ordering evc partial order hcgs c lattice isomorphic lattice ideals hevc proof true reasons standard theory based happenedbefore 28 2 8 proof straightforward following corollary underlies detection algorithms sections 5 6 corollary 2 processwisetotal partial ordering global state g 0 immediate successor g hcgs c ideal corresponding g 0 contains exactly one event ideal corresponding g proof follows theorem 1 fact partial order one ideal immediate successor another ideal two ideals differ exactly one element detection based strong event ordering poss db instantiate generic theory section 4 partial ordering db definitely occurred defined db ordering cannot defined solely terms timestamps ce 1 ce 2 ts1 ts2 allow consecutive events process identical timestamps therefore assume process records local sequence number well interval timestamp event theorem 3 every computation c db processwisetotal partial ordering evc proof see appendix discussion section 4 db induces notion cgs db cgss g 2 cgs db local states g possibly overlapped time example figure 1 shows computation c 1 lattice hcgs db pair arcs enclosing event show endpoints interval timestamp lattice node labeled represents global state process 1 local state 1 process 2 local state 2 42 figure 1 left computation c 1 right lattice hcgs db consider paper detection algorithms passive monitor process original system sends timestamped local states new process called monitor specifically process executes event thereby terminating current local state process sends monitor message containing timestamps css ct 8 consider online detection monitor detects property soon possible algorithms offline detection monitor waits computation terminated checking whether property holds obtained special cases consider first algorithms detecting poss db restricted class predicates consider general algorithms detecting poss db 51 algorithms poss db db conjunctive predicates garg waldecker 13 14 developed efficient algorithms detecting poss conjunctive predicates phi predicate conjunctive conjunction predicates depend local state one process example x local variable process predicate x 1 conjunctive predicate conjunctive algorithms adapted straightforward way detect poss db roughly replacing comparisons based happenedbefore comparisons based db yields detection algorithms worstcase time complexity 2 e e maximum number events executed process worstcase time complexity algorithms reduced log ne exploiting total ordering numbers start reviewing garg waldeckers algorithm detecting poss hb conjunctive predicates suppose predicate interest depends 8 several straightforward optimizations possible example message might describe differences consecutive reported local states rather repeating entire local state also except initial local state suffices include local state timestamp ct since sent previous message monitor also given predicate phi events cannot possibly truthify falsify phi ignored local state process process sends monitor timestamped local states satisfying local states satisfying oe reported process monitor maintains queue q adds timestamped local state received process end q let headq denote head nonempty queue q j removed q heads queues repeatedly compared sometimes removed way heads nonempty queues pairwise concurrent point queues nonempty heads queues form cgs satisfying phi algorithm returns cgs thereby indicating poss hb queue empty monitor waits receive local states repeats procedure described worstcase time complexity 2 e one local states time local state removed q new head q compared heads queues detection poss db number comparisons reduced follows expanding definition cgs db c global state g consistent iff using fact c 2 headgi c 1 sheadgi follows ts1 ts2 one show 7 equivalent min evaluate 8 efficiently maintain two priority queues p 1 p 2 whose contents determined invariants i1 process q nonempty p 1 contains record key c 1 sheadq satellite data p 1 contains records i2 process q nonempty p 2 contains record key c 2 headq satellite data hi ptri ptr pointer record satellite data contains records recall operations priority queue p include getminp returns record hk di key k satellite data k minimal extractminp removes returns record also use priority queues analogous operations based maximal key values thus 8 equivalent k negation 9 used loop figure 2 check heads nonempty queues concurrent let possconjalg denote algorithm figure 2 computation satisfies poss db returns cgs satisfying phi analyze time complexity recall operation priority queue containing records takes olog n time constant number operations performed local state worstcase time complexity algorithm figure 2 oen log n note time complexity independent quality clock synchronization algorithm 14 detecting conjunctive phi adapted similar way detect phi predicates receiving x process add records p 1 p 2 maintain invariants i1 i2 remove record ie record lambdaptr add records p 1 p 2 maintain invariants i1 i2 endif endwhile return cgs hheadq 1 endif endif figure 2 algorithm possconjalgphi detecting poss db conjunctive predicates process sends monitor local states satisfying local predicate 52 general algorithm poss db develop online detection algorithm poss db phi adapting alagar venkatesans algorithm detecting poss hb phi nonterminating ie infinite computations 1 algorithm based procedure depthfirst search lattice cgss depthfirst exploration lattice cgss infinite computation would never backtrack thus would never visit cgss near beginning lattice algorithm lattice divided sequence sublattices l corresponding increasing prefixes computation depthfirst search used explore sublattice l i1 gammal following paragraphs describe adapt algorithm online detection poss db finding initial cgs asynchronous setting initial cgs simply contains initial local state process timed setting global state might consistent since processes might started different times theorem 4 every computation c cgs c empty hcgs c contains unique minimal element ie c unique initial cgs proof existence minimal elements lattice cgss follows immediately nonemptiness absence infinite descending chains 7 chapter 2 prove contradiction lattice cgss unique minimal element suppose cgss g 1 g 2 minimal g 1 6 g 2 let g denote meet operation lattice cgss note g 1 6 g 2 assumptions g 2 minimal g 1 6 definition g g 1 g definition g g 1 g together g 1 g contradicts assumed minimality g 1 find initial cgs exploit fact every conjunctive predicate phi computation satisfies poss db phi possconjalgphi finds returns unique minimal cgs satisfying phi proof closely analogous proof corresponding property garg waldeckers algorithm 14 corollary cgs db c empty possconjalgtrue returns initial cgs otherwise possconjalgtrue never calls return choosing sequence sublattices avoid delays detection monitor receives timestamped local state constructs largest cgs g 2 constructed local states received far done loop figure 4 cgs implicitly defines next sublattice contains exactly cgss g denote cgs constructed previous local state received ie cgs corresponding sublattice l constructing g 2 monitor depthfirst search sublattice l definition contains cgss g exploration sublattice two main steps exploration sublattice cgss cgs g 1 larger cgs ffl use procedure initstatesg compute set minimal respect cgss sublattice ffl cgs g use procedure depthfirstsearchg depthfirst search starting g fragment sublattice searches together explore entire sublattice alagar venkatesan observed initstates computed efficiently follows local state let minstates unique minimal cgs containing let succs local state occurs immediately process local state succs undefined initstatesg procedure var endif return computing minstate algorithm computing minstate similar algorithm computing initial cgs relies following property possconjalg possconjalgphi started global state g ie local states process occur gi ignored remainder computation satisfies poss db finds unique minimal cgs greater g satisfying phi global state g local state let gi 7 denote global state g except local state process simple way compute minstates call possconjalgtrue starting global state g 0 prs 7 g 0 initial cgs optimization sometimes possible consider call minstates 2 minstate previously called local state prs 2 argument optimization apply minstate computed described otherwise let 1 argument previous call minstate local state prs 2 observe 1 occurred 2 1 minstate called initstates initstates called nondecreasing chain cgss property algorithm figure 4 2 assuming shortcircuiting evaluation initstates initstatesg possconjalgtrue global state minstates 1 prs 7 instead g 0 prs 7 leads following algorithm oldi contains result previous call minstate local state process initially oldi set g 0 procedure oldprs cgs returned possconjalgtrue started oldprsprs 7 return depthfirst search fragment sublattice since cgs may multiple predecessors lattice cgss search algorithm needs efficiency mechanism ensure cgs explored straightforward approach maintain set containing cgss visited far however may expensive space time alagar venkatesan 1 proposed following clever alternative introduce total ordering idx cgss defined lexicographically smaller indexg 2 global state g indexg tuple hk gi k th local state process depthfirst search explore cgs g immediate predecessor respect g maximal among immediate predecessors g respect idx leads algorithm figure 3 cgs g predg set immediate predecessors g lattice cgss compute predg process check whether moving process back one local state yields cgs include resulting cgs set putting pieces together yields online detection algorithm figure 4 local states g 0 ie local states g 0 prs occurs handled receiving process statement even though local states might received initial cgs found recall process sends local state monitor local state ends natural db depends local states end delay detection one approach bounding reducing delay process reported event monitor recently send message monitor report still local state reporting execution skip another approach described 23 requires bound message latency instant monitor use local clock bound determine lower bound ending time last local state received process 521 complexity analyze time complexity consider separately cost invocations minstate cost operations effect process calls minstate cause possconjalg algorithm executed n times process worst procedure depthfirstsearchg phig returntrue else gi 6 g 2 consis db g maximal hs idx returntrue endif endif rof returnfalse figure 3 algorithm depthfirst search computation thus total cost calls possconjalg minstate hence total cost calls minstate oen 2 log n total cost executions loop figure 4 oen 3 since 1 evaluating loop condition takes time 2 condition evaluated one local states 2 loop body executed one local states execution takes constant time total cost executions body loop figure 4 ojcgs db since depthfirst search takes 2 time per cgs since evaluating pred takes 2 time call initstates takes 3 excluding cost calls minstate 1 evaluating takes time 2 may evaluated 2 times loop existential quantifier total cost calls initstates 4 e since initstates called per local state summing contributions conclude worstcase time complexity algorithm ojcgs db cj depends rate events occur relative error clocks simplify complexity analysis suppose 1 interval consecutive events process least 2 error clocks known 3 interval timestamp event e given c 1 value local clock machine pre e occurred every event initialization phase 0 cgs returned possconjalgtrue g 0 initial cgs local states g 0 prs occurs receiving process largest cgs initstatesg report poss db phi exit endif rof figure 4 algorithm detecting poss db e local state concurrent 3 local states process local state o3 n gamma1 cgss o3 n e cgss worstcase time complexity algorithm o3 n en 2 2 local state concurrent d4 local states process od4e e cgss worstcase time complexity algorithm od4e cases worstcase time complexity detecting poss db linear e normally much larger n contrast worstcase time complexity general algorithms detecting poss realistic complexity analysis requires considering distributions interevent times rather simply fixing minimum value specifically consider distributed computations interevent times selected normal ie gaussian distribution mean standard deviation p negative numbers selected distribution ignored simplicity continue assume fixed bound error clocks number cgss depends n e ratio cases analyzed number cgss scales linearly e illustrated graph figure 5 figure 6 plots number cgss vs n one see large number cgss increases slowly roughly linearly n small number cgss increases exponentially n cgss figure 5 number cgss vs e muepsilon muepsilon cgss figure left number cgss vs n ranging 6 50 right number cgss vs n 2 50 note vertical scales two graphs different 53 general algorithm detection algorithm phi 6 23 adapted detect phi roughly replacing condition form e 1 db algorithm divides lattice levels level local state local computation number local states preceding computation level global state g sum levels constituent local states level lattice cgss contains cgss level following 6 23 give algorithm monitor constructs one level lattice cgss time constructing one level lattice time unnecessary sometimes delays detection property construction used simplify presentation algorithm used monitor detect phi given figure 7 lowest level lattice contains initial cgs loop maintains following invariant last contains cgss reachable initial cgs without passing cgs satisfying phi line algorithm monitor considers global state g last process checks whether local state succgi concurrent local states g processes monitor waits local states already arrived monitor adds gi 7 succgi current already current cgs returned possconjalgtrue find initial cgs last fgg remove cgss last satisfy phi last current cgss immediate successors cgss last remove cgss current satisfy phi last current report figure 7 algorithm detecting db since phi could false cgss assume cost evaluating phi global state constant worstcase asymptotic time complexity algorithm equals worstcase asymptotic time complexity constructing cgs db cgs algorithm advances n processes resulting global state g consistent algorithm checks whether g already current let tm denote total cost membership checks constructing cgs db c takes thetajcgs db time tm depends data structure used implement current naive arraybased implementation check constant cost tm thetae n due cost initializing arrays worstcase time complexity algorithm thetae n n 2 9 however implementation serious disadvantage time complexity remains even actual number cgss much smaller e n typically case thus generally preferable alternatives implement current dictionary using hash table balanced trees let w c width lattice cgs db c ie maximum size level lattice balanced trees used membership check cost olog w c worstcase time complexity ojcgs db jcgs db cj w c depend rate events occur relative error clocks simplify complexity analysis introduce meanings section 521 2 o3 n e cgss w c o3 n worstcase time complexity algorithm o3 n en 2 2 od4e e cgss w c od4e worstcase time complexity od4e cases worstcase time complexity detecting linear e contrast worstcase time complexity general algorithms detecting realistic complexity analysis consider distribution interevent times bound error clocks last paragraph section 52 course number cgss still characterized figures 5 6 easy argue assumptions expected size level independent e depends fashion number cgss n thus graphs showing dependence w c n would shape graphs figure 6 6 detection based weak event ordering inst possibly occurred ordering events defined pb db using 3 induces relation pb local states interpretation pb possibly ended 0 started two local states strongly concurrent related pb local states must overlap time call elements cgs pb strongly consistent global states scgss 10 example figure 8 shows hcgs pb recall computation c 1 shown figure 1 note hcgs pb total order generally show theorem 5 computations c hcgs pb total order therefore lattice 9 online detection e known advance arrays may need resized eg doubled occasionally change asymptotic time complexity fromentin raynal call elements cgs inevitable global states 9 figure 8 lattice hcgs pb proof suppose ie suppose exist computation c two global states cgs pb c two processes j gi pb gj definition cgs pb definition cgs pb transitivity transitivity c 2 contradiction follows poss pb equivalent ie computations c predicates phi c satisfies poss pb pb phi define inst instantaneously denote modality ie poss pb pb informally computation satisfies inst phi global state g satisfying phi system definitely passes g computation theorem 1 apply pb lemma 6 pb partial ordering proof consider computation figure 9 actual orderings e 2 2 e 1 2 e 2 2 e 1 3 cannot determined interval timestamps e 1pb 2 e 2pb 2 since also e 1pb contains cycle light surprising minimal increase hcgs pb necessarily correspond advancing one process one event example consider computation c 1 figure 1 shown figure 8 two processes advance second third scgss c 1 computations minimal increase hcgs pb corresponds advance multiple events per process computation c 2 shown figure 9 local state process 2 1 definitely overlaps 1 2 part scgs process 1 advances two events consecutive scgss c 2 computation c 2 two scgss hs 1 since minimal increase hcgs pb necessarily correspond advancing one process one event algorithms section 5 cannot adapted easily detect inst algorithm detecting inst based fromentin raynals algorithm detecting properly asynchronous systems 9 10 definition properly generalized arbitrary ordering events e 2e 1e 2e 1e 1e 1e 2s 2s 2s 1s 1s 1 figure 9 computation c 2 properly computation c satisfies properly phi iff global state satisfying phi contained every path hcgs c theorem 7 properly db equivalent inst proof suffices show global state g cgs pb c iff contained every maximal path cgs db c proof based theorem igs 9 states global state g contained every maximal path hcgs hb last returns last element sequence closely analogous proof shows global state g contained every maximal path hcgs db definition db equivalent significant difference involves last local state process informally disjunct needed fromentin raynals analysis global state g f containing last local state process appears every maximal path even though system might pass g f realtime since processes might terminate different times peculiarity arise realtime timestamps used 11 need disjunct dealing specially last local state process expanding definition cgs pb c simplifying yields 11 example equivalence note hcgs pb figure 8 contains exactly cgss contained every path hcgs db figure 1 straightforward adaptation fromentin raynals algorithm detecting properly hb yields algorithm detecting inst worstcase time complexity 3 e fromentin raynals algorithm optimizations similar presented section 51 reduce log ne expanding definition cgs pb c global state g strongly consistent iff check condition efficiently introduce priority queues p 1 p 2 whose contents determined following invariants j1 process q nonempty p 1 contains record key c 1 headq satellite data hi ptri ptr pointer record satellite data contains records j2 process q nonempty p 2 contains record key c 2 sheadq satellite data p 2 contains records use p 1 p 2 define function scp efficiently tests whether heads nonempty queues pairwise strongly concurrent taking account possibility obtain countmaxp number records containing maximal value key priority queue p datahk thus following procedure makesc make strongly concurrent loops heads nonempty queues strongly concurrent procedure makesc remove record ie record lambdaptr add records p 1 p 2 maintain invariants j1 j2 endif endwhile extractminp like getmin except removes record returns optimized algorithm detecting inst appears figure 10 head2q returns second element queue q scgs g found g satisfy phi monitor starts searching next scgs advancing process j advance yields cgs ie element cgs db first process advanced eg queue q contains one element monitor waits local states reported follows definitions cgs db cgs pb advancing process yields cgs advancing process j c 1 shead2q j minimal yields cgs thus reduce time needed find process j maintaining priority queue p 3 satisfying invariant j3 process q nonempty p 3 contains record key c 1 shead2q j satellite data p 3 contains records thus line suffices take testing whether gj 7 head2q j consistent done olog n time temporarily updating p 1 p 2 process j advanced using 9 analyze worstcase time complexity summing times spent inside outside makesc iteration loop makesc takes olog n time operation priority queues takes olog n time removes one local state computation contains one local states total time spent inside makesc log ne total time spent code outside makesc also log ne since one scgss corollary theorem 7 local state considered olog n cost wait statement thus worstcase time complexity algorithm log ne receiving x process add records p 1 p 2 maintain invariants j1 j2 found true found makesc found false else found scgs global state headq g scgs g satisfies phi return g else wait exists j gj 7 head2q j cgs db remove records j p 1 add records j p 1 p 2 maintain invariants j1 j2 endif endif endwhile endif figure 10 algorithm detecting inst phi applications 71 coherence protocols coherence shared data central issue many distributed systems including distributed file systems distributed shared memory distributed databases typical invariant maintained coherence protocol one machine copy data item write mode machine valid copy data item part testing debugging coherence protocol monitor might used issue warning poss db cohrnt detected report error cohrnt detected computationally cheaper sometimes less informative alternative monitor inst cohrnt report error detected detection algorithm based happenedbefore could used instead system modified maintain vector clocks reason maintains already however coherence protocol uses timers time acts hidden channel 2 ie means communication messages detection based happenedbefore might yield less accurate results timers used coherence protocols ffl obtain lock broadcasting request lock conflicting announcement received within appropriate time interval granting oneself lock ffl release lock associating finite lifetime lock lock called lease 15 lifetime expires processes know without communication lock released example resource allocation algorithm 19 section 51 uses timers ways techniques use timers instead messages synchronization detection based happenedbefore less appropriate example release lock one process acquisition lock another process need related happenedbefore poss hb cohrnt may detected even coherence maintained poss db cohrnt would detected clockbased monitoring useful even coherence protocols provide weaker guarantees cohrnt example sun network file system nfs 29 section 1762 file information cached timers used limit staleness cached information needed timer expires client asks server whether cached information still valid since lockfree approach enforce onecopy filesharing semantics traditional unix useful monitor system detect often violations onecopy semantics seen applications example detection algorithm inst easily adapted count instead detect scgss satisfying predicate process reading cached information cache contains recent version information nfs lifetime cached data typically tens seconds three orders magnitude larger typical clock synchronization error lan approach detect violations onecopy semantics 72 concurrency control distributed transactions leases also used concurrency control distributed database systems reduce number messages needed commit readonly transactions described 22 section 7 idea readonly transaction acquires leases uses data objects transaction completes leases expires coordinator commits transaction without communication part testing debugging system one might use monitor detect violations invariant transaction commits holds locks objects uses since commit events expirations leases may unrelated happenedbefore detection based poss hb may report violations even violation occurred detection based realtime clocks would report violation r techniques tackle state explosion global predicate detection local temporal predicates distributed systems detection global predicates techniques limitations consistent detection global predicates introduction lattices order reachability analysis distributed executions inevitable global states concept detect unstable properties distributed computations observer independent way characterizing detecting set global states seen observers distributed computation efficient detection channel predicates distributed systems detection weak unstable predicates distributed programs detection strong unstable predicates distributed programs efficient faulttolerant mechanism distributed file system consistency detecting atomic sequences predicates distributed computations linear space algorithm online detection global predicates using time instead timeout faulttolerant systems mutual exclusion problem part ia theory interprocess com munication interprocess communication part 1 practical uses synchronized clocks distributed systems detection global state predicates time synchronization network time protocol network time protocol version specification improved algorithms synchronizing computer network clocks detecting causal relationships distributed computations search holy grail operating system concepts detecting global predicates distributed systems clocks efficient symbolic detection global properties distributed systems faster possibility detection combining two approaches tr using time instead timeout faulttolerant distributed systems mutual exclusion problem leases efficient faulttolerant mechanism distributed file cache consistency practical uses synchronized clocks distributed systems consistent detection global predicates introduction osf dce rev 10 detecting atomic sequences predicates distributed computations local temporal predicates distributed systems improved algorithms synchronizing computer network clocks specification verification dynamic properties distributed computations detection strong unstable predicates distributed programs shared global states distributed computations efficient detection channel predicates distributed systems efficient distributed detection conjunctions local predicates consistent global states distributed systems realtime communication time clocks ordering events distributed system operating system concepts 4th ed detection weak unstable predicates distributed programs detection global state predicates faster possibility detection combining two approaches detecting global predicates distributed systems clocks reachability analysis distributed executions techniques tackle state explosion global predicate detection efficient symbolic detection global properties distributed systems global predicates rough real time characterizing detecting set global states seen observers distributed computation ctr ajay kshemkalyani finegrained modality classification global predicates ieee transactions parallel distributed systems v14 n8 p807816 august
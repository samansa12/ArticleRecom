distributed streams algorithms sliding windows paper presents algorithms estimating aggregate functions sliding window n recent data items one streams results includeolfor single stream present first egrapproximation scheme number 1s sliding window optimal worst case time space also present first egr sum integers 0r sliding window optimal worst case time space assuming r polynomial n algorithms deterministic use logarithmic memory wordsin contrast show deterministic algorithm estimates within small constant relative error number 1s sum integers sliding window union distributed streams requires ohgrn space present first randomized egrsgrapproximation scheme number 1s sliding window union distributed streams uses logarithmic memory words also present first egrsgrapproximation scheme number distinct values sliding window distributed streams uses logarithmic memory wordsolour results obtained using novel family synopsis data structures b introduction urry recent work designing effective algorithms estimating aggregates statistics data streams 1 2 3 4 5 6 8 9 11 12 14 15 16 17 18 19 25 due importance applications network monitoring data warehousing telecommunica tions sensor networks work focused almost entirely sequential context data stream observed single party figure 1 depicts example data stream data item either 0 1 hand many applications multiple data sources generating stream network monitoring telecommunications example nodeperson network potential source new streaming data large retail data warehouse retail store produces stream items sold model scenarios previously proposed distributed streams model 13 number data streams stream observed single party aggregate computed union streams moreover many real world scenarios eg marketing trac engineering recent data important example telecommunications call records generated continuously customers processing done recent call records model scenarios datar et al 4 recently introduced sliding windows setting data streams aggregates statistics computed sliding window n recent items data stream paper studies sliding windows setting single stream distributed stream models improving upon previous results settings order describe results rst describe models previous work detail 11 sequential distributed streams goal sequential distributed algorithm data streams approximate function f minimizing 1 total workspace memory used parties 2 time taken party process data item 3 time produce estimate ie query time many functions sequential distributed data streams require linear space compute exactly attention focused nding either approximation scheme approximation scheme dened follows definition 1 approximation scheme quantity x randomized procedure given positive computes estimate x position position 79 1rank 42 43 44 figure 1 example data stream bits position stream position rank among 1bits 1rank computed stream processed within relative error probability least 1 ie pr deterministic procedure given positive 1 computes estimate whose worst case relative error algorithms sliding window single stream datar et al 4 presented number interesting results estimating functions sliding window single stream fundamental problem consider determining number 1s sliding window call basic counting problem stream figure 1 example number 1s current window 39 recent items 20 presented approximation scheme basic counting uses 1 log 2 n memory bits workspace processes data item o1 amortized olog n worst case time produce estimate current window time also prove matching lower bound space demonstrated importance problem using algorithm building block number functions sum bounded integers lp norms restricted model improve upon results presenting approx imation scheme basic counting matches space query time bounds improving peritem processing time o1 worst case time also present approximation scheme sum bounded integers sliding window improves worst case peritem processing time olog n o1 improved algorithms use family small space data structures call waves example wave basic counting given figure 2 data stream figure 1 basic shape suggestive ocean wave break xaxis 1rank extends right new 1bits arrive shall see additional stream bits arrive wave retains basic shape moving right crest wave always largest 1rank thus far algorithms distributed streams distributed streams model 13 party observes stream limited workspace communicates parties estimate requested specif ically produce estimate party sends message referee computes estimate model reects setup used commercial network monitoring products data analysis frontend serves role referee among results 13 approximation scheme number 1s union distributed streams ie bitwise streams using 1 log1 log n memory bits per party n length stream ii approximation scheme number distinct values collection distributed streams using 1 log1 log r memory bits values 0r algorithms use coordinated sampling stream sampled random positions given sampling rate party stores positions 1bits sample stored 1bits exceed target space bound sampling probability reduced sample ts smaller space sliding windows considered paper combine idea wave coordinated sampling store wave consisting many random samples stream samples contain recent items sampled high probability containing older items sampled lower probability obtain approximation scheme number 1s positionwise union distributed streams sliding window also obtain approximation scheme number distinct values sliding windows single distributed streams scheme uses logarithmic memory words per party algorithms propose distributed streams model stored coins setting 13 parties share string unbiased fully independent random bits bits must stored prior observing streams space store bits must accounted workspace bound previous works streaming models eg 1 5 6 8 18 19 studied settings stored coins stored coins dier private coins eg studied communication complexity 21 23 24 random string stored parties 12 summary contributions contributions paper follows 1 introduce family synopsis data structures called waves demonstrate utility data stream processing sliding windows setting 2 present rst approximation scheme basic counting single stream optimal worst case space processing time query time specif ically given accuracy matches space bound o1 query time datar et al 4 improving peritem processing time o1 amortized olog n worst case o1 worst case 3 present rst approximation scheme sum integers 0r sliding window single stream optimal worst case space assum ing r polynomial n processing time 8 4 2 1 44 67 91847284 9199 window figure 2 deterministic wave example window query 39 xaxis shows 1ranks yaxis level labeled 2 query time specically improves peritem processing time 4 o1 amortized olog n worst case o1 worst case 4 show contrast single stream case deterministic algorithm estimate number 1s sliding window union distributed streams within small constant relative error unless uses space 5 present rst randomized approximation scheme number 1s sliding window union distributed streams uses logarithmic memory words use building block rst approximation scheme number distinct values sliding window distributed streams uses logarithmic memory words remainder paper organized follows section presents comparisons previous related work section 3 section 4 present results using deterministic randomized resp wave synopsis finally section 5 shows techniques used various functions sliding window distinct values counting nth recent 1 2 related work paper introducing sliding windows setting 4 authors gave algorithm basic counting problem uses exponential histograms exponential histogram maintains information recently seen items less old items none items outside window last n items specically k0 recent 1s assigned individual buckets k1 next recent 1s assigned buckets size 2 k2 next recent 1s assigned buckets size 4 1s within last n items assigned bucket bucket eh stores size power 2 position recent 1 bucket k last bucket either 1 upon receiving new item last bucket discarded position longer falls within window new item 1 assigned new bucket size 1 makes two least recent buckets size 1 merged form bucket size 2 k1 large two least recent buckets size 2 merged resulting cascading log n bucket merges worst case shall see approach using waves avoids cascading previous paper 13 formalized distributed streams model presented several approximation schemes aggregates distributed streams also compared power distributed streams model previously studied merged streams model eg 5 19 data streams arrived party interleaved arbitrary order algorithm flajolet martin 7 variant due alon matias szegedy 1 estimate number distinct values stream also number 1s bit stream constant relative error 1 algorithm works distributed streams model adapted sliding windows 4 two results know extend algorithm work arbitrary relative error trevisan 25 baryossef et al 3 1 trevisans algorithm extended distributed streams quite easily cost extending sliding windows clear olog1 instances algorithm using dierent hash functions must maintain 1 smallest distinct hashed values sliding window n values assuming hashed values random maintaining minimum value sliding window takes olog n expected time 4 know extend algorithm 3 sliding windows addition space time bounds single streams worse however algorithm made list ecient 3 quickly survey recent related work frameworks studying data synopses presented 12 along survey results algorithms computing many dierent functions data stream observed single party maintaining histograms 16 maintaining signicant transforms data used answer aggregate queries 14 computing correlated aggregates 9 babcock et al 2 considered problem 1 datar et al 4 also reported extension arbitrary relative error sliding window single stream using trevisan approach 20 maintaining uniform random sample specied size sliding window recent elements communication complexity models 22 parties unlimited time space process respective puts simultaneous 1round communication complexity results often related distributed streams model lower bounds 1round communication complexity certainly carry directly none previous papers use wavelike synopses 3 deterministic waves section rst present new approxima tion scheme number 1s sliding window single stream present new approx imation scheme sum bounded integers sliding window single stream finally consider distributed streams three natural denitions sliding window streams show small space deterministic schemes improve performance two scenarios third deterministic approximation scheme obtain sublinear space 31 basic wave begin describing basic wave show yields approximation scheme basic counting problem sliding window prespecied maximum window size n basic wave somewhat wasteful terms space bound processing time query time consider data stream bits desired positive 1 simplify notation assume throughout 1 integer maintain two counters pos current length stream rank current number 1s stream equivalently 1rank recent 1 wave contains positions recent 1s stream arranged dierent levels wave dlog2ne levels contains positions 1 recent 1bits whose 1rank multiple 2 2 figure 2 depicts basic wave data stream figure 1 3 48 gure levels level labeled contains positions recent 1bits whose 1ranks 0 modulo 2 1ranks given xaxis given wave estimate number 1s window size n n follows let estimate number 1s stream positions pos steps 1 let p1 maximum position stored wave less p2 minimum position stored wave greater equal exact answer let r1 r2 1ranks p1 p2 respectively 2 return otherwise r r 1 r 2for example given window query depicted figure 2 simplify description describe throughout steady state wave initially fewer 1bits wave stores noted earlier actual number 1s window 20 indeed lemma 1 estimation procedure returns estimate x within relative error actual number 1s window proof level contains 1 stored positions stream whose 1ranks 2 apart thus regardless current rank earliest 1rank level rank 2 thus dierence rank earliest 1rank level 1 least dierence 1ranks least large dierence positions follows p1 exists let j smallest numbered level containing position p1 know number 1s window rank r2 1 rank r1 example 50 321 50 24 figure 2 thus r2 return exact answer assume returning midpoint range guarantee absolute error r 2 r 1 construction 2 j gap r1 next larger position r2 thus absolute error estimate 2 j 1 bound relative error show positions level j 1 contained window includes least 2 j 1 1s let r3 earliest 1rank level j 1 position p1 level j 1 r1 r3 since r2 smallest 1rank wave larger r1 r2 r3 moreover argued r3 rank therefore actual number 1s window least rank r2 1 rank r3 thus relative error less 1 note proof readily extends beyond steady state case level fewer 1 positions contain position less hence serve role level j 1 32 improvements show improve basic wave order obtain optimal deterministic wave sliding window size n let n 0 smallest power 2 greater equal 2n first use modulo n 0 counters pos rank store positions wave modulo n 0 numbers takes log n 0 bits regardless length stream next discard expire positions n pos never used would create ambiguity modulo n 0 arith metic keep track largest 1rank discarded r1 smallest 1rank still wave r2 number 1s sliding window size n answered o1 time processing 0bit takes constant time processing 1bit takes ologn worst case time o1 amortized time new 1bit stored level 1rank multiple 2 improvements used eh synopsis introduced datar et al 4 obtain bounds however deterministic wave synopsis quite dierent eh synopsis steps used dierent signicantly decrease peritem processing time o1 worst case follows instead storing single position multiple levels store position maximum level shown figure 3 3 levels 3 gure explicitly discarded positions 8 4 2 1 44 7672 figure 3 optimal deterministic wave xaxis shows 1ranks yaxis level labeled 2 positions level 1 store 1 1e positions levels may store fewer positions discard expired positions wave positions level stored xed length queue called level queue time new position added level position tail queue removed assuming queue full example using circular buer queue new head position simply overwrites next buer slot maintain doubly linked list positions 1bits wave increasing order positions evicted tail level queue spliced list new stream item arrives check head sorted list see head needs expired finally observed 4 set positions sorted sequence numbers 0 n 0 storing dierence modulo n 0 consecutive positions instead absolute positions reduce space 1 logn log n bits 1 log 2 n bits figure 4 summarizes steps deterministic wave algorithm putting altogether theorem 1 algorithm figure 4 approx imation scheme number 1s sliding window size n data stream using 1 log 2 n bits stream item processed o1 worst case time time instant provide estimate o1 time proof sketch proof relative error follows along lines proof lemma 1 set positions improved wave superset set positions basic wave wave level step 3a position leastsignicant 1bit rank numbering 0 assuming constant time op eration time bounds follow discussion 4 space level queues updated place block memory used throughout hence linked list pointers osets block fullsized pointers space bound follows space bound optimal matches lower outside size order show full levels positions less pos largest expired 1rank 4 show determine wave level constant time even weaker machine model explicitly support operation constant time upon receiving stream bit b 1 increment pos note additions comparisons done modulo n 0 smallest power 2 greater equal 2n 2 head p r linked list l expired ie discard l tail queue store r largest 1rank discarded 3 increment rank determine corresponding wave level j ie largest j rank multiple 2 j b level j queue full discard tail queue splice l c add pos rank head level j queue tail l answering query sliding window size n 1 let r1 largest 1rank discarded r1 x rank exact answer let r2 1rank head linked list l l empty exact answer 2 return otherwise r r 1 r 2 figure 4 deterministic wave algorithm basic counting single stream bound datar et al 4 randomized deterministic algorithms computing wave level weaker machine model step 3a figure 4 requires computing least signicant 1bit given number machine model explicitly support operation constant time naive approach would examine bit rank one time desired position found takes log n worst case time rank n 0 bits instead store log n 0 wave levels associated sequence array eg f0 takes olog n log log n bits also store counter log n 0 log log n 0 bits initially 1 1bits received desired wave level next element array rst 1bit reaching end array property last log log n 0 bits rank 0 desired wave level log log n 0 plus position least signicant 1bit numbering 0 increment return cycling array correctly computes wave level step moreover note cycling array log n 0 steps need know least signicant 1bit thus interleaving cycling ii search bits determine wave levels o1 worst case time basic counting window size n n algorithm figure 4 achieves constant worst case query time sliding window size n sliding window size n n single wave used give estimate basic counting problem within relative error following two steps outlined basic wave section 31 however query time window sizes less n 1 logn worst case must search linked list l order determine p1 p2 matches query time bound eh algorithm 4 33 sum bounded integers deterministic wave scheme extended handle problem maintaining sum last n items data stream item integer 0r datar et al 4 showed extend eh approach obtain approximation scheme problem using 1 log n log r buckets log n log r bits o1 query time log r log n amortized olog n log r worst case peritem processing time also presented matching asymptotic lower bound number bits certain weak assumptions relative sizes n r show achieve constant worst case peritem processing time using number memory words query time number bits 1 log nlog r 2 slightly worse eh bound r superpolynomial n algorithm depicted figure 5 sum sliding window range 0 n r let n 0 smallest power 2 greater equal 2nr maintain two modulo n 0 counters pos current length total running sum levels algorithm follows general steps algorithm figure 4 instead storing pairs p r store triples p v z v value data item needed value stored item always 1 z partial sum item equivalent 1rank sums answering query know window sum total z2 v2 total z1 return midpoint interval key insight algorithm suces store item level j 2 j largest power 2 divides number total total naively one would mimic basic counting wave viewing value v v items value 1 would take worst case time process item datar et al 4 reduced log r time directly computing eh resulting inserting v items value 1 however single item stored olog n log r eh buckets contrast upon receiving stream value v 2 0r 1 increment pos note additions comparisons done modulo n 0 2 head p v 0 z linked list l expired ie p pos n discard l tail queue store z largest partial sum discarded 3 v 0 determine largest j number total total v multiple 2 j add v total b level j queue full discard tail queue splice l c add pos v total head level j queue tail l answering query sliding window size n 1 let z1 largest partial sum discarded l z1 return total exact answer let p v2 z2 head linked list l l empty return exact answer 2 return x total figure 5 deterministic wave algorithm sum sliding window store item enables o1 time bound challenge quickly compute wave level step 3a show o1 time first observe desired wave level largest position j numbering 0 number interval 0s positions less j hence multiple 2 j second observe 1 dier bit position j bit changes 1 0 point total total largest thus j position mostsignicant bit 0 total 1 total v accordingly let f bitwise complement total let bitwise f g desired wave level position mostsignicant 1bit h ie blog hc 5 putting altogether theorem 2 algorithm figure 5 approx imation scheme sum last n items data stream item integer 0r uses 1 log n log r memory words memory word olog n log r bits ie suciently large hold item window size item processed o1 worst case time time instant provide 5 weaker machine model support operation h constant time use binary search nd desired position ologlog n log r time follows let w word size b bit mask comprising w 1s followed w 0s begin checking zero left shift b wpositions recurse otherwise right shift b wpositions recurse estimate o1 time proof sketch purposes analyzing approximation error reduce wave equivalent basic wave basic counting problem follows triple p v z sums wave pair p z 0 basic wave z stored levels l z 0 multiple 2 l also add pair p1 z1 z1 largest partial sum discarded sums wave algorithm levels l 0 z 0 multiple next level discard recent 1 level let minimum level containing p1 adapting argument proof lemma 1 shown 1 regardless current rank earliest 1rank level 2 j gap r1 next larger position r2 3 positions level contained window know window sum total z2 v2 total z1 since take midpoint absolute error x z 2 v 2 z 1 gap z2 v2 z1 gap r1 r2 basic wave thus 2 absolute error 2 j 1 moreover 1 3 actual window sum least thus relative error less 1 space time bounds immediate given discussion perform step 3a constant time 34 distributed streams consider three natural denitions sliding window collection 2 distributed streams illustrated basic counting problem 1 seek total number 1s last n items streams n items total 2 single logical stream split arbitrarily among parties party receives items include sequence number logical stream seek total number 1s last n items logical stream 3 seek total number 1s last n items positionwise union logical streams deterministic wave used answer sliding windows queries collection distributed streams rst two scenarios rst scenario apply single stream algorithm stream answer query party sends count referee simply sums answers individual count within relative error total second scenario similarly reduced single stream problem issue party knows latest sequence number stream overall latest waves may contain expired positions thus answer query party sends wave referee computes maximum sequence number parties uses wave obtain estimate resulting window sums result individual estimate within relative error recall discussion end section 32 total improving single stream performance previous work improved distributed streams performance two scenarios however third scenario problematic denote union counting problem problem counting number 1s positionwise union distributed data streams stream represents characteristic vector set size union sets present next linear space lower bound deterministic algorithms problem considering randomized algorithms section 4 lower bound deterministic algorithms show following lower bound deterministic algorithm union counting problem guarantees small constant relative error theorem 3 deterministic algorithm guarantees constant relative error 1for union counting problem requires n space nbit streams even parties sliding window proof proof contradiction suppose algorithm existed approximating union counting within relative error 1using space less n attempted maximize constants let b two parties sees data stream x b sees data stream x length n n even query request occurs streams observed suppose x exactly n ones zeroes note restricted scenario exact answer union counting problem n hxy hamming distance x possible message referee c let sm denote set inputs sends c since workspace n bits number distinct messages could send c 2 n number possible inputs n using pigeonhole principle conclude exists message sends c relative error exact answer n absolute error estimate produced algorithm n claim two inputs sm hamming distance greater 4n proof contradiction suppose two inputs x1 x2 sm hx1 x2 4n consider two runs algorithm rst second runs referee c gets pair messages outputs estimate z absolute error cases n equation 1 z n z n 1 given nbit input exactly n 2 1s number nbit inputs exactly n1s hamming distance k k even number n2 combinations kout n0s ipped 1s kout n1s ipped 0s inputs odd distances thus number inputs hamming distance k 4 1 claim messages sends c choosing 1in equation 2 choosing suitably large follows equation 3 4n obtain contradiction completes proof sum bounded integers sum bounded integers problem scenarios 1 2 straightforward applications single stream algorithm scenario 3 union means take positionwise sum problem reduces rst scenario union means take positionwise maximum lower bound applies number 1s union special case sum positionwise maximum linear space lower bound deterministic algorithms theorem 3 motivation considering randomized waves introduced next section 4 randomized waves similar deterministic wave randomized wave contains positions recent 1s data stream stored dierent levels level contains recently selected positions 1bits position selected level probability 2 thus main dierence deterministic randomized waves level deterministic wave selects 1 every 2 1bits regular intervals whereas randomized wave selects expected 1 every 2 1bits random intervals also randomize wave retains positions per level 41 basic randomized wave begin describing basic randomized wave show yields approximation scheme union counting sliding window prespecied maximum window size n sketch proof approximation guarantees uses main error analysis lemma 13 finally show time space bounds let n 0 minimum power 2 least 2n let desired error probability maintains basic randomized wave stream consisting one level use pseudorandom hash function h map positions levels according exponential distribution 12 h computed follows consider numbers members eld preprocessing step choose q r uniformly independently random g store party order compute hp party computes party receiving stream bit b 1 increment pos note additions comparisons done modulo n 0 2 discard position p tail queue expired ie p pos n 3 parties use function h level l queue q j l full discard tail q j l b add pos head q j l answering query sliding window size n n party observed pos bits 1 party j sends wave fq referee let max0 pos pos desired window 2 j minimum level tail q j l j position p 3 let l max j1 l j let u union positions q1 l 4 return ju w j figure randomized wave algorithm union counting sliding window streams operations performed g represent x dbit vector hp largest signicant bits x zero ie 0d two properties h use 1 x distributed uniformly g hence probability hi equals l l exactly 12 l1 2 mapping pairwise independent ie distinct p1 p2 pr k2g hash function used 13 except domain range sizes depend maximum window size n entire stream length steps maintaining randomized wave summarized top half figure 6 1bit arriving position p selected levels hp sample level stored queue contains c 2 recent positions selected level 36 constant determined analysis attempted minimize c consider queue q j l whose tail earliest element position q contains 1bits interval pos whose positions hash value greater equal l call range q j l move level l l 1 range may increase never decrease window size n queues lower numbered levels may ranges fail contain window move higher levels high probability nd level whose range contains window bottom half figure 6 summarizes steps answering query receive query number 1s interval initially selects lowest numbered level l j range q contains w step 2 let l maximum levels parties thus range q j l contains w implies queue contains positions 1bits w stream hash value least l take union positions queues form queue level l positionwise streams step 3 algorithm returns number positions queue fall within window w scaled factor 2 l step 4 lemma 2 algorithm figure 6 returns estimate union counting problem sliding window size n n within relative error probability greater 23 proof level l dene b maintains positions recent 1s j l consider size overlap j l w large small l probability selecting 1bit w j l 12 l decreases l increases overlap level l greater c 2 w contains position among c 2 recent positions j l hand overlap less equal c 2 range q contains w thus l j level selected p j minimum level js j l w j c 2 words progressively halving sampling probability level number points overlap less equal c 2 random process analyzed previous paper 13 though dierent scenario thus lemma follows lemma 1 13 taking median olog1 independent instances algorithm get desired approximation scheme theorem 4 estimation procedure approximation scheme union counting problem sliding window size n using log1 log 2 n bits per party time process item dominated time expected olog1 nite eld operations proof olog1 instances olog n queues o1 2 positions position olog n bits also instance hash function parameters q r olog n bits note approximation guarantees hold regardless number parties peritem processing o1 expected time per instance expected number levels new position added step 3 bounded 2 likewise expected number levels position ever bounded 2 thus scanning tails queues levels looking p step 2 takes constant expected time 42 improvements query time query time estimation procedure time referee receive process ot log1 log n memory words queries window size n could easily keep track minimum level l j range q contains window constant processing time overhead query requested determining l referee retains positions p queues fall within window hp l avoid recomputing hp hp could stored queues containing p way referee computes q j l w explicitly receiving q j l party p j takes union retained positions returns estimate x reduces query time ot 2 time per instance preserving bounds 5 extensions number distinct values minor modica tions randomized wave algorithm used estimate number distinct values sliding window distributed streams item selected levels sample stored ordered pair p v v value seen stream p position recent occurrence value updated every time value appears stream sample level l stores c pairs recent positions sampled level note contrast union counting scheme hash function hashes value item rather position party maintains pos length observed stream also maintains doubly linked list pairs wave ordered position list lets party discard expired pairs item v arrives insert pos v levels hv v already present wave update position determine presence value wave use additional hash table hashed items value contains pointer occurrence value doubly linked list updating values position requires moving corresponding pair current position tail list done constant time values position updated levels belongs straightforward argument shows peritem processing done constant expected time value belongs expected constant number levels produce estimate party passes wave referee referee constructs wave union computing levelwise union waves ceives resulting wave used estimation perform olog1 independent instances algorithm take median space bound approximation guarantees follow directly arguments previous section putting altogether theorem 5 estimation procedure approximation scheme number distinct values sliding window size n distributed streams uses log1 log n log r bits per party values 0r peritem processing time dominated time expected olog1 nite eld operations handling predicates note algorithm distinct values counting stores random sample distinct values sample used answer complex queries set distinct values eg many even distinct values predicate evenness known query time order provide approximation scheme ad hoc predicate selectivity least ie least fraction distinct values satisfy predicate store sample size 1 level increasing space bound factor 1 problems without sliding windows studied 10 nth recent 1 use wave synopsis obtain approximation scheme position nth recent 1 stream follows instead storing 1bits wave store 0s 1s thus items level l 2 l positions apart l 1s apart addition keep track 1rank 1bit closest item wave rest algorithm similar basic counting scheme note need log 2 bits upper bound window size needed order contain n recent 1s problems improved time bounds basic counting sum single stream lead improved time bounds problems reduce problems described 4 example approx imation scheme sliding average readily obtained running sum count algorithms targeting relative error 6 r space complexity approximating frequency moments sampling moving window streaming data reductions streaming algorithms maintaining stream statistics sliding windows approximate l 1 testing spotchecking data streams probabilistic counting algorithms data base applications approximate l p computing correlated aggregates continual data streams distinct sampling highlyaccurate answers distinct values queries event reports new samplingbased summary statistics improving approximate query answers synopsis data structures massive data sets estimating simple functions union data streams clustering data streams computing data streams stable distributions personal communication randomized oneround communication complexity communication complexity private vs common random bits communication complexity public vs private coin ips one round communication games note counting distinct elements streaming model tr probabilistic counting algorithms data base applications private vs common random bits communication complexity public vs private coin flips one round communication games extended abstract communication complexity new samplingbased summary statistics improving approximate query answers space complexity approximating frequency moments randomized oneround communication complexity synopsis data structures massive data sets testing spotchecking data streams extended abstract computing correlated aggregates continual data streams spaceefficient online computation quantile summaries estimating simple functions union data streams datastreams histograms reductions streaming algorithms application counting triangles graphs sampling moving window streaming data maintaining stream statistics sliding windows surfing wavelets streams distinct sampling highlyaccurate answers distinct values queries event reports approximate lpdifference algorithm massive data streams approximate l1difference algorithm massive data streams clustering data streams stable distributions pseudorandom generators embeddings data stream computation ctr linfeng zhang yong guan variance estimation sliding windows proceedings twentysixth acm sigmodsigactsigart symposium principles database systems june 1113 2007 beijing china edith cohen martin strauss maintaining timedecaying stream aggregates proceedings twentysecond acm sigmodsigactsigart symposium principles database systems p223233 june 0911 2003 san diego california michael h albert alexander golynski angle hamel alejandro lpezortiz srinivasa rao mohammad ali safari longest increasing subsequences sliding windows theoretical computer science v321 n23 p405414 august 2004 abhinandan das sumit ganguly minos garofalakis rajeev rastogi distributed setexpression cardinality estimation proceedings thirtieth international conference large data bases p312323 august 31september 03 2004 toronto canada edith cohen haim kaplan efficient estimation algorithms neighborhood variance moments proceedings fifteenth annual acmsiam symposium discrete algorithms january 1114 2004 new orleans louisiana brain babcock mayur datar rajeev motwani liadan ocallaghan maintaining variance kmedians data stream windows proceedings twentysecond acm sigmodsigactsigart symposium principles database systems p234243 june 0911 2003 san diego california edith cohen martin j strauss maintaining timedecaying stream aggregates journal algorithms v59 n1 p1936 april 2006 suman nath phillip b gibbons srinivasan seshan zachary r anderson synopsis diffusion robust aggregation sensor networks proceedings 2nd international conference embedded networked sensor systems november 0305 2004 baltimore md usa sumit ganguly counting distinct items update streams theoretical computer science v378 n3 p211222 june 2007 l k lee h f ting maintaining significant stream statistics sliding windows proceedings seventeenth annual acmsiam symposium discrete algorithm p724732 january 2226 2006 miami florida arvind arasu gurmeet singh manku approximate counts quantiles sliding windows proceedings twentythird acm sigmodsigactsigart symposium principles database systems june 1416 2004 paris france izchak sharfman assaf schuster daniel keren geometric approach monitoring threshold functions distributed data streams proceedings 2006 acm sigmod international conference management data june 2729 2006 chicago il usa edith cohen haim kaplan spatiallydecaying aggregation network model algorithms proceedings 2004 acm sigmod international conference management data june 1318 2004 paris france arvind arasu jennifer widom resource sharing continuous slidingwindow aggregates proceedings thirtieth international conference large data bases p336347 august 31september 03 2004 toronto canada brian babcock chris olston distributed topk monitoring proceedings acm sigmod international conference management data june 0912 2003 san diego california edith cohen haim kaplan spatiallydecaying aggregation network journal computer system sciences v73 n3 p265288 may 2007 yishan jiao maintaining stream statistics multiscale sliding windows acm transactions database systems tods v31 n4 p13051334 december 2006 lukasz golab tamer zsu issues data stream management acm sigmod record v32 n2 p514 june
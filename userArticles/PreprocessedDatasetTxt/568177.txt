obtaining knuth morris pratts string matcher partial evaluation present first formal proof partial evaluation quadratic string matcher yield precise behaviour knuth morris pratts linear string matcherobtaining kmplike string matcher canonical example partial evaluation starting naive quadratic program checking whether pattern occurs text one ensures backtracking performed partialevaluation time bindingtime shift yields staged string matcher specializing resulting staged program yields residual programs back text la kmp aware however formal proof partial evaluation staged string matcher precisely yields kmp string matcher fact specific string matcherin article present staged string matcher formally prove performs sequence comparisons pattern text kmp string matcher end operationally specify programming languages matchers written formalize sequence comparisons trace semantics also state mild conditions specializing staged string matcher respect pattern string provably yields specialized string matcher whose size proportional length pattern string whose time complexity proportional length text string finally show tabulating one functions staged string matcher gives rise next table original kmp algorithmthe method scales obtaining linear string matchers known new b introduction obtaining knuth morris pratts linear string matcher naive quadratic string matcher traditional exercise partial evaluation run match pat res run pe match pat run match pat res given static pattern partial evaluator perform backtracking statically produce specialized matcher traverses text linear time initially exercise proposed futamura illustrate generalized partial computation form partial evaluation memoizes result dynamic tests processing conditional branches 10 1 subsequently consel danvy pointed bindingtime improved ie staged quadratic string matcher could also specialized linear string matcher using standard mixstyle partial evaluator 7 number publications followed showing either range bindingtime improved string matchers presenting range partial evaluators integrating bindingtime improvement 1 9 11 12 15 23 24 25 15 years however observe 1 kmp test called appears little impact development algorithms outside field partial evaluation 2 except grobauer lawalls recent work 13 issues precise characterization time space specialized string matchers addressed goal work address second item hope contribute remedying first one long run 11 work relate original kmp algorithm 18 staged quadratic string matcher keeps one character negative information essentially consel danvys original solution 7 many ways stage string matcher 1 13 show one appendix approach semantic rather algorithmic intuitive 1 example dynamic test comparison static ie known character pattern dynamic ie unknown character text one conditional branch characters match statically know dynamic character branch characters mismatch statically know dynamic character former piece positive information latter piece negative information formalize imperative language similar one kmp algorithm traditionally specified formalize subset scheme staged matcher specified present two trace semantics account sequence indices corresponding successive comparisons characters pattern text show kmp algorithm staged matcher share trace analyze binding times staged matcher using otheshelf bindingtime analysis similix 3 4 observe dynamic comparisons ones static pattern dynamic text therefore specializing staged string matcher preserves trace given oine program specializer similixs 1 computes static operations specialization time 2 generates residual program dynamic operations disappear duplicated executed order source program also assess size residual programs proportional size corresponding static patterns 2 correspondence preservation traces shows staged matcher keeps one character negative information corresponds specializes second half kmp algorithm precisely also two corollaries 1 staged matcher keep track negative information srensen gluck joness work positive supercompilation 25 give rise kmp algorithm instead observe staged matcher gives rise morris pratts algorithm 5 chapter 6 also linear slightly less ecient 2 staged string matcher keeps track characters negative information accumulated consecutive character mismatches futamuras generalized partial computation 9 11 gluck klimovs supercompiler 12 jones gomard sestofts textbook 15 figure 123 give rise kmp algorithm either corresponding residual programs slightly ecient kmp algorithm size linearly proportional length pattern indeed grobauer lawall shown size residual programs bounded pat pat denotes pattern denotes alphabet 13 said linear string matching kmp example handbook exact string matching 5 charras lecroq list dierent algorithms follow tradition counting size integers units example table integers size log n integers lie interval 0 n 1 consider size b many naive string matchers exist staged yield variety linear string matchers eg boyer moores 1 observe half algorithms listed charras lecroq obtained specialized versions staged string matchers proving observation done manner present article kmp furthermore obtain new linear string matchers exploring variety staged string matchers 12 overview rest article organized follows section 2 specify operational semantics imperative language used knuth morris pratt section 3 specify operational semantics subset scheme 16 sections specify 1 abstract syntax language 2 expressible values 3 evaluation rules 4 string matcher 5 semantics string matcher 6 abstract semantics string matcher point abstract semantics account sequence comparisons pattern text knuth morris pratts algorithm imperative matcher staged string matcher functional matcher lemmas 1 2 show abstract semantics faithfully account comparisons pattern text string matchers theorem 1 establishes correspondence abstract imperative matcher section 26 theorem 1 section abstract functional matcher section 36 concrete imperative matcher section 25 section 26 concrete functional matcher section 35 section 36 section 4 show imperative matcher functional matcher give rise sequence comparisons section 5 investigate result specializing functional matcher respect pattern string using program specialization using simple form data specialization section 6 concludes 2 kmp imperatively section describe imperative language imperative string matcher specified language canonical constant mutable identifiers immutable arrays present imperative string matcher meaning finally specify trace semantics imperative matcher 21 abstract syntax program consists statements stm expressions e exp numerals mutable identifiers x mid array identifiers aid operators opr opr xe ss e else fi e od return e e num x c ae e opr e e e 22 expressible values value integer boolean character alphabet 23 rules following rules e exp v 231 auxiliary constructs language includes numeric operators comparison operator characters 232 stores store total function 233 constants constants defined total function 234 arrays arrays defined partial function n denotes set natural numbers including zero indexing arrays starts zero indexing bounds undefined 235 relations bigstep evaluation relation expressions reads smallstep evaluation relation statements reads r stm computation progress r unit computation completed normally r z computation aborted return choose bigstep evaluation relation expressions interested intermediate evaluation steps choose smallstep evaluation relation statements want monitor progress imperative computations 236 expressions var array 237 statements assign e od unit e od swhile e od c return e n 24 string matcher kmp algorithm consists two parts initialization next table actual string matching 18 241 initialization next table first part builds next table pattern satisfying following definition table next table array indices length pattern next j largest less j pat j exists next j 1 initialization next table described pseudocode figure assume pat txt lpat ltxt given initial store pat denotes pattern lpat length txt denotes text ltxt length j lpat 1 0 patj patt nextj nextt else nextj od figure 1 initialization next table 242 string matching second part traverses text using next table described program figure 2 written imperative language specified sections 21 22 23 second part lpat ltxt constant identifiers j k mutable identifiers pat txt next array identifiers pat denotes pattern lpat length txt denotes text ltxt length 3 write pseudocode instead code language sections 21 22 23 arrays immutable could easily extend language support mutable arrays would clutter rest development side conditions expressing next table updated second part kmp algorithm therefore chosen simplify language jlpat kltxt j 0 patj txtk figure 2 imperative string matcher rest article consider second part kmp algorithm refer imperative matcher 25 semantics imperative matcher consider meaning imperative matcher state without proof imperative matcher terminates accesses pattern text next table within bounds sequence indices corresponding successive comparisons characters pattern text imperative language deterministic kmp algorithm correct string matcher sequence exists unique imperative comparison string matcher section 24 derivation tree form derivation tree definition 3 index following function maps imperative comparison corresponding pair indices pattern text index definition 4 computation imperative computation derivation imperative matcher premises 0 1 sn1 derivation trees contains pattern text next table c contains length pattern text 0 imperative matcher 0 initial state mapping identifiers zero computation said complete r 1 n imperative computation premise might contain imperative com parisons want build sequence indices corresponding successive comparisons characters pattern text applying index function imperative comparisons premise gives indices collect sequence nonempty sets pairs indices follows premises imperative computation let c set imperative comparisons n imperative trace sequence neutral element concatenation section 26 lemma 1 shows premises definition 5 contains one imperative comparison therefore p either empty singleton set imperative trace thus sequence singleton sets corresponds successive comparisons characters pat txt choose three program points one checking whether end pattern end text one comparing character pattern character text one reinitializing index pattern ie shifting pattern 18 page 324 based next table definition 6 program points imperative program points match compare shift defined following sets configurations match compare shift jlpat kltxt j 0 patj txtk set imperative program points defined sum compare 26 abstract semantics definition 7 abstract states set abstract imperative states sum set abstract imperative final states set abstract imperative intermediate states states states int states fin states int match compare shift injection tags definition 8 program points abstract states define correspondence abstract imperative states union imperative program points final results following relation states int pp match j match compare j compare shift j definition 9 abstract matcher let pat txt let next next table pat abstract imperative matcher following total function states int states match j compare j compare j shift j compare nextj match function last yields last element nonempty sequence abstract states last states last definition 11 abstract computations let pat txt let corresponding abstract imperative matcher set abstract imperative computations abscomp states least set closed 1 match 0 last p p abscomp said complete last states fin computations faithful abstract imperative computations represent imperative computations faithfully words 1 imperative computation starts initial derivation either contain program points 1 contain program points apart final configuration 2 contain comparisons 3 final configuration program point p match match 0 p 2 whenever last configuration imperative computation imperative program point p related abstract state exists imperative program point final result p abstract state following holds 1 derivation p p contain program points 2 3 p 4 derivation contains comparison c index proof part 1 straightforward verify part 2 must divide cases dictated abstract matcher show single case p match k cases similar derivation jlpat kltxt od unit jlpat kltxt od else return j lpat return kj else return c j lpat return kj else return return kj var since match j kj also kj n furthermore observe derivation contains program points comparisons since one comparison exists step derivation imperative trace definition 5 sequence singleton sets moreover since imperative matcher terminates abstract matcher well definition 12 abstract trace abstract imperative trace maps sequence abstract states another sequence abstract states trace states trace following corollary lemma 1 shows abstract imperative traces represent imperative traces corollary 1 imperative traces faithful let pat txt given imperative trace complete imperative computation let compare j abstract imperative trace corresponding complete abstract imperative computation words abstract trace faithfully represents imperative trace 27 summary formally specified imperative string matcher implementing kmp algorithm given trace semantics accounting indices successively compares characters pattern text next section turn functional string matcher treat similarly 3 kmp functionally section describe functional language functional string matcher specified language firstorder subset scheme tail recursive equations present functional string matcher meaning finally specify trace semantics functional matcher 31 abstract syntax program consists serious expressions e exp trivial expressions triv operators opr opr numerals num num value identifiers x vid function identifiers f fid sequences value identifiers x vid 32 expressible values value integer boolean character string 33 rules 331 auxiliary constructs language includes numeric operators comparison operator characters stringindexing operator c ith character indexing strings starts zero indexing bounds undefined 332 environments expressions evaluated value environment venv function environment 333 relations bigstep evaluation relation trivial expressions reads smallstep evaluation relation serious expressions reads e f r choose bigstep evaluation relation trivial expressions interested intermediate evaluation steps choose smallstep evaluation relation serious expressions want monitor progress computations 334 programs top level program evaluated initial function environment 0 holding predefined functions initial value environment 0 holding predefined values initial configuration program thus e 0 0 function environment 335 trivial expressions var 336 serious expressions 34 string matcher consider string matcher figure 3 motivated appendix written subset scheme specified sections 31 32 33 initial environment 0 binds pat lpat pattern length txt ltxt text length none pat txt lpat ltxt bound program therefore denote initial values throughout rest article refer string matcher functional matcher 35 semantics functional matcher consider meaning functional matcher sequence indices corresponding successive comparisons characters pattern text functional comparison string matcher section 34 derivation tree form denotes another derivation tree letrec match lambda j k ltxt compare j k compare lambda j eq stringref pat match 0 match rematch rematch lambda j k jp kp kp eq stringref pat jp jp match rematch compare jp k eq stringref pat jp rematch rematch match figure 3 functional matcher definition 14 index following function maps functional comparison corresponding pair indices pattern text index f definition 15 computation functional computation derivation functional matcher premises derivation trees initial function environment e 0 functional matcher 0 value environment mapping pat txt lpat ltxt pattern text lengths respectively value identifiers zero computation said complete r 1 n functional computation premise might contain functional compar isons want build sequence indices corresponding successive comparisons characters pattern text applying index function functional comparisons premise gives indices collect sequence nonempty sets pairs indices follows definition premises functional computation let c set functional comparisons e n functional trace sequence otherwise section 36 lemma 2 shows premises definition 16 contains one functional comparison therefore p either empty singleton set functional trace thus sequence singleton sets corresponds successive comparisons characters pat txt choose three program points one checking whether end pattern end text one comparing character pattern character text one matching pattern prefix sux pattern program points correspond bodies match compare rematch functions definition 17 program points functional program points match f compare f rematch f defined following sets configurations match compare f rematch body match function c body compare function r body rematch function set functional program points defined sum compare f rematch f 36 abstract semantics definition abstract states set abstract functional states sum set abstract functional final states set abstract functional intermediate states f states int f states fin f states int f rematch n n n n match compare rematch injection tags definition 19 program points abstract states define correspondence abstract functional states union functional program points final results following relation f states int match j compare j rematch j k jp kp f e rematch f definition 20 abstract matcher let pat txt abstract functional matcher following total function f states int match j compare j compare j match rematch j k 0 1 otherwise rematch j k jp kp f match compare jp rematch j k jp definition 21 last function last f yields last element nonempty sequence abstract states last last definition 22 abstract computations let pat txt let f corresponding abstract functional matcher set abstract functional computations abscomp f states f least set closed 1 match 0 last f f p p abscomp f said complete last f states fin f computations faithful abstract functional computations represent functional computations faithfully words 1 functional computation starts initial derivation either contain program points 1 contain program points apart final configuration 2 contain comparisons 3 final configuration program point p match f match 0 2 whenever last configuration functional computation functional program point p related abstract state f exists functional program point final result p abstract state following holds 1 derivation p p contain program points 2 f 3 f p 4 derivation contains comparison c indexf proof part 1 straightforward verify part 2 must divide cases dictated abstract matcher show single case p match f txt cases similar derivation var var compare app c denotes body compare function definition 17 since match j k also compare j k corresponds final configuration derivation furthermore observe derivation contains program points comparisons since one comparison exists step derivation functional trace definition 16 sequence singleton sets moreover one matchers terminates well definition 23 abstract trace abstract functional trace maps sequence abstract states another sequence abstract states trace trace following corollary lemma 2 shows abstract functional traces traces corollary 2 functional traces faithful let pat txt given functional trace complete functional computation let compare j abstract trace corresponding complete abstract functional compu tation words abstract trace faithfully represents functional trace lemma 3 invariants let pat txt abscomp f corresponding set abstract functional computations 1 following conditions whose conclusions call invariants satisfied proof let pat txt given let abscomp f proof structural induction base case show invariants hold initially induction cases show invariants preserved match compare rematch initialization definition abscomp f initial abstract functional state computation match 0 0 lengths strings pat txt nonnegative insertion obtain 0 m2 thus hold trivially initial abstract functional state preservation match let us assume invariants m1 m2 hold abstract functional state match j k consider three possible cases j next abstract state abstract functional computation therefore kj invariants preserved 1 next abstract state therefore 1 invariants preserved next abstract state therefore compare k case assumption invariants c1 c2 invariants thus preserved match preservation compare let us assume invariants c1 c2 hold abstract functional state compare j k consider three possible cases 1 next abstract state abstract functional computation match 1 since j k pat txt integers j pat hold since premises true invariants c1 c2 invariants m1 m2 hold txtk patj 0 definition compare j 1 next abstract state match 1 argument identical obtain invariant m2 inserting value invariant m1 done initalization case also obtain invariant m1 txtk patjj 0 definition compare j next abstract state rematch due c1 j 0 r1 holds c2 identical r2 thus r3 holds convention denotes empty string similarly patkp jp denotes empty string invariant r4 holds finally r5 holds trivially interval 1 kp jp 1 0 denotes empty set convention invariants thus preserved compare preservation rematch let us assume invariants r1 r2 r3 r4 r5 hold abstract functional state rematch j k jp kp consider five possible cases 0 definition rematch j k jp kp f match 1 next abstract state abstract functional computation match 1 invariant r2 obtain shown 0 definition rematch j k jp kp f 1 next abstract state rematch invariants r1 r2 hold j k trivial updates immediately give invariants r1 r2 kp since j invariant r3 satisfied first look pat0 patjp 1 empty string since 1 empty string therefore invariant r4 holds invariant know body r5 holds every k interval 1 kp jp 2 since j need show pat0 patj k specifically 1 easily seen since case assumption give patj invariant r5 holds k next abstract state therefore compare r1 r3 case assumption holds since k kp 1 next abstract state therefore rematch give us r3 pat0 patjp need show patjp true case assumption thus r4 holds since interval k unchanged holds assumption kp j patjp patkp definition rematch j k jp kp f rematch j k 0 kp jp 1 next abstract state therefore rematch trivial update j k r1 r2 shown still hold clearly jp 0 assumption kp jp gives us kp finally since kp j kp1 j kp thus invariant r3 holds shown second case strings empty condition thus invariant r4 holds similarly second case need show pat0 patj specifically holds consider jpth k jpth entries characters patjp patkp respectively since k kp case assumption entries distinct conclude showing first string contains jpth entry case assumption us 0 jp thus invariant r5 holds key connection abstract functional matcher abstract imperative matcher stated following remark remark shows interpret invariant r5 terms next table remark 1 notice j 0 b k bpat0 patj definition 1 next j cannot occur interval j b j indeed k j pat0 patj k patj k patj j k candidate nextj therefore negation condition gives us j k candidate nextj 37 summary formally specified functional string matcher given trace semantics accounting indices successively compares characters pattern text next section show given pattern text traces imperative matcher functional matcher coincide extensional correspondence imperative functional matchers definition 24 correspondence define correspondence imperative functional states relation states states f match j compare j shift j define states states f sequences f hold empty sequences synchronization relation sync states states f defined trace trace f last last f theorem 1 abstract equivalence given pattern text unique complete abstract imperative computation unique complete abstract functional computation two abstract computations synchronized ie syncs holds proof let pat txt given let abscomp proof structural induction abstract computation base case prove abstract computations start abstract state therefore initially synchronized induction cases prove synchronization always preserved initialization definition abscomp abscomp f abstract computations start abstract state match 0 0 since syncmatch 0 0 match 0 0 holds abstract computations initially synchronized preservation match assumption initial subsequences synchronized ie synci holds last last f match j k three cases occur exhaustive invariants lemma 3 j similarly definition match j j assumption synci holds therefore thus complete abstract computations synchronized similarly definition match j 1 synchronization preserved since computations end integer j pat k txt definition match j larly definition match j assumption synci compare j k compare j k also holds synchronization thus preserved cases preservation compare assumption initial subsequences synchronized ie synci holds last last f compare j k three cases occur exhaustive invariants lemma 3 txtk patj 0 definition compare j 1 similarly definition compare j since definition since synci assumption shift states included abstract trace synci shift j match txtk patjj 0 definition compare j similarly definition compare j holds assumption shift j 1 similarly definition compare j synci holds assumption synci match j 1 k1 match synchronization preserved cases preservation rematch shift assumption initial subsequences synchronized ie synci holds last last f rematch j k jp kp since definition 24 shift j jp kp consider cases abstract functional computation goes abstract state form dierent rematch j k jp kp sound recursive calls rematch function never diverge lexicographic ordering kp jp jp termination relation rematch call match compare two cases occur 0 definition rematch j k jp kp f match 1 know invariant r5 holds k interval remark 1 implies next j case assumption know next j 1 j 1 next therefore definition abstract imperative matcher shift j synci holds assumption synci match 0 k1 match 0 k1 also holds due invariants r1 r3 jp pat definition rematch j k jp kp f compare jp k know body invariant r5 holds k interval 1 jjp1 remark 1 gives us next j jp1 j1 r4 know case assumption patjp patj therefore jp candidate next j since next j since next j largest value less j satisfying requirements next invariant r3 know jp 0 definition abstract imperative matcher shift j compare jp k since synci holds assumption synci compare jp k compare jp k also holds since kmp algorithm terminates since abstract matchers total functions complete abstract computations exist unique position state main result captured diagram section 12 abstract imperative matcher section 26 theorem 1 section abstract functional matcher section 36 concrete imperative matcher section 25 section 26 concrete functional matcher section 35 section 36 corollary 3 equivalence let pat txt given 1 corresponding complete imperative computation c final configuration n number n 2 corresponding complete functional computa tion c final configuration n number n 3 4 traces c c equal proof theorem 1 abstract functional matcher terminates corollary 2 functional matcher complete functional computation therefore exists lemma 1 lemma 2 corollaries abstract computations represent computations trace result represented faithfully finally theorem 1 abstract computations synchronized means abstract traces results equal summarize shown given pattern text traces imperative matcher functional matcher coincide sense two matchers albeit dierent time complexity next section show eliminate extra complexity functional matcher using partial evaluation 5 intensional correspondence imperative functional matchers turn specializing functional string matcher respect given patterns first use partial evaluation ie program specialization next consider simple form data specialization first show size specialized programs linear size pattern specialized programs run time linear size text next show specialized data coincides next table kmp section informal makes somewhat liberal use partial evaluation terminology 21 define main pat txt let lpat stringlength pat ltxt stringlength txt letrec match lambda j k compare j k compare lambda j k match 0 match rematch rematch lambda j k jp kp kp eq stringref pat jp jp match rematch compare jp k eq stringref pat jp rematch rematch match figure 4 bindingtime annotated functional matcher 51 program specialization figure 4 displays bindingtime annotated version complete functional matcher derived appendix formal parameters tagged static dynamic depending whether denote values depend data available partialevaluation time whether denote values may depend data available run time addition dynamic conditional expressions dynamic tests dynamic additions subtractions boxed parts source program static evaluated partialevaluation time dynamic parts reconstructed giving rise residual program partial evaluator similix 3 4 designed preserve dynamic computations order present case dynamic tests among dynamic computations guaranteed occur specialized programs order source program therefore construction similix generates programs traverse text order functional matcher thus kmp algorithm example specialized functional matcher respect pattern abac without postunfolding resulting residual program displayed figure 5 lambdadropping 8 renaming character following subscripts next character pattern matched textan intuitive notation suggested grobauer lawall 13 specialized string matcher traverses text linearly compares characters text literal characters pattern article 18 page 330 knuth morris pratt display similar program next table compiled control flow come back point end section 52 revisitation partial evaluation pattern matching strings 13 grobauer lawall analyzed size complexity residual code produced similix measured terms number residual tests showed size residual program linear length pattern time complexity linear length text manner show similix yields residual program linear length pattern whose time complexity linear length text similix polyvariant programpoint specializer builds mutually recursive specialized versions source program points default conditional expressions dynamic tests source program point specialized respect set static values corresponding residual program point indexed set source program point met set static values residual call corresponding residual program point generated proposition 1 specializing functional matcher figure 4 respect pattern yields residual program whose size linear length pattern proof informal functions residual code generated main match compare first one main goal function contains memoization points one residual main function generated exactly one memoization pointa dynamic conditional expression functions match compare static data available two memoization points bound j pat lpat piece static data varies value j ie j since 0 j pat memoization points invariants lemma 3 section 4 fact memoization point match reached j pat pat variants two memoization points generated number define mainabac txt let ltxt stringlength txt define match abac define compare abac eq stringref txt k match abac k 1 match abac k 1 define match abac define compare abac eq b stringref txt k match abac k 1 compare abac k define match abac define compare abac eq stringref txt k match abac k 1 match abac k 1 define match abac define compare abac eq c stringref txt k compare abac k match abac 0 txt evaluating mainabac txt yields result evaluating main abac txt k evaluating match abac k scope ltxt yields result evaluating match 0 k scope lpat ltxt lpat denotes length pat ltxt denotes length txt k evaluating match abac k scope ltxt yields result evaluating match 1 scope lpat ltxt k evaluating match abac k scope ltxt yields result evaluating match 2 k scope lpat ltxt k evaluating match abac k scope ltxt yields result evaluating match 3 k scope lpat ltxt figure 5 result specializing functional matcher wrt abac residual functions therefore linear size pattern addition size function bounded small constant seen one writes bnf residual programs 20 proposition 2 specializing functional matcher figure 4 respect pattern yields residual program whose time complexity linear length text proof informal proven knuth morris pratt kmp algorithm performs number comparisons characters pattern text linear length text 18 corollary 3 shows functional matcher performs exact sequence comparisons characters pattern text kmp algorithm comparisons performed compare function exactly one comparison performed call compare number calls compare therefore linear length text since match function either terminates calls compare number calls match bounded number calls compare proposition 1 residual code generated functions main compare match time complexity functions main compare match easily seen bounded small constant since main called number calls compare match linear length text time complexity residual program linear length text 52 data specialization section 36 remark 1 connects rematch function functional matcher next table kmp algorithm section revisit connection show actually derive kmp algorithm next table functional matcher using simple form data specialization 2 6 17 19 end first restate functional matcher functional matcher functions tail recursive ie iteratively call particular rematch completes either calling match calling compare two actual parameters match 0 literal increment k available scope match two actual parameters compare jp computed course rematch k available scope compare make possible tabulate rematch function modify functional matcher longer tail recursive instead rematch call match compare tail recursively make return value call match compare set value jp natural number 1 correspondingly instead compare call rematch tail recursively make dispatch result rematch call match compare tail recursively result displayed figure 6 proof theorem 1 show rematch terminates calling compare jp equal next j kmp algorithm also show define main pat txt let lpat stringlength pat ltxt stringlength txt letrec match lambda j k ltxt compare j k compare lambda j eq stringref pat match 0 match let next rematch j 0 1 next 1 match compare next k rematch lambda j jp kp kp eq stringref pat jp jp rematch eq stringref pat jp rematch rematch match figure variation functional matcher match called rematch value next j kmp algorithm 1 call rematch compare therefore calling new rematch function equivalent lookup next table kmp algorithm particular tabulating pat input values rematch corresponding j 0 pat 1 yields next table used kmp algorithm simple data specialization yields string matcher traverses text linearly matching pattern looking next index pattern next table case mismatch words data specialization functional matcher yields kmp algorithm particular specializing string matcher figure 6 tabulated version respect pattern would compile corresponding next table control flow residual program result would coincide compiled code knuth morris pratts article 18 page 330 6 conclusion issues presented first formal proof partial evaluation precisely yield kmp extensionally trace semantics synchronization intensionally size specialized programs relation next table actual derivation kmp algorithm shown key obtaining kmp naive quadratic string matcher keep backtracking static control also maintain exactly one character negative formation consel danvys original solution together grobauer lawalls complexity proofs size time complexity residual programs buildup corollary 3 paves way relating eect staged string matchers independently known string matchers eg boyer moores 1 work led us consider family kmp algorithms relation following family staged string matchers staged string matcher keep track negative information gives rise knuth morris pratts next table f function 18 page 327 ie morris pratts algorithm 5 chapter 6 tabulating function yields array size pattern staged string matcher keeps track one character negative information corresponds knuth morris pratts algorithm next table staged string matcher keeps track limited number characters negative information gives rise kmplike algorithm corresponding residual programs ecient also bigger staged string matcher keeps track characters negative information also gives rise kmplike algorithm corresponding residual programs even ecient also even bigger grobauer lawall shown size residual programs bounded pat size alphabet 13 however conjecture string matchers keep track two characters negative information tighter upper bound size twice length pattern ie 2pat conjecture holds short patterns let us conclude two points obtaining ecient string matchers partial evaluation naive string matcher obtaining eciently essence obtaining ecient string matchers partial evaluation naive string matcher ensure backtracking naive matcher static one either stage naive matcher use simple partial evaluator keep naive matcher unstaged use sophisticated partial evaluator matters backtracking carried specialization time dynamic computations preserved specialized programs size residual programs provides lower bound time complexity specialization example looking kmp size residual program proportional size pattern positive information kept best generalpurpose partial evaluator could thus proceed time linear pat ie opat first pass kmp algorithm ever evaluating static parts source program specialization time driven static control flow source program seem like optimal strategy even discounting complexity bindingtime analysis example data specialization section 52 works time quadratic pat ie opat 2 construct next table hand ecient treatment could one bullets partial evaluators gun 22 section 11 ie treatment generally applicable dramatic eect occasionally example proving conjecture could lead bullet acknowledgments grateful torben amtoft julia lawall karoline malmkjr jan midtgaard mikkel nygaard anonymous reviewers variety comments special thanks andrzej filinski comments led us reshape article work supported esprit working group appsem http wwwmdchalmerssecsresearchsemanticsappsem staging quadratic string matcher figure 7 displays naive quadratic string matcher successively checks whether pattern pat prefix one successive suxes text txt main function initializes indices j k access pat txt match function checks whether matching finished either success failure whether one comparison needed compare function carries comparison either continues match rest pat rest current sux txt starts match pat next sux txt figure 8 displays staged version quadratic string matcher instead matching pat next sux txt version uses rematch function recompare function first match pat prefix sux pat know equal corresponding segment txt eventually rematch function resumes matching rest pattern rest txt result staged string matcher backtrack txt partialevaluation jargon string matcher figure 8 uses positive information text see footnote 1 page 4 piece negative information also available namely latest character provoked mismatch figure 9 displays staged version quadratic string matcher exploits negative information rather blindly resuming compare function rematch function first checks whether character caused latest mismatch could cause new mismatch thereby avoiding one access text simplify formal development inline recompare rematch lambdalift rematch lexical level match compare 8 14 resulting string matcher displayed figure 10 section 34 course many ways stage string matcher one chosen easy derive easy reason r abstraction instantiation stringmatching programs mixed computation translation linearisation decomposition compilers similix 51 manual automatic autoprojection recursive equations global variables abstract data types exact string matching algorithms sandrine chiroko partial evaluation pattern matching strings transforming recursive equations programs block structure program transformation system based generalized partial computation generalized partial computation essence generalized partial computation occams razor metacomputation notion perfect process tree partial evaluation pattern matching strings lambda lifting transforming programs recursive equations partial evaluation automatic program generation revised 5 report algorithmic language scheme data specialization fast pattern matching strings program data specialization principles abstract interpretation partialevaluation algo rithms transformationbased optimiser haskell christian queinnec jeanmarie geroy partial evaluation pattern matching constraint logic programming languages positive su percompiler tr lambda lifting transforming programs recursive equations partial evaluation pattern matching strings partial evaluation pattern matching constraint logic programming languages automatic autoprojection recursive equations global variable abstract data types essence generalized partial computation partial evaluation automatic program generation abstract interpretation partial evaluation algorithms data specialization transformationbased optimiser haskell lambdadropping glossary partial evaluation related topics program transformation system based generalized partial computation revised report algorithmic language scheme combining program data specialization occams razor metacompuation partial evaluation pattern matching strings revisited ctr mads sig ager olivier danvy henning korsholm rohde fast partial evaluation pattern matching strings acm sigplan notices v38 n10 p39 october yoshihiko futamura zenjiro konishi robert glck automatic generation efficient string matching algorithms generalized partial computation proceedings asian symposium partial evaluation semanticsbased program manipulation p18 september 1214 2002 aizu japan olivier danvy henning korsholm rohde obtaining boyermoore stringmatching algorithm partial evaluation information processing letters v99 n4 p158162 31 august 2006 mads sig ager olivier danvy henning korsholm rohde fast partial evaluation pattern matching strings acm transactions programming languages systems toplas v28 n4 p696714 july 2006 germn vidal costaugmented partial evaluation functional logic programs higherorder symbolic computation v17 n12 p746 marchjune 2004